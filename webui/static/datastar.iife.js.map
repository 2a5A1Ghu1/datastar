{"version":3,"file":"datastar.iife.js","sources":["../src/lib/dom.ts","../src/lib/eval.ts","../src/lib/external/reactively.ts","../src/lib/core.ts","../src/lib/extensions/actions.ts","../src/lib/extensions/bind.ts","../src/lib/extensions/focus.ts","../src/lib/external/idiomorph.ts","../src/lib/extensions/fragments.ts","../src/lib/extensions/model.ts","../src/lib/extensions/on.ts","../src/lib/extensions/ref.ts","../src/lib/extensions/show.ts","../src/lib/extensions/signal.ts","../src/lib/extensions/teleport.ts","../src/lib/extensions/text.ts","../src/lib/extensions/intersects.ts","../src/lib/extensions/index.ts","../src/lib/mockFetch.ts"],"sourcesContent":["export function walkDownDOM(el: Element | null, callback: (el: Element) => void) {\n  if (!el) return\n  callback(el)\n\n  el = el.firstElementChild\n\n  while (el) {\n    walkDownDOM(el, callback)\n    el = el.nextElementSibling\n  }\n}\n\n/**\n * Walks up the DOM tree, starting from the given element, and calls the callback for each element.\n * @param el The element to start from.\n * @param callback The callback to call for each element.\n */\nexport function walkUpDOM(el: Element | null, callback: (el: Element) => void) {\n  if (!el) return\n  callback(el)\n\n  el = el.parentElement\n  walkUpDOM(el, callback)\n}\n","import { ActionsMap, NamespacedReactiveRecordCallback, NamespacedReactiveRecords } from './types'\n\nexport function functionGenerator<T>(str: string): NamespacedReactiveRecordCallback<T> {\n  const fnContents = `return ${str}`\n  const fn = new Function('el', 'dataStack', 'actions', fnContents)\n  return fn as NamespacedReactiveRecordCallback<T>\n}\n\nexport function functionEval(el: Element, dataStack: NamespacedReactiveRecords, actions: ActionsMap, str: string) {\n  const fn = functionGenerator(str)\n  try {\n    return fn(el, dataStack, actions)\n  } catch (e) {\n    console.error(`Error evaluating expression: ${str}`)\n  }\n}\n\nexport function camelize(str: string) {\n  return str\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => {\n      return index === 0 ? word.toLowerCase() : word.toUpperCase()\n    })\n    .replace(/\\s+/g, '')\n}\n","/**\n * Nodes for constructing a reactive graph of reactive values and reactive computations.\n * The graph is acyclic.\n * The user inputs new values into the graph by calling set() on one more more reactive nodes.\n * The user retrieves computed results from the graph by calling get() on one or more reactive nodes.\n * The library is responsible for running any necessary reactive computations so that get() is\n * up to date with all prior set() calls anywhere in the graph.\n *\n * We call input nodes 'roots' and the output nodes 'leaves' of the graph here in discussion,\n * but the distinction is based on the use of the graph, all nodes have the same internal structure.\n * Changes flow from roots to leaves. It would be effective but inefficient to immediately propagate\n * all changes from a root through the graph to descendant leaves. Instead we defer change\n * most change progogation computation until a leaf is accessed. This allows us to coalesce computations\n * and skip altogether recalculating unused sections of the graph.\n *\n * Each reactive node tracks its sources and its observers (observers are other\n * elements that have this node as a source). Source and observer links are updated automatically\n * as observer reactive computations re-evaluate and call get() on their sources.\n *\n * Each node stores a cache state to support the change propogation algorithm: 'clean', 'check', or 'dirty'\n * In general, execution proceeds in three passes:\n *  1. set() propogates changes down the graph to the leaves\n *     direct children are marked as dirty and their deeper descendants marked as check\n *     (no reactive computations are evaluated)\n *  2. get() requests that parent nodes updateIfNecessary(), which proceeds recursively up the tree\n *     to decide whether the node is clean (parents unchanged) or dirty (parents changed)\n *  3. updateIfNecessary() evaluates the reactive computation if the node is dirty\n *     (the computations are executed in root to leaf order)\n */\n\n/** current capture context for identifying @reactive sources (other reactive elements) and cleanups\n * - active while evaluating a reactive function body  */\nlet CurrentReaction: Reactive<any> | undefined = undefined\nlet CurrentGets: Reactive<any>[] | null = null\nlet CurrentGetsIndex = 0\n\n/** A list of non-clean 'effect' nodes that will be updated when stabilize() is called */\nlet EffectQueue: Reactive<any>[] = []\n\nlet stabilizeFn: ((node: Reactive<any>) => void) | undefined = undefined // fn to call if there are dirty effect nodes\nlet stabilizationQueued = false // stabilizeFn() is queued to run after this event loop\n\n/** reactive nodes are marked dirty when their source values change TBD*/\nexport const CacheClean = 0 // reactive value is valid, no need to recompute\nexport const CacheCheck = 1 // reactive value might be stale, check parent nodes to decide whether to recompute\nexport const CacheDirty = 2 // reactive value is invalid, parents have changed, valueneeds to be recomputed\nexport type CacheState = typeof CacheClean | typeof CacheCheck | typeof CacheDirty\ntype CacheNonClean = typeof CacheCheck | typeof CacheDirty\n\nexport function logDirty(_enable?: boolean): void {\n  // TBD for a debug build\n}\n\nexport interface ReactivelyParams {\n  equals?: (a: any, b: any) => boolean\n  effect?: boolean\n}\n\n/** A reactive element contains a mutable value that can be observed by other reactive elements.\n *\n * The property can be modified externally by calling set().\n *\n * Reactive elements may also contain a 0-ary function body that produces a new value using\n * values from other reactive elements.\n *\n * Dependencies on other elements are captured dynamically as the 'reactive' function body executes.\n *\n * The reactive function is re-evaluated when any of its dependencies change, and the result is\n * cached.\n */\nexport function reactive<T>(fnOrValue: T | (() => T), params?: ReactivelyParams): Reactive<T> {\n  const node = new Reactive(fnOrValue, params?.effect)\n  if (params?.equals) {\n    node.equals = params.equals\n  }\n  return node\n}\n\nfunction defaultEquality(a: any, b: any) {\n  return a === b\n}\n\n/** A reactive element contains a mutable value that can be observed by other reactive elements.\n *\n * The property can be modified externally by calling set().\n *\n * Reactive elements may also contain a 0-ary function body that produces a new value using\n * values from other reactive elements.\n *\n * Dependencies on other elements are captured dynamically as the 'reactive' function body executes.\n *\n * The reactive function is re-evaluated when any of its dependencies change, and the result is\n * cached.\n */\nexport class Reactive<T> {\n  private _value: T\n  private fn?: () => T\n  private observers: Reactive<any>[] | null = null // nodes that have us as sources (down links)\n  private sources: Reactive<any>[] | null = null // sources in reference order, not deduplicated (up links)\n\n  private state: CacheState\n  cleanups: ((oldValue: T) => void)[] = []\n  equals = defaultEquality\n\n  constructor(\n    fnOrValue: (() => T) | T,\n    readonly isEffect = false,\n  ) {\n    if (typeof fnOrValue === 'function') {\n      this.fn = fnOrValue as () => T\n      this._value = undefined as any\n      this.isEffect = isEffect || false\n      this.state = CacheDirty\n      if (isEffect) {\n        EffectQueue.push(this)\n        stabilizeFn?.(this)\n      }\n    } else {\n      this.fn = undefined\n      this._value = fnOrValue\n      this.state = CacheClean\n      this.isEffect = false\n    }\n  }\n\n  get value(): T {\n    return this.get()\n  }\n\n  set value(v: T) {\n    this.set(v)\n  }\n\n  get(): T {\n    if (CurrentReaction) {\n      if (!CurrentGets && CurrentReaction.sources && CurrentReaction.sources[CurrentGetsIndex] == this) {\n        CurrentGetsIndex++\n      } else {\n        if (!CurrentGets) CurrentGets = [this]\n        else CurrentGets.push(this)\n      }\n    }\n    if (this.fn) this.updateIfNecessary()\n    return this._value\n  }\n\n  set(fnOrValue: T | (() => T)): void {\n    if (typeof fnOrValue === 'function') {\n      const fn = fnOrValue as () => T\n      if (fn !== this.fn) {\n        this.stale(CacheDirty)\n      }\n      this.fn = fn\n    } else {\n      if (this.fn) {\n        this.removeParentObservers(0)\n        this.sources = null\n        this.fn = undefined\n      }\n      const value = fnOrValue as T\n      if (!this.equals(this._value, value)) {\n        if (this.observers) {\n          for (let i = 0; i < this.observers.length; i++) {\n            const observer = this.observers[i]\n            observer.stale(CacheDirty)\n          }\n        }\n        this._value = value\n      }\n    }\n  }\n\n  private stale(state: CacheNonClean): void {\n    if (this.state < state) {\n      // If we were previously clean, then we know that we may need to update to get the new value\n      if (this.state === CacheClean && this.isEffect) {\n        EffectQueue.push(this)\n        stabilizeFn?.(this)\n      }\n\n      this.state = state\n      if (this.observers) {\n        for (let i = 0; i < this.observers.length; i++) {\n          this.observers[i].stale(CacheCheck)\n        }\n      }\n    }\n  }\n\n  /** run the computation fn, updating the cached value */\n  private update(): void {\n    const oldValue = this._value\n\n    /* Evalute the reactive function body, dynamically capturing any other reactives used */\n    const prevReaction = CurrentReaction\n    const prevGets = CurrentGets\n    const prevIndex = CurrentGetsIndex\n\n    CurrentReaction = this\n    CurrentGets = null as any // prevent TS from thinking CurrentGets is null below\n    CurrentGetsIndex = 0\n\n    try {\n      if (this.cleanups.length) {\n        this.cleanups.forEach((c) => c(this._value))\n        this.cleanups = []\n      }\n      this._value = this.fn!()\n\n      // if the sources have changed, update source & observer links\n      if (CurrentGets) {\n        // remove all old sources' .observers links to us\n        this.removeParentObservers(CurrentGetsIndex)\n        // update source up links\n        if (this.sources && CurrentGetsIndex > 0) {\n          this.sources.length = CurrentGetsIndex + CurrentGets.length\n          for (let i = 0; i < CurrentGets.length; i++) {\n            this.sources[CurrentGetsIndex + i] = CurrentGets[i]\n          }\n        } else {\n          this.sources = CurrentGets\n        }\n\n        for (let i = CurrentGetsIndex; i < this.sources.length; i++) {\n          // Add ourselves to the end of the parent .observers array\n          const source = this.sources[i]\n          if (!source.observers) {\n            source.observers = [this]\n          } else {\n            source.observers.push(this)\n          }\n        }\n      } else if (this.sources && CurrentGetsIndex < this.sources.length) {\n        // remove all old sources' .observers links to us\n        this.removeParentObservers(CurrentGetsIndex)\n        this.sources.length = CurrentGetsIndex\n      }\n    } finally {\n      CurrentGets = prevGets\n      CurrentReaction = prevReaction\n      CurrentGetsIndex = prevIndex\n    }\n\n    // handles diamond depenendencies if we're the parent of a diamond.\n    if (!this.equals(oldValue, this._value) && this.observers) {\n      // We've changed value, so mark our children as dirty so they'll reevaluate\n      for (let i = 0; i < this.observers.length; i++) {\n        const observer = this.observers[i]\n        observer.state = CacheDirty\n      }\n    }\n\n    // We've rerun with the latest values from all of our sources.\n    // This means that we no longer need to update until a signal changes\n    this.state = CacheClean\n  }\n\n  /** update() if dirty, or a parent turns out to be dirty. */\n  private updateIfNecessary(): void {\n    // If we are potentially dirty, see if we have a parent who has actually changed value\n    if (this.state === CacheCheck) {\n      for (const source of this.sources!) {\n        source.updateIfNecessary() // updateIfNecessary() can change this.state\n        if ((this.state as CacheState) === CacheDirty) {\n          // Stop the loop here so we won't trigger updates on other parents unnecessarily\n          // If our computation changes to no longer use some sources, we don't\n          // want to update() a source we used last time, but now don't use.\n          break\n        }\n      }\n    }\n\n    // If we were already dirty or marked dirty by the step above, update.\n    if (this.state === CacheDirty) {\n      this.update()\n    }\n\n    // By now, we're clean\n    this.state = CacheClean\n  }\n\n  private removeParentObservers(index: number): void {\n    if (!this.sources) return\n    for (let i = index; i < this.sources.length; i++) {\n      const source: Reactive<any> = this.sources[i] // We don't actually delete sources here because we're replacing the entire array soon\n      const swap = source.observers!.findIndex((v) => v === this)\n      source.observers![swap] = source.observers![source.observers!.length - 1]\n      source.observers!.pop()\n    }\n  }\n}\n\nexport function onCleanup<T = any>(fn: (oldValue: T) => void): void {\n  if (CurrentReaction) {\n    CurrentReaction.cleanups.push(fn)\n  } else {\n    console.error('onCleanup must be called from within a @reactive function')\n  }\n}\n\n/** run all non-clean effect nodes */\nexport function stabilize(): void {\n  for (let i = 0; i < EffectQueue.length; i++) {\n    EffectQueue[i].get()\n  }\n  EffectQueue.length = 0\n}\n\n/** run a function for each dirty effect node.  */\nexport function autoStabilize(fn = deferredStabilize): void {\n  stabilizeFn = fn\n}\n\n/** queue stabilize() to run at the next idle time */\nfunction deferredStabilize(): void {\n  if (!stabilizationQueued) {\n    stabilizationQueued = true\n\n    queueMicrotask(() => {\n      stabilizationQueued = false\n      stabilize()\n    })\n  }\n}\n","import { camelize } from '.'\nimport { walkDownDOM, walkUpDOM } from './dom'\nimport { ACTION } from './extensions/actions'\nimport { Reactive, autoStabilize, onCleanup, reactive } from './external/reactively'\nimport { ActionFn, ActionsMap, Modifier, NamespacedReactiveRecords, WithExpressionArgs } from './types'\nautoStabilize()\n\nfunction signal<T>(initialValue: T): Reactive<T> {\n  return reactive(initialValue)\n}\n\nfunction computed<T>(fn: () => T): Reactive<T> {\n  return reactive(fn)\n}\n\nfunction effect(fn: () => void) {\n  return reactive(fn, { effect: true })\n}\n\nconst extensionObserver = new MutationObserver((mutations) => {\n  for (const m of mutations) {\n    m.removedNodes.forEach((node) => {\n      const el = node as Element\n      if (!el) return\n      extensionElementRegistry.delete(el)\n    })\n\n    m.addedNodes.forEach((node) => {\n      const el = node as Element\n      if (!el) return\n      extensionApplyFunctions.forEach((fn) => fn(el))\n    })\n  }\n})\n\nextensionObserver.observe(document, {\n  attributes: true,\n  childList: true,\n  subtree: true,\n})\n\nexport interface Preprocesser {\n  name: string\n  description: string\n  regexp: RegExp\n  replacer: (groups: Record<string, string>) => string\n}\nexport function useProcessor({ regexp, replacer }: Preprocesser, str: string): string {\n  // console.log(`preprocess with ${name}. ${description}`)\n  const matches = [...str.matchAll(regexp)]\n  if (!matches.length) return str\n  for (const match of matches) {\n    if (!match.groups) continue\n    const { groups } = match\n    const { whole } = groups\n    str = str.replace(whole, replacer(groups))\n  }\n  return str\n}\n\nfunction cyrb53(str: string, seed = 0) {\n  let h1 = 0xdeadbeef ^ seed,\n    h2 = 0x41c6ce57 ^ seed\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i)\n    h1 = Math.imul(h1 ^ ch, 2654435761)\n    h2 = Math.imul(h2 ^ ch, 1597334677)\n  }\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507)\n  h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909)\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507)\n  h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909)\n\n  return 4294967296 * (2097151 & h2) + (h1 >>> 0)\n}\n\nconst prefixHashes = new Map<string, number>()\nconst extensionApplyFunctions = new Map<number, Function>()\nconst extensionElementRegistry = new Map<Element, Set<number>>()\nconst extensionPreprocessStack = new Array<Preprocesser>()\nconst data = new Map<Element, NamespacedReactiveRecords>()\n\nconst actions: ActionsMap = {}\n\nexport function addDataExtension(\n  prefix: string,\n  args: {\n    allowedTags?: Iterable<string>\n    allowedModifiers?: Iterable<string | RegExp>\n    isPreprocessGlobal?: boolean\n    preprocessExpressions?: Iterable<Preprocesser>\n    withExpression?: (args: WithExpressionArgs) => NamespacedReactiveRecords | void\n    requiredExtensions?: Iterable<string>\n  },\n) {\n  if (prefix.toLowerCase() !== prefix) throw Error(`Data extension 'data-${prefix}' must be lowercase`)\n  if (prefixHashes.has(prefix)) {\n    throw new Error(`Data extension 'data-${prefix}' already registered`)\n  }\n\n  const hash = cyrb53(prefix)\n  prefixHashes.set(prefix, hash)\n\n  if (!args) {\n    args = {}\n  }\n\n  for (const extension of args.requiredExtensions || []) {\n    if (extension === prefix) {\n      throw new Error(`Data extension 'data-${prefix}' cannot require itself`)\n    }\n  }\n\n  const extensionsRegistered = new Set(prefixHashes.keys())\n  for (const requiredExtension of args.requiredExtensions || []) {\n    if (!extensionsRegistered.has(requiredExtension)) {\n      throw new Error(`Data extension 'data-${prefix}' can't be a duplicate`)\n    }\n  }\n\n  if (typeof args?.isPreprocessGlobal === 'undefined') {\n    args.isPreprocessGlobal = true\n  }\n\n  if (args?.preprocessExpressions && args.isPreprocessGlobal) {\n    extensionPreprocessStack.push(...args.preprocessExpressions)\n  }\n\n  const allAllowedModifiers: RegExp[] = []\n  if (args?.allowedModifiers) {\n    for (const modifier of args.allowedModifiers) {\n      const m = modifier instanceof RegExp ? modifier : new RegExp(modifier)\n      allAllowedModifiers.push(m)\n    }\n  }\n\n  const allowedTags = new Set([...(args?.allowedTags || [])].map((t) => t.toLowerCase()))\n\n  function registerExtensionOnElement(parentEl: Element) {\n    walkDownDOM(parentEl, (element) => {\n      const el = toHTMLorSVGElement(element)\n      if (!el) return\n\n      let extensions = extensionElementRegistry.get(el)\n      if (!extensions) {\n        extensions = new Set()\n        extensionElementRegistry.set(el, extensions)\n      }\n\n      if (extensions.has(hash)) return\n      extensions.add(hash)\n\n      if (allowedTags.size) {\n        const tagLower = el.tagName.toLowerCase()\n        if (!allowedTags.has(tagLower)) return\n      }\n\n      for (var d in el.dataset) {\n        if (!d.startsWith(prefix)) continue\n\n        let [name, ...modifiersWithArgsArr] = d.split('.')\n\n        const pl = prefix.length\n        const pl1 = pl + 1\n        name = name.slice(pl, pl1).toLocaleLowerCase() + name.slice(pl1)\n\n        const modifiers = modifiersWithArgsArr.map((m) => {\n          const [label, ...args] = m.split(':')\n\n          const isAllowed = allAllowedModifiers.some((allowedModifier) => allowedModifier.test(label))\n          if (!isAllowed) {\n            throw new Error(`Modifier ${label} is not allowed for ${name}`)\n          }\n\n          return { label, args }\n        })\n\n        const dataStack = loadDataStack(el)\n        let expression = el.dataset[d] || ''\n\n        for (const preprocessor of extensionPreprocessStack) {\n          expression = useProcessor(preprocessor, expression)\n        }\n\n        if (args?.preprocessExpressions && !args?.isPreprocessGlobal) {\n          for (const preprocessor of args.preprocessExpressions) {\n            expression = useProcessor(preprocessor, expression)\n          }\n        }\n\n        const elementData = data.get(el) || {}\n        if (args?.withExpression) {\n          const postExpression = args.withExpression({\n            name,\n            expression,\n            el,\n            dataStack,\n            reactivity: {\n              signal,\n              computed,\n              effect,\n              onCleanup,\n            },\n            withMod: (label: string) => withModifier(modifiers, label),\n            hasMod: (label: string) => hasModifier(modifiers, label),\n            actions,\n          })\n          if (postExpression) {\n            Object.assign(elementData, postExpression)\n          }\n        }\n        data.set(el, elementData)\n      }\n    })\n  }\n\n  registerExtensionOnElement(document.body)\n  extensionApplyFunctions.set(hash, registerExtensionOnElement)\n\n  // console.info(`Registered data extension: data-${prefix}`)\n}\n\nfunction loadDataStack(el: Element): NamespacedReactiveRecords {\n  const stack: NamespacedReactiveRecords[] = []\n\n  walkUpDOM(el, (el) => {\n    const elData = data.get(el)\n    if (elData) stack.push(elData)\n  })\n\n  stack.reverse()\n\n  const dataStack: NamespacedReactiveRecords = {}\n  for (const namespacedRecords of stack) {\n    for (const namespaceKey in namespacedRecords) {\n      if (!dataStack[namespaceKey]) {\n        dataStack[namespaceKey] = {}\n      }\n      Object.assign(dataStack[namespaceKey], namespacedRecords[namespaceKey])\n    }\n  }\n\n  return dataStack\n}\n\nexport function toHTMLorSVGElement(el: Element) {\n  if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n    return null\n  }\n  return el\n}\n\nexport function hasModifier(modifiers: Modifier[], label: string) {\n  return modifiers.some((m) => m.label === label)\n}\n\nexport function withModifier(modifiers: Modifier[], label: string) {\n  return modifiers.find((m) => m.label === label)\n}\n\nexport function addActionExtension(args: {\n  name: string\n  description: string\n  fn: ActionFn\n  requiredExtensions?: Iterable<string>\n}) {\n  const { name, fn, requiredExtensions } = args\n  const extensionHashes = [ACTION, ...(requiredExtensions || [])]\n\n  if (name != camelize(name)) {\n    throw new Error(`must be camelCase`)\n  }\n\n  for (const ext of extensionHashes) {\n    if (!prefixHashes.has(ext)) {\n      throw new Error(`requires '@${name}' registration`)\n    }\n\n    if (name in actions) {\n      throw new Error(`'@${name}' already registered`)\n    }\n\n    actions[name] = fn\n  }\n}\n\nlet nextID = 0\nexport function uniqueId() {\n  return nextID++\n}\n","import { addDataExtension } from '../core'\n\nexport const ACTION = 'action'\n\nexport function addActionDataExtension() {\n  addDataExtension(ACTION, {\n    preprocessExpressions: [\n      {\n        name: 'action',\n        description: 'turns @action(args) into actions.action(args)',\n        regexp: new RegExp(/(?<whole>@(?<action>[a-zA-Z_$][0-9a-zA-Z_$]*)(?<call>\\((?<args>.*)\\))?)/g),\n        replacer: ({ action, args }) => `actions.${action}({el,dataStack, actions}, ${args || ''})`,\n      },\n    ],\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataExtension } from '../core'\n\nexport const BIND = 'bind'\nexport function addBindDataExtension() {\n  addDataExtension(BIND, {\n    requiredExtensions: [SIGNAL],\n    withExpression: ({ el, name, expression, dataStack, actions, reactivity: { effect } }) => {\n      const signalFn = functionGenerator(expression)\n\n      const elementData: NamespacedReactiveRecords = {\n        bind: {\n          [name]: effect(() => {\n            if (!dataStack?.signals) return\n            const res = signalFn(el, dataStack, actions)\n            el.setAttribute(name, `${res}`)\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { SIGNAL } from '.'\nimport { addDataExtension, toHTMLorSVGElement } from '../core'\n\nexport const FOCUS = 'focus'\nexport function addFocusDataExtension() {\n  addDataExtension(FOCUS, {\n    requiredExtensions: [SIGNAL],\n    withExpression: ({ el }) => {\n      const element = toHTMLorSVGElement(el)\n      if (!element?.focus) throw new Error('Element must have a focus method')\n      element.focus()\n      return {}\n    },\n  })\n}\n","const generatedByIdiomorphId = new WeakSet()\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function idiomorph(oldNode: Document | Element, newContent: string | Element, config = {}) {\n  if (oldNode instanceof Document) {\n    oldNode = oldNode.documentElement\n  }\n\n  let parsedContent: Element\n  if (typeof newContent === 'string') {\n    parsedContent = parseContent(newContent) as Element\n  } else {\n    parsedContent = newContent\n  }\n\n  const normalizedContent = normalizeContent(parsedContent)\n  const ctx = createMorphContext(oldNode, normalizedContent, config)\n\n  return morphNormalizedContent(oldNode, normalizedContent, ctx)\n}\n\nfunction morphNormalizedContent(oldNode: Element, normalizedNewContent: Element, ctx: any) {\n  if (ctx.head.block) {\n    const oldHead = oldNode.querySelector('head')\n    const newHead = normalizedNewContent.querySelector('head')\n    if (oldHead && newHead) {\n      const promises = handleHeadElement(newHead, oldHead, ctx)\n      // when head promises resolve, call morph again, ignoring the head tag\n      Promise.all(promises).then(() => {\n        morphNormalizedContent(\n          oldNode,\n          normalizedNewContent,\n          Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          }),\n        )\n      })\n      return\n    }\n  }\n\n  if (ctx.morphStyle === 'innerHTML') {\n    // innerHTML, so we are only updating the children\n    morphChildren(normalizedNewContent, oldNode, ctx)\n    return oldNode.children\n  } else if (ctx.morphStyle === 'outerHTML' || ctx.morphStyle == null) {\n    // otherwise find the best element match in the new content, morph that, and merge its siblings\n    // into either side of the best match\n    const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx)\n    if (!bestMatch) throw new Error('Could not find best match')\n\n    // stash the siblings that will need to be inserted on either side of the best match\n    const previousSibling = bestMatch?.previousSibling as Element\n    const nextSibling = bestMatch?.nextSibling as Element\n\n    // morph it\n    const morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx)\n\n    if (bestMatch) {\n      // if there was a best match, merge the siblings in too and return the\n      // whole bunch\n      return insertSiblings(previousSibling, morphedNode, nextSibling)\n    } else {\n      // otherwise nothing was added to the DOM\n      return []\n    }\n  } else {\n    throw 'Do not understand how to morph style ' + ctx.morphStyle\n  }\n}\n\n/**\n * @param oldNode root node to merge content into\n * @param newContent new content to merge\n * @param ctx the merge context\n * @returns {Element} the element that ended up in the DOM\n */\nfunction morphOldNodeTo(oldNode: Element, newContent: Element, ctx: any) {\n  if (ctx.ignoreActive && oldNode === document.activeElement) {\n    // don't morph focused element\n  } else if (newContent == null) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n\n    oldNode.remove()\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return\n  } else if (!isSoftMatch(oldNode, newContent)) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n    if (ctx.callbacks.beforeNodeAdded(newContent) === false) return\n\n    if (!oldNode.parentElement) throw new Error('oldNode has no parentElement')\n    oldNode.parentElement.replaceChild(newContent, oldNode)\n    ctx.callbacks.afterNodeAdded(newContent)\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return newContent\n  } else {\n    if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return\n\n    if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n      // ignore the head element\n    } else if (\n      newContent instanceof HTMLHeadElement &&\n      oldNode instanceof HTMLHeadElement &&\n      ctx.head.style !== 'morph'\n    ) {\n      handleHeadElement(newContent, oldNode, ctx)\n    } else {\n      syncNodeFrom(newContent, oldNode)\n      morphChildren(newContent, oldNode, ctx)\n    }\n    ctx.callbacks.afterNodeMorphed(oldNode, newContent)\n    return oldNode\n  }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n * @param {Element} newParent the parent element of the new content\n * @param {Element } oldParent the old content that we are merging the new content into\n * @param ctx the merge context\n */\nfunction morphChildren(newParent: Element, oldParent: Element, ctx: any) {\n  let nextNewChild = newParent.firstChild as Element | null\n  let insertionPoint = oldParent.firstChild as Element | null\n  let newChild\n\n  // run through all the new content\n  while (nextNewChild) {\n    newChild = nextNewChild\n    nextNewChild = newChild.nextSibling as Element | null\n\n    // if we are at the end of the exiting parent's children, just append\n    if (insertionPoint == null) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n      oldParent.appendChild(newChild)\n      ctx.callbacks.afterNodeAdded(newChild)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // if the current node has an id set match then morph\n    if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n      morphOldNodeTo(insertionPoint, newChild, ctx)\n      insertionPoint = insertionPoint.nextSibling as Element | null\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // otherwise search forward in the existing old children for an id set match\n    let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx)\n\n    // if we found a potential match, remove the nodes until that point and morph\n    if (idSetMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx)\n      morphOldNodeTo(idSetMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // no id set match found, so scan forward for a soft match for the current node\n    let softMatch = findSoftMatch(newParent, newChild, insertionPoint, ctx)\n\n    // if we found a soft match for the current node, morph\n    if (softMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx)\n      morphOldNodeTo(softMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // abandon all hope of morphing, just insert the new child before the insertion point\n    // and move on\n    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n    oldParent.insertBefore(newChild, insertionPoint)\n    ctx.callbacks.afterNodeAdded(newChild)\n    removeIdsFromConsideration(ctx, newChild)\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint !== null) {\n    let tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling as Element | null\n    removeNode(tempNode, ctx)\n  }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\n/**\n * syncs a given node with another node, copying over all attributes and\n * inner element state from the 'from' node to the 'to' node\n *\n * @param {Element} from the element to copy attributes & state from\n * @param {Element} to the element to copy attributes & state to\n */\nfunction syncNodeFrom(from: Element, to: Element) {\n  let type = from.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    for (const fromAttribute of from.attributes) {\n      const toAttribute = to.getAttribute(fromAttribute.name)\n      if (toAttribute !== fromAttribute.value) {\n        to.setAttribute(fromAttribute.name, fromAttribute.value)\n      }\n    }\n    for (const toAttribute of to.attributes) {\n      if (!from.hasAttribute(toAttribute.name)) {\n        to.removeAttribute(toAttribute.name)\n      }\n    }\n  }\n\n  // sync text nodes\n  if (type === Node.COMMENT_NODE || type === Node.TEXT_NODE) {\n    if (to.nodeValue !== from.nodeValue) {\n      to.nodeValue = from.nodeValue\n    }\n  }\n\n  // NB: many bothans died to bring us information:\n  //\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  // https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n\n  // sync input value\n  if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== 'file') {\n    to.value = from.value || ''\n    syncAttribute(from, to, 'value')\n\n    // sync boolean attributes\n    syncAttribute(from, to, 'checked')\n    syncAttribute(from, to, 'disabled')\n  } else if (from instanceof HTMLOptionElement) {\n    syncAttribute(from, to, 'selected')\n  } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n    const fromValue = from.value\n    const toValue = to.value\n    if (fromValue !== toValue) {\n      to.value = fromValue\n    }\n    if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n      to.firstChild.nodeValue = fromValue\n    }\n  }\n}\n\nfunction syncAttribute(from: Element, to: Element, attributeName: string) {\n  const fAttr = from.getAttribute(attributeName)\n  const tAttr = to.getAttribute(attributeName)\n\n  if (fAttr !== tAttr) {\n    if (fAttr) {\n      to.setAttribute(attributeName, fAttr)\n    } else {\n      to.removeAttribute(attributeName)\n    }\n  }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(newHeadTag: HTMLHeadElement, currentHead: HTMLHeadElement, ctx: any) {\n  const added = []\n  const removed = []\n  const preserved = []\n  const nodesToAppend = []\n\n  const headMergeStyle = ctx.head.style\n\n  // put all new head elements into a Map, by their outerHTML\n  const srcToNewHeadNodes = new Map()\n  for (const newHeadChild of newHeadTag.children) {\n    srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild)\n  }\n\n  // for each elt in the current head\n  for (const currentHeadElt of currentHead.children) {\n    // If the current head element is in the map\n    let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML)\n    let isReAppended = ctx.head.shouldReAppend(currentHeadElt)\n    let isPreserved = ctx.head.shouldPreserve(currentHeadElt)\n    if (inNewContent || isPreserved) {\n      if (isReAppended) {\n        // remove the current version and let the new version replace it and re-execute\n        removed.push(currentHeadElt)\n      } else {\n        // this element already exists and should not be re-appended, so remove it from\n        // the new content map, preserving it in the DOM\n        srcToNewHeadNodes.delete(currentHeadElt.outerHTML)\n        preserved.push(currentHeadElt)\n      }\n    } else {\n      if (headMergeStyle === 'append') {\n        // we are appending and this existing element is not new content\n        // so if and only if it is marked for re-append do we do anything\n        if (isReAppended) {\n          removed.push(currentHeadElt)\n          nodesToAppend.push(currentHeadElt)\n        }\n      } else {\n        // if this is a merge, we remove this content since it is not in the new head\n        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n          removed.push(currentHeadElt)\n        }\n      }\n    }\n  }\n\n  // Push the remaining new head elements in the Map into the\n  // nodes to append to the head tag\n  nodesToAppend.push(...srcToNewHeadNodes.values())\n  console.log('to append: ', nodesToAppend)\n\n  const promises = []\n  for (const newNode of nodesToAppend) {\n    console.log('adding: ', newNode)\n    const newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild as Element | null\n    if (!newElt) throw new Error('could not create new element from: ' + newNode.outerHTML)\n    console.log(newElt)\n    if (!!ctx.callbacks.beforeNodeAdded(newElt)) {\n      if (newElt.hasAttribute('href') || newElt.hasAttribute('src')) {\n        let resolver: (value: unknown) => void\n        const promise = new Promise((resolve) => {\n          resolver = resolve\n        })\n        newElt.addEventListener('load', function () {\n          resolver(undefined)\n        })\n        promises.push(promise)\n      }\n      currentHead.appendChild(newElt)\n      ctx.callbacks.afterNodeAdded(newElt)\n      added.push(newElt)\n    }\n  }\n\n  // remove all removed elements, after we have appended the new elements to avoid\n  // additional network requests for things like style sheets\n  for (const removedElement of removed) {\n    if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n      currentHead.removeChild(removedElement)\n      ctx.callbacks.afterNodeRemoved(removedElement)\n    }\n  }\n\n  ctx.head.afterHeadMorphed(currentHead, {\n    added: added,\n    kept: preserved,\n    removed: removed,\n  })\n  return promises\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\nfunction noOp() {}\n\nfunction createMorphContext(oldNode: Element, newContent: Element, config: any) {\n  return {\n    target: oldNode,\n    newContent: newContent,\n    config: config,\n    morphStyle: config.morphStyle,\n    ignoreActive: config.ignoreActive,\n    idMap: createIdMap(oldNode, newContent),\n    deadIds: new Set(),\n    callbacks: Object.assign(\n      {\n        beforeNodeAdded: noOp,\n        afterNodeAdded: noOp,\n        beforeNodeMorphed: noOp,\n        afterNodeMorphed: noOp,\n        beforeNodeRemoved: noOp,\n        afterNodeRemoved: noOp,\n      },\n      config.callbacks,\n    ),\n    head: Object.assign(\n      {\n        style: 'merge',\n        shouldPreserve: (elt: Element) => elt.getAttribute('im-preserve') === 'true',\n        shouldReAppend: (elt: Element) => elt.getAttribute('im-re-append') === 'true',\n        shouldRemove: noOp,\n        afterHeadMorphed: noOp,\n      },\n      config.head,\n    ),\n  }\n}\n\nfunction isIdSetMatch(node1: Element, node2: Element, ctx: any) {\n  if (!node1 || !node2) return false\n\n  if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n    if (node1?.id?.length && node1.id === node2.id) return true\n\n    return getIdIntersectionCount(ctx, node1, node2) > 0\n  }\n  return false\n}\n\nfunction isSoftMatch(node1: Element, node2: Element) {\n  if (!node1 || !node2) return false\n\n  return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n}\n\nfunction removeNodesBetween(startInclusive: Element, endExclusive: Element, ctx: any) {\n  while (startInclusive !== endExclusive) {\n    const tempNode = startInclusive\n    startInclusive = startInclusive?.nextSibling as Element\n    if (!tempNode) throw new Error('tempNode is null')\n    removeNode(tempNode, ctx)\n  }\n  removeIdsFromConsideration(ctx, endExclusive)\n  return endExclusive.nextSibling as Element | null\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(newContent: Element, oldParent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  // max id matches we are willing to discard in our search\n  const newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent)\n\n  let potentialMatch: Element | null = null\n\n  // only search forward if there is a possibility of an id match\n  if (newChildPotentialIdCount > 0) {\n    potentialMatch = insertionPoint\n    // if there is a possibility of an id match, scan forward\n    // keep track of the potential id match count we are discarding (the\n    // newChildPotentialIdCount must be greater than this to make it likely\n    // worth it)\n    let otherMatchCount = 0\n    while (potentialMatch != null) {\n      // If we have an id match, return the current potential match\n      if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n        return potentialMatch\n      }\n\n      // computer the other potential matches of this new content\n      otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent)\n      if (otherMatchCount > newChildPotentialIdCount) {\n        // if we have more potential id matches in _other_ content, we\n        // do not have a good candidate for an id match, so return null\n        return null\n      }\n\n      // advanced to the next old content child\n      potentialMatch = potentialMatch.nextSibling as Element | null\n    }\n  }\n  return potentialMatch\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(newContent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  let potentialSoftMatch = insertionPoint as Element | null\n  let nextSibling = newChild.nextSibling as Element | null\n\n  let siblingSoftMatchCount = 0\n\n  while (potentialSoftMatch && nextSibling) {\n    if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n      // the current potential soft match has a potential id set match with the remaining new\n      // content so bail out of looking\n      return null\n    }\n\n    // if we have a soft match with the current node, return it\n    if (isSoftMatch(newChild, potentialSoftMatch)) {\n      return potentialSoftMatch\n    }\n\n    if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n      // the next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling as Element | null\n\n      // If there are two future soft matches, bail to allow the siblings to soft match\n      // so that we don't consume future soft matches for the sake of the current node\n      if (siblingSoftMatchCount >= 2) {\n        return null\n      }\n    }\n\n    // advanced to the next old content child\n    potentialSoftMatch = potentialSoftMatch.nextSibling as Element | null\n  }\n\n  return potentialSoftMatch\n}\n\nconst parser = new DOMParser()\nfunction parseContent(newContent: string) {\n  // remove svgs to avoid false-positive matches on head, etc.\n  const contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '')\n\n  // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n  if (\n    contentWithSvgsRemoved.match(/<\\/html>/) ||\n    contentWithSvgsRemoved.match(/<\\/head>/) ||\n    contentWithSvgsRemoved.match(/<\\/body>/)\n  ) {\n    const content = parser.parseFromString(newContent, 'text/html')\n    // if it is a full HTML document, return the document itself as the parent container\n    if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n      generatedByIdiomorphId.add(content)\n      return content\n    } else {\n      // otherwise return the html element as the parent container\n      let Element = content.firstChild\n      if (Element) {\n        generatedByIdiomorphId.add(Element)\n        return Element as Element\n      } else {\n        return null\n      }\n    }\n  } else {\n    // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n    // deal with touchy tags like tr, tbody, etc.\n    const responseDoc = parser.parseFromString(`<body><template>${newContent}</template></body>`, 'text/html')\n    const content = responseDoc.body.querySelector('template')?.content\n    if (!content) throw new Error('content is null')\n    generatedByIdiomorphId.add(content)\n    return content\n  }\n}\n\nfunction normalizeContent(newContent: Element) {\n  if (newContent == null) {\n    // noinspection UnnecessaryLocalVariableJS\n    const dummyParent = document.createElement('div')\n    return dummyParent\n  } else if (generatedByIdiomorphId.has(newContent)) {\n    // the template tag created by idiomorph parsing can serve as a dummy parent\n    return newContent\n  } else if (newContent instanceof Node) {\n    // a single node is added as a child to a dummy parent\n    const dummyParent = document.createElement('div')\n    dummyParent.append(newContent)\n    return dummyParent\n  } else {\n    // all nodes in the array or Element collection are consolidated under\n    // a single dummy parent element\n    const dummyParent = document.createElement('div')\n    for (const elt of [...newContent]) {\n      dummyParent.append(elt)\n    }\n    return dummyParent\n  }\n}\n\nfunction insertSiblings(previousSibling?: Element, morphedNode?: Element, nextSibling?: Element) {\n  const stack = []\n  const added = []\n  while (previousSibling) {\n    stack.push(previousSibling)\n    previousSibling = previousSibling.previousSibling as Element\n  }\n  while (stack.length > 0) {\n    const node = stack.pop()!\n    added.push(node) // push added preceding siblings on in order and insert\n    morphedNode?.parentElement?.insertBefore(node, morphedNode)\n  }\n  added.push(morphedNode)\n  while (nextSibling) {\n    stack.push(nextSibling)\n    added.push(nextSibling) // here we are going in order, so push on as we scan, rather than add\n    nextSibling = nextSibling.nextSibling as Element\n  }\n  while (stack.length) {\n    morphedNode?.parentElement?.insertBefore(stack.pop()!, morphedNode.nextSibling)\n  }\n  return added\n}\n\nfunction findBestNodeMatch(newContent: Element, oldNode: Element, ctx: any) {\n  let currentElement = newContent.firstChild as Element | null\n  let bestElement = currentElement\n  let score = 0\n  while (currentElement) {\n    let newScore = scoreElement(currentElement, oldNode, ctx)\n    if (newScore > score) {\n      bestElement = currentElement\n      score = newScore\n    }\n    currentElement = currentElement.nextSibling as Element | null\n  }\n  return bestElement\n}\n\nfunction scoreElement(node1: Element, node2: Element, ctx: any) {\n  if (isSoftMatch(node1, node2)) {\n    return 0.5 + getIdIntersectionCount(ctx, node1, node2)\n  }\n  return 0\n}\n\nfunction removeNode(tempNode: Element, ctx: any) {\n  removeIdsFromConsideration(ctx, tempNode)\n  if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return\n\n  tempNode.remove()\n  ctx.callbacks.afterNodeRemoved(tempNode)\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: any, id: string) {\n  return !ctx.deadIds.has(id)\n}\n\nfunction idIsWithinNode(ctx: any, id: string, targetNode: Element) {\n  return ctx.idMap.get(targetNode)?.has(id) || false\n}\n\nfunction removeIdsFromConsideration(ctx: any, node: Element) {\n  const idSet = ctx.idMap.get(node)\n  if (!idSet) return\n  for (const id of idSet) {\n    ctx.deadIds.add(id)\n  }\n}\n\nfunction getIdIntersectionCount(ctx: any, node1: Element, node2: Element) {\n  const sourceSet = ctx.idMap.get(node1)\n  if (!sourceSet) return 0\n\n  let matchCount = 0\n  for (const id of sourceSet) {\n    // a potential match is an id in the source and potentialIdsSet, but\n    // that has not already been merged into the DOM\n    if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n      ++matchCount\n    }\n  }\n  return matchCount\n}\n\n/**\n * A bottom up algorithm that finds all elements with ids inside of the node\n * argument and populates id sets for those nodes and all their parents, generating\n * a set of ids contained within all nodes for the entire hierarchy in the DOM\n *\n * @param node {Element}\n * @param {Map<Node, Set<String>>} idMap\n */\nfunction populateIdMapForNode(node: Element, idMap: Map<Element, Set<string>>) {\n  const nodeParent = node.parentElement\n  // find all elements with an id property\n  const idElements = node.querySelectorAll('[id]')\n  for (const elt of idElements) {\n    let current = elt as Element | null\n    // walk up the parent hierarchy of that element, adding the id\n    // of element to the parent's id set\n    while (current !== nodeParent && !!current) {\n      let idSet = idMap.get(current)\n      // if the id set doesn't exist, create it and insert it in the  map\n      if (idSet == null) {\n        idSet = new Set()\n        idMap.set(current, idSet)\n      }\n      idSet.add(elt.id)\n      current = current.parentElement\n    }\n  }\n}\n\n/**\n * This function computes a map of nodes to all ids contained within that node (inclusive of the\n * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n * to contribute to a parent nodes matching.\n *\n * @param {Element} oldContent  the old content that will be morphed\n * @param {Element} newContent  the new content to morph to\n * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n */\nfunction createIdMap(oldContent: Element, newContent: Element) {\n  const idMap = new Map()\n  populateIdMapForNode(oldContent, idMap)\n  populateIdMapForNode(newContent, idMap)\n  return idMap\n}\n","import { ActionArgs } from '..'\nimport { addActionExtension, toHTMLorSVGElement } from '../core'\nimport { idiomorph } from '../external/idiomorph'\nimport { Reactive } from '../external/reactively'\nconst p = new DOMParser()\nconst DATASTAR_CLASS_PREFIX = 'datastar'\nconst INDICATOR_CLASS = `${DATASTAR_CLASS_PREFIX}-indicator`\nconst LOADING_CLASS = `${DATASTAR_CLASS_PREFIX}-request`\nconst ACCEPT = 'Accept',\n  TEXT_HTML = 'text/html',\n  CONTENT_TYPE = 'Content-Type',\n  APPLICATION_JSON = 'application/json',\n  SELECTOR = 'selector',\n  SWAP = 'swap'\n\nexport const GET = 'get'\nexport const addGetExtension = () => addFetchMethod(GET)\nexport const POST = 'post'\nexport const addPostExtension = () => addFetchMethod(POST)\nexport const PUT = 'put'\nexport const addPutExtension = () => addFetchMethod(PUT)\nexport const PATCH = 'patch'\nexport const addPatchExtension = () => addFetchMethod(PATCH)\nexport const DELETE = 'delete'\nexport const addDeleteExtension = () => addFetchMethod(DELETE)\n\nexport const addAllFragmentExtensions = () => {\n  addGetExtension()\n  addPostExtension()\n  addPutExtension()\n  addPatchExtension()\n  addDeleteExtension()\n}\n\nlet hasInjectedStyles = false\nfunction addFetchMethod(method: string) {\n  if (!hasInjectedStyles) {\n    const style = document.createElement('style')\n    style.innerHTML = `\n.${INDICATOR_CLASS}{\n  opacity:0;\n  transition: opacity 500ms ease-in;\n}\n.${LOADING_CLASS} .${INDICATOR_CLASS}{\n    opacity:1\n}\n.${LOADING_CLASS}.${INDICATOR_CLASS}{\n    opacity:1\n}\n    `\n    document.head.appendChild(style)\n    hasInjectedStyles = true\n  }\n\n  addActionExtension({\n    name: method,\n    description: `turns @${method}(args) into fetch(${method}, args)`,\n    fn: async (args: ActionArgs) => fetcher(method, args),\n  })\n}\n\nasync function fetcher(method: string, args: ActionArgs) {\n  const { el: elRaw, dataStack } = args\n\n  const urlSignal: Reactive<string> = dataStack.signals?.[method]\n  if (!urlSignal) throw new Error(`No signal for ${method}`)\n\n  const el = toHTMLorSVGElement(elRaw)\n  if (!el) throw new Error('Element must be an HTMLElement or SVGElement')\n\n  el.classList.add(LOADING_CLASS)\n\n  const url = new URL(urlSignal.value, window.location.origin)\n\n  const headers = new Headers()\n\n  headers.append(ACCEPT, TEXT_HTML)\n  headers.append(CONTENT_TYPE, APPLICATION_JSON)\n\n  if (dataStack?.headers) {\n    for (let name in dataStack.headers) {\n      const signal = dataStack.headers[name]\n      headers.append(name, signal.value)\n    }\n  }\n\n  const dataStackJSON = JSON.stringify(dataStack, (_, value) => {\n    if (value instanceof Reactive) {\n      if (value.isEffect) return undefined\n      return value.get()\n    }\n    return value\n  })\n  const req: RequestInit = { method, headers }\n  if (method === GET) {\n    const queryParams = new URLSearchParams(url.search)\n    queryParams.append('dataStack', dataStackJSON)\n    url.search = queryParams.toString()\n  } else {\n    req.body = dataStackJSON\n  }\n\n  const res = await fetch(url, req)\n  if (!res.ok) throw new Error('Network response was not ok.')\n  const html = await res.text()\n\n  const dom = [...p.parseFromString(html, TEXT_HTML).body.children]\n  for (let i = 0; i < dom.length; i++) {\n    const frag = dom[i]\n    if (!(frag instanceof Element)) {\n      throw new Error('Not an element')\n    }\n    const fragElement = toHTMLorSVGElement(frag)\n\n    const id = frag.getAttribute('id')\n    const firstFrag = i === 0\n    const hasID = !!id?.length\n    const useElAsTarget = firstFrag && !hasID\n\n    let targets: Iterable<Element>\n    if (useElAsTarget) {\n      targets = [elRaw]\n    } else {\n      if (!hasID) throw new Error('No id')\n\n      const targetSelector = fragElement?.dataset?.[SELECTOR] || `#${id}`\n      targets = document.querySelectorAll(targetSelector) || []\n    }\n    if (!!!targets) throw new Error('No target element')\n\n    for (const target of targets) {\n      const merge = fragElement?.dataset?.[SWAP] || 'morph'\n      switch (merge) {\n        case 'morph':\n          idiomorph(target, frag)\n          break\n        case 'inner':\n          target.innerHTML = frag.innerHTML //  The default, replace the inner html of the target element\n          break\n        case 'outer':\n          target.outerHTML = frag.outerHTML //  Replace the entire target element with the response\n          break\n        case 'prepend':\n          target.prepend(frag.outerHTML) //  Insert the response before the first child of the target element\n          break\n        case 'append':\n          target.append(frag.outerHTML) //  Insert the response after the last child of the target element\n          break\n        case 'before':\n          target.before(frag) //  Insert the response before the target element\n          break\n        case 'after':\n          target.after(frag) //  Insert the response after the target element\n          break\n        case 'delete':\n          target.remove() //  Deletes the target element regardless of the response\n          break\n        default:\n          throw new Error('Invalid merge mode')\n      }\n    }\n  }\n\n  el.classList.remove(LOADING_CLASS)\n}\n","import { SIGNAL } from '.'\nimport { addDataExtension, uniqueId } from '../core'\n\nexport const MODEL = 'model'\nconst updateEvents = ['change', 'input', 'keydown']\nexport function addModelDataExtension() {\n  addDataExtension(MODEL, {\n    allowedTags: ['input', 'textarea', 'select'],\n    requiredExtensions: [SIGNAL],\n\n    withExpression: ({ name, el, expression, dataStack, reactivity: { effect, onCleanup } }) => {\n      const signal = dataStack.signals[expression]\n      if (!signal) {\n        throw new Error(`Signal ${expression} not found`)\n      }\n\n      if (!('value' in el)) throw new Error('Element must have a value property')\n      el.value = signal.value\n\n      const setter = () => {\n        const current = signal.value\n        if (typeof current === 'number') {\n          signal.value = Number(el.value)\n        } else if (typeof current === 'string') {\n          signal.value = el.value\n        } else if (typeof current === 'boolean') {\n          signal.value = Boolean(el.value)\n        } else {\n          throw new Error('Unsupported type')\n        }\n      }\n\n      return {\n        model: {\n          [`${name}-${uniqueId()}`]: effect(() => {\n            el.value = signal.value\n\n            for (const event of updateEvents) {\n              el.addEventListener(event, setter)\n            }\n\n            onCleanup(() => {\n              for (const event of updateEvents) {\n                el.removeEventListener(event, setter)\n              }\n            })\n          }),\n        },\n      }\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataExtension } from '../core'\n\nexport const ON = 'on'\n\nconst ONCE = 'once',\n  THROTTLE = 'throttle',\n  DEBOUNCE = 'debounce',\n  LEADING = 'leading'\n\nexport function addOnDataExtension() {\n  addDataExtension(ON, {\n    requiredExtensions: [SIGNAL],\n    allowedModifiers: [ONCE, THROTTLE, DEBOUNCE, LEADING],\n    withExpression: ({\n      el,\n      name,\n      hasMod,\n      withMod,\n      expression,\n      dataStack,\n      reactivity: { computed, effect, onCleanup },\n      actions,\n    }) => {\n      const signalFn = functionGenerator(expression)\n\n      const hasOnce = hasMod(ONCE)\n      const throttleMod = withMod(THROTTLE)\n      const debounceMod = withMod(DEBOUNCE)\n      const hasLeading = hasMod(LEADING)\n\n      if (name === 'load') {\n        document.addEventListener('DOMContentLoaded', () => signalFn(el, dataStack, actions), true)\n        return\n      }\n\n      const fn = () => signalFn(el, dataStack, actions)\n      let wrappedFnCallback: Function = fn\n      let callback: () => void\n\n      if (hasOnce) {\n        wrappedFnCallback = () => {\n          fn()\n          if (callback) {\n            el.removeEventListener(name, callback)\n          }\n        }\n      } else if (!!throttleMod) {\n        const [throttleTimeRaw] = throttleMod.args\n        const throttleTime = throttleTimeRaw ? Number(throttleTimeRaw) : 1000\n\n        let prev = 0\n        const throttledFn = computed(() => {\n          const now = Date.now()\n          const delta = now - prev\n          if (delta >= throttleTime) {\n            prev = now\n            return fn()\n          }\n        })\n\n        wrappedFnCallback = () => throttledFn.value\n      } else if (!!debounceMod) {\n        const [debounceTimeRaw] = debounceMod.args\n        const debounceTime = debounceTimeRaw ? Number(debounceTimeRaw) : 1000\n\n        let timerID: ReturnType<typeof setTimeout> | undefined\n        const debouncedFn = computed(() => {\n          if (hasLeading && !timerID) {\n            fn()\n          }\n          clearTimeout(timerID)\n          timerID = setTimeout(() => {\n            if (hasLeading) timerID = undefined\n            else fn()\n          }, debounceTime)\n        })\n\n        wrappedFnCallback = () => debouncedFn.value\n      }\n\n      callback = () => wrappedFnCallback()\n\n      el.addEventListener(name, callback)\n\n      const elementData: NamespacedReactiveRecords = {\n        on: {\n          [name]: effect(() => {\n            onCleanup(() => {\n              if (hasOnce) return\n\n              el.removeEventListener(name, callback)\n            })\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL } from '..'\nimport { addDataExtension } from '../core'\n\nexport const REF = 'ref'\nexport function addRefDataExtension() {\n  addDataExtension(REF, {\n    requiredExtensions: [SIGNAL],\n    preprocessExpressions: [\n      {\n        name: 'ref',\n        description: 'turns #ref into data.refs.ref.value',\n        regexp: new RegExp(/(?<whole>\\#(?<ref>[a-zA-Z_$][0-9a-zA-Z_$]*))/g),\n        replacer: ({ ref }) => `data.refs.${ref}.value`,\n      },\n    ],\n    withExpression: ({ el, name, reactivity: { signal } }) => {\n      const elementData: NamespacedReactiveRecords = {\n        refs: {\n          [name]: signal(el),\n        },\n      }\n      return elementData\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataExtension } from '../core'\n\nconst IMPORTANT = 'important',\n  DISPLAY = 'display',\n  NONE = 'none'\n\nexport const SHOW = 'show'\nexport function addShowDataExtension() {\n  addDataExtension(SHOW, {\n    requiredExtensions: [SIGNAL],\n    allowedModifiers: [IMPORTANT],\n    withExpression: ({ el, name, dataStack, expression, hasMod, reactivity: { effect }, actions }) => {\n      const signalFn = functionGenerator(expression)\n\n      if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n        throw new Error('Element must have a style property')\n      }\n\n      const isImportant = hasMod(IMPORTANT)\n      const priority = isImportant ? IMPORTANT : undefined\n\n      const elementData: NamespacedReactiveRecords = {\n        show: {\n          [name]: effect(() => {\n            const shouldShow = !!signalFn(el, dataStack, actions)\n            if (shouldShow) {\n              if (el.style.length === 1 && el.style.display === NONE) {\n                el.style.removeProperty(DISPLAY)\n              } else {\n                el.style.setProperty(DISPLAY, '', priority)\n              }\n            } else {\n              el.style.setProperty(DISPLAY, NONE, priority)\n            }\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { functionEval } from '..'\nimport { addDataExtension } from '../core'\nimport { ACTION } from './actions'\n\nexport const SIGNAL = 'signal'\n\nconst PERSIST_KEY = 'persist'\nexport function addSignalDataExtension() {\n  addDataExtension(SIGNAL, {\n    requiredExtensions: [ACTION],\n    preprocessExpressions: [\n      {\n        name: 'signal',\n        description: 'turns $signal into dataStack.signals.signal.value',\n        regexp: new RegExp(/(?<whole>\\$(?<signal>[a-zA-Z_$][0-9a-zA-Z_$]*))/g),\n        replacer: ({ signal }) => `dataStack.${SIGNAL}s.${signal}.value`,\n      },\n    ],\n    allowedModifiers: [PERSIST_KEY],\n    withExpression: ({ name, el, expression, reactivity, hasMod, actions }) => {\n      const signal = reactivity.signal(functionEval(el, {}, actions, expression))\n\n      if (hasMod(PERSIST_KEY)) {\n        const value = localStorage.getItem(name)\n        if (value) {\n          const parsedValue = JSON.parse(value)\n          signal.value = parsedValue\n        }\n\n        reactivity.effect(() => {\n          const value = JSON.stringify(signal.value)\n          localStorage.setItem(name, value)\n        })\n      }\n\n      return {\n        signals: {\n          [name]: signal,\n        },\n      }\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataExtension, toHTMLorSVGElement } from '../core'\n\nconst PREPEND = 'prepend',\n  APPEND = 'append',\n  MUST_PARENT_ERR = 'Target element must have a parent if using prepend or append'\n\nexport const TELEPORT = 'teleport'\nexport function addTeleportDataExtension() {\n  addDataExtension(TELEPORT, {\n    requiredExtensions: [SIGNAL],\n    allowedModifiers: [PREPEND, APPEND],\n    withExpression: ({ name, el, expression, dataStack, reactivity: { effect }, hasMod, actions }) => {\n      if (!(el instanceof HTMLTemplateElement)) {\n        throw new Error('Element must be a template')\n      }\n\n      const signalFn = functionGenerator(expression)\n\n      const elementData: NamespacedReactiveRecords = {\n        text: {\n          [name]: effect(() => {\n            const res = signalFn(el, dataStack, actions)\n            if (typeof res !== 'string') throw new Error('Selector must be a string')\n            const target = document.querySelector(res)\n            if (!target) throw new Error(`Target element not found: ${res}`)\n\n            if (!el.content) throw new Error('Template element must have content')\n            const n = el.content.cloneNode(true)\n            const nEl = toHTMLorSVGElement(n as Element)\n            if (nEl?.firstElementChild) throw new Error('Empty template')\n\n            if (hasMod(PREPEND)) {\n              if (!target.parentNode) throw new Error(MUST_PARENT_ERR)\n              target.parentNode.insertBefore(n, target)\n            } else if (hasMod(APPEND)) {\n              if (!target.parentNode) throw new Error(MUST_PARENT_ERR)\n              target.parentNode.insertBefore(n, target.nextSibling)\n            } else {\n              target.appendChild(n)\n            }\n            target.appendChild(n)\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { NamespacedReactiveRecords, functionGenerator } from '..'\nimport { addDataExtension } from '../core'\n\nexport const TEXT = 'text'\nexport function addTextDataExtension() {\n  addDataExtension(TEXT, {\n    withExpression: ({ name, el, expression, dataStack, actions, reactivity: { effect } }) => {\n      const signalFn = functionGenerator(expression)\n\n      const elementData: NamespacedReactiveRecords = {\n        text: {\n          [name]: effect(() => {\n            if (!dataStack?.signals) return\n            const res = signalFn(el, dataStack, actions)\n            el.textContent = `${res}`\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataExtension } from '../core'\n\nconst once = 'once',\n  full = 'full',\n  half = 'half'\n\nexport const INTERSECTS = 'intersects'\nexport function addIntersectsExtension() {\n  addDataExtension(INTERSECTS, {\n    requiredExtensions: [SIGNAL],\n    allowedModifiers: [once, full, half],\n    withExpression: ({ name, el, expression, dataStack, actions, hasMod, reactivity: { effect, onCleanup } }) => {\n      const signalFn = functionGenerator(expression)\n      const fn = () => signalFn(el, dataStack, actions)\n\n      const options = { threshold: 0 }\n      if (hasMod(full)) options.threshold = 1\n      else if (hasMod(half)) options.threshold = 0.5\n\n      const observer = new IntersectionObserver((entries) => {\n        entries.forEach((entry) => {\n          if (entry.isIntersecting) {\n            fn()\n\n            if (hasMod(once)) {\n              observer.disconnect()\n            }\n          }\n        })\n      }, options)\n\n      const elementData: NamespacedReactiveRecords = {\n        on: {\n          [name]: effect(() => {\n            observer.observe(el)\n\n            onCleanup(() => {\n              observer.disconnect()\n            })\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { addActionDataExtension } from './actions.js'\nimport { addBindDataExtension } from './bind.js'\nimport { addFocusDataExtension } from './focus.js'\nimport { addAllFragmentExtensions } from './fragments.js'\nimport { addModelDataExtension } from './model.js'\nimport { addOnDataExtension } from './on.js'\nimport { addRefDataExtension } from './ref.js'\nimport { addShowDataExtension } from './show.js'\nimport { addSignalDataExtension } from './signal.js'\nimport { addTeleportDataExtension } from './teleport.js'\nimport { addTextDataExtension } from './text.js'\n\nexport * from './bind.js'\nexport * from './focus.js'\nexport * from './fragments.js'\nexport * from './intersects.js'\nexport * from './on.js'\nexport * from './ref.js'\nexport * from './show.js'\nexport * from './signal.js'\nexport * from './teleport.js'\nexport * from './text.js'\n\nexport function addAllIncludedExtensions() {\n  addActionDataExtension()\n  addSignalDataExtension()\n  addBindDataExtension()\n  addModelDataExtension()\n  addFocusDataExtension()\n  addAllFragmentExtensions()\n  addOnDataExtension()\n  addRefDataExtension()\n  addShowDataExtension()\n  addTeleportDataExtension()\n  addTextDataExtension()\n}\n","export interface MockedResponse {\n  html: string\n  status?: number\n  statusText?: string\n  headers?: Headers\n}\n\nexport interface MockFetchRoutes {\n  [url: string]: {\n    [method: string]: (req: Request) => Promise<MockedResponse>\n  }\n}\n\nexport function injectMockFetch(routes: MockFetchRoutes) {\n  console.warn(`Overriding fetch with mock version, this should only be used in examples.`)\n\n  const mockFetch = async (url: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n    const req = new Request(url, init)\n\n    if (!(url instanceof URL)) throw new Error(`url must be a URL`)\n\n    const urlMethods = routes[url.pathname]\n    if (!urlMethods) throw new Error(`No mock route found for ${req.url}`)\n\n    const methodFn = urlMethods[req.method]\n    if (!methodFn) throw new Error(`No mock route found for ${req.method} ${req.url}`)\n\n    let { html, status, statusText, headers } = await methodFn(req)\n    if (!headers) headers = new Headers()\n    if (!headers.has('Content-Type')) headers.append('Content-Type', 'text/html')\n    status = status || 200\n    statusText = statusText || 'OK'\n\n    const res = new Response(html, { status, statusText, headers })\n    return res\n  }\n\n  window.fetch = mockFetch\n}\n"],"names":["walkDownDOM","el","callback","walkUpDOM","functionGenerator","str","fnContents","functionEval","dataStack","actions","fn","camelize","word","index","CurrentReaction","CurrentGets","CurrentGetsIndex","EffectQueue","stabilizeFn","stabilizationQueued","CacheClean","CacheCheck","CacheDirty","reactive","fnOrValue","params","node","Reactive","defaultEquality","a","b","isEffect","v","value","i","state","oldValue","prevReaction","prevGets","prevIndex","c","source","observer","swap","onCleanup","stabilize","autoStabilize","deferredStabilize","signal","initialValue","computed","effect","mutations","m","extensionElementRegistry","extensionApplyFunctions","useProcessor","regexp","replacer","matches","match","groups","whole","cyrb53","seed","h1","h2","ch","prefixHashes","extensionPreprocessStack","data","addDataExtension","prefix","args","hash","extension","extensionsRegistered","requiredExtension","allAllowedModifiers","modifier","allowedTags","t","registerExtensionOnElement","parentEl","element","toHTMLorSVGElement","extensions","tagLower","name","modifiersWithArgsArr","pl","pl1","modifiers","label","allowedModifier","loadDataStack","expression","preprocessor","elementData","postExpression","withModifier","hasModifier","stack","elData","namespacedRecords","namespaceKey","addActionExtension","requiredExtensions","extensionHashes","ACTION","ext","nextID","uniqueId","addActionDataExtension","action","BIND","addBindDataExtension","SIGNAL","signalFn","res","FOCUS","addFocusDataExtension","generatedByIdiomorphId","idiomorph","oldNode","newContent","config","parsedContent","parseContent","normalizedContent","normalizeContent","ctx","createMorphContext","morphNormalizedContent","normalizedNewContent","oldHead","newHead","promises","handleHeadElement","morphChildren","bestMatch","findBestNodeMatch","previousSibling","nextSibling","morphedNode","morphOldNodeTo","insertSiblings","isSoftMatch","syncNodeFrom","newParent","oldParent","nextNewChild","insertionPoint","newChild","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","from","to","type","fromAttribute","toAttribute","syncAttribute","fromValue","toValue","attributeName","fAttr","tAttr","newHeadTag","currentHead","added","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","newHeadChild","currentHeadElt","inNewContent","isReAppended","isPreserved","newNode","newElt","resolver","promise","resolve","removedElement","noOp","createIdMap","elt","node1","node2","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","parser","contentWithSvgsRemoved","content","Element","dummyParent","currentElement","bestElement","score","newScore","scoreElement","isIdInConsideration","id","idIsWithinNode","targetNode","idSet","sourceSet","matchCount","populateIdMapForNode","idMap","nodeParent","idElements","current","oldContent","p","DATASTAR_CLASS_PREFIX","INDICATOR_CLASS","LOADING_CLASS","ACCEPT","TEXT_HTML","CONTENT_TYPE","APPLICATION_JSON","SELECTOR","SWAP","GET","addGetExtension","addFetchMethod","POST","addPostExtension","PUT","addPutExtension","PATCH","addPatchExtension","DELETE","addDeleteExtension","addAllFragmentExtensions","hasInjectedStyles","method","style","fetcher","elRaw","urlSignal","url","headers","dataStackJSON","_","req","queryParams","html","dom","frag","fragElement","firstFrag","hasID","useElAsTarget","targets","targetSelector","target","MODEL","updateEvents","addModelDataExtension","setter","event","ON","ONCE","THROTTLE","DEBOUNCE","LEADING","addOnDataExtension","hasMod","withMod","hasOnce","throttleMod","debounceMod","hasLeading","wrappedFnCallback","throttleTimeRaw","throttleTime","prev","throttledFn","now","debounceTimeRaw","debounceTime","timerID","debouncedFn","REF","addRefDataExtension","ref","IMPORTANT","DISPLAY","NONE","SHOW","addShowDataExtension","priority","PERSIST_KEY","addSignalDataExtension","reactivity","parsedValue","PREPEND","APPEND","MUST_PARENT_ERR","TELEPORT","addTeleportDataExtension","n","TEXT","addTextDataExtension","once","full","half","INTERSECTS","addIntersectsExtension","options","entries","entry","addAllIncludedExtensions","injectMockFetch","routes","mockFetch","init","urlMethods","methodFn","status","statusText"],"mappings":"sCAAgB,SAAAA,EAAYC,EAAoBC,EAAiC,CAC/E,GAAKD,EAKL,IAJAC,EAASD,CAAE,EAEXA,EAAKA,EAAG,kBAEDA,GACLD,EAAYC,EAAIC,CAAQ,EACxBD,EAAKA,EAAG,kBAEZ,CAOgB,SAAAE,EAAUF,EAAoBC,EAAiC,CACxED,IACLC,EAASD,CAAE,EAEXA,EAAKA,EAAG,cACRE,EAAUF,EAAIC,CAAQ,EACxB,CCrBO,SAASE,EAAqBC,EAAkD,CAC/E,MAAAC,EAAa,UAAUD,CAAG,GAEzB,OADI,IAAI,SAAS,KAAM,YAAa,UAAWC,CAAU,CAElE,CAEO,SAASC,GAAaN,EAAaO,EAAsCC,EAAqBJ,EAAa,CAC1G,MAAAK,EAAKN,EAAkBC,CAAG,EAC5B,GAAA,CACK,OAAAK,EAAGT,EAAIO,EAAWC,CAAO,OACtB,CACF,QAAA,MAAM,gCAAgCJ,CAAG,EAAE,CACrD,CACF,CAEO,SAASM,GAASN,EAAa,CACpC,OAAOA,EACJ,QAAQ,sBAAuB,CAACO,EAAMC,IAC9BA,IAAU,EAAID,EAAK,YAAY,EAAIA,EAAK,aAChD,EACA,QAAQ,OAAQ,EAAE,CACvB,CCSA,IAAIE,EACAC,EAAsC,KACtCC,EAAmB,EAGnBC,EAA+B,CAAA,EAE/BC,EACAC,EAAsB,GAGnB,MAAMC,EAAa,EACbC,GAAa,EACbC,EAAa,EAyBV,SAAAC,EAAYC,EAA0BC,EAAwC,CAC5F,MAAMC,EAAO,IAAIC,GAASH,EAAWC,GAAQ,MAAM,EACnD,OAAIA,GAAQ,SACVC,EAAK,OAASD,EAAO,QAEhBC,CACT,CAEA,SAASE,GAAgBC,EAAQC,EAAQ,CACvC,OAAOD,IAAMC,CACf,CAcO,MAAMH,EAAY,CAUvB,YACEH,EACSO,EAAW,GACpB,CADS,KAAA,SAAAA,EAEL,OAAOP,GAAc,YACvB,KAAK,GAAKA,EACV,KAAK,OAAS,OACd,KAAK,SAAWO,GAAY,GAC5B,KAAK,MAAQT,EACTS,IACFd,EAAY,KAAK,IAAI,EACrBC,IAAc,IAAI,KAGpB,KAAK,GAAK,OACV,KAAK,OAASM,EACd,KAAK,MAAQJ,EACb,KAAK,SAAW,GAEpB,CA5BQ,OACA,GACA,UAAoC,KACpC,QAAkC,KAElC,MACR,SAAsC,CAAA,EACtC,OAASQ,GAuBT,IAAI,OAAW,CACb,OAAO,KAAK,KACd,CAEA,IAAI,MAAMI,EAAM,CACd,KAAK,IAAIA,CAAC,CACZ,CAEA,KAAS,CACP,OAAIlB,IACE,CAACC,GAAeD,EAAgB,SAAWA,EAAgB,QAAQE,CAAgB,GAAK,KAC1FA,IAEKD,EACAA,EAAY,KAAK,IAAI,EADRA,EAAc,CAAC,IAAI,GAIrC,KAAK,IAAI,KAAK,kBAAkB,EAC7B,KAAK,MACd,CAEA,IAAIS,EAAgC,CAC9B,GAAA,OAAOA,GAAc,WAAY,CACnC,MAAMd,EAAKc,EACPd,IAAO,KAAK,IACd,KAAK,MAAMY,CAAU,EAEvB,KAAK,GAAKZ,CAAA,KACL,CACD,KAAK,KACP,KAAK,sBAAsB,CAAC,EAC5B,KAAK,QAAU,KACf,KAAK,GAAK,QAEZ,MAAMuB,EAAQT,EACd,GAAI,CAAC,KAAK,OAAO,KAAK,OAAQS,CAAK,EAAG,CACpC,GAAI,KAAK,UACP,QAASC,EAAI,EAAGA,EAAI,KAAK,UAAU,OAAQA,IACxB,KAAK,UAAUA,CAAC,EACxB,MAAMZ,CAAU,EAG7B,KAAK,OAASW,CAChB,CACF,CACF,CAEQ,MAAME,EAA4B,CACpC,GAAA,KAAK,MAAQA,IAEX,KAAK,QAAUf,GAAc,KAAK,WACpCH,EAAY,KAAK,IAAI,EACrBC,IAAc,IAAI,GAGpB,KAAK,MAAQiB,EACT,KAAK,WACP,QAASD,EAAI,EAAGA,EAAI,KAAK,UAAU,OAAQA,IACzC,KAAK,UAAUA,CAAC,EAAE,MAAMb,EAAU,CAI1C,CAGQ,QAAe,CACrB,MAAMe,EAAW,KAAK,OAGhBC,EAAevB,EACfwB,EAAWvB,EACXwB,EAAYvB,EAEAF,EAAA,KACJC,EAAA,KACKC,EAAA,EAEf,GAAA,CAQF,GAPI,KAAK,SAAS,SAChB,KAAK,SAAS,QAASwB,GAAMA,EAAE,KAAK,MAAM,CAAC,EAC3C,KAAK,SAAW,IAEb,KAAA,OAAS,KAAK,KAGfzB,EAAa,CAIX,GAFJ,KAAK,sBAAsBC,CAAgB,EAEvC,KAAK,SAAWA,EAAmB,EAAG,CACnC,KAAA,QAAQ,OAASA,EAAmBD,EAAY,OACrD,QAASmB,EAAI,EAAGA,EAAInB,EAAY,OAAQmB,IACtC,KAAK,QAAQlB,EAAmBkB,CAAC,EAAInB,EAAYmB,CAAC,CACpD,MAEA,KAAK,QAAUnB,EAGjB,QAASmB,EAAIlB,EAAkBkB,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAErD,MAAAO,EAAS,KAAK,QAAQP,CAAC,EACxBO,EAAO,UAGHA,EAAA,UAAU,KAAK,IAAI,EAFnBA,EAAA,UAAY,CAAC,IAAI,CAI5B,CAAA,MACS,KAAK,SAAWzB,EAAmB,KAAK,QAAQ,SAEzD,KAAK,sBAAsBA,CAAgB,EAC3C,KAAK,QAAQ,OAASA,EACxB,QACA,CACcD,EAAAuB,EACIxB,EAAAuB,EACCrB,EAAAuB,CACrB,CAGI,GAAA,CAAC,KAAK,OAAOH,EAAU,KAAK,MAAM,GAAK,KAAK,UAE9C,QAASF,EAAI,EAAGA,EAAI,KAAK,UAAU,OAAQA,IAAK,CACxC,MAAAQ,EAAW,KAAK,UAAUR,CAAC,EACjCQ,EAAS,MAAQpB,CACnB,CAKF,KAAK,MAAQF,CACf,CAGQ,mBAA0B,CAE5B,GAAA,KAAK,QAAUC,IACN,UAAAoB,KAAU,KAAK,QAEnB,GADLA,EAAO,kBAAkB,EACpB,KAAK,QAAyBnB,EAIjC,MAMF,KAAK,QAAUA,GACjB,KAAK,OAAO,EAId,KAAK,MAAQF,CACf,CAEQ,sBAAsBP,EAAqB,CACjD,GAAK,KAAK,QACV,QAASqB,EAAIrB,EAAOqB,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC1C,MAAAO,EAAwB,KAAK,QAAQP,CAAC,EACtCS,EAAOF,EAAO,UAAW,UAAWT,GAAMA,IAAM,IAAI,EACnDS,EAAA,UAAWE,CAAI,EAAIF,EAAO,UAAWA,EAAO,UAAW,OAAS,CAAC,EACxEA,EAAO,UAAW,KACpB,CACF,CACF,CAEO,SAASG,GAAmBlC,EAAiC,CAC9DI,EACcA,EAAA,SAAS,KAAKJ,CAAE,EAEhC,QAAQ,MAAM,2DAA2D,CAE7E,CAGO,SAASmC,IAAkB,CAChC,QAASX,EAAI,EAAGA,EAAIjB,EAAY,OAAQiB,IAC1BjB,EAAAiB,CAAC,EAAE,MAEjBjB,EAAY,OAAS,CACvB,CAGgB,SAAA6B,GAAcpC,EAAKqC,GAAyB,CAC5C7B,EAAAR,CAChB,CAGA,SAASqC,IAA0B,CAC5B5B,IACmBA,EAAA,GAEtB,eAAe,IAAM,CACGA,EAAA,GACZ0B,IAAA,CACX,EAEL,CC9TAC,KAEA,SAASE,GAAUC,EAA8B,CAC/C,OAAO1B,EAAS0B,CAAY,CAC9B,CAEA,SAASC,GAAYxC,EAA0B,CAC7C,OAAOa,EAASb,CAAE,CACpB,CAEA,SAASyC,GAAOzC,EAAgB,CAC9B,OAAOa,EAASb,EAAI,CAAE,OAAQ,EAAM,CAAA,CACtC,CAE0B,IAAI,iBAAkB0C,GAAc,CAC5D,UAAWC,KAAKD,EACZC,EAAA,aAAa,QAAS3B,GAAS,CAC/B,MAAMzB,EAAKyB,EACNzB,GACLqD,EAAyB,OAAOrD,CAAE,CAAA,CACnC,EAECoD,EAAA,WAAW,QAAS3B,GAAS,CAC7B,MAAMzB,EAAKyB,EACNzB,GACLsD,GAAwB,QAAS7C,GAAOA,EAAGT,CAAE,CAAC,CAAA,CAC/C,CAEL,CAAC,EAEiB,QAAQ,SAAU,CAClC,WAAY,GACZ,UAAW,GACX,QAAS,EACX,CAAC,EAQM,SAASuD,GAAa,CAAE,OAAAC,EAAQ,SAAAC,CAAA,EAA0BrD,EAAqB,CAEpF,MAAMsD,EAAU,CAAC,GAAGtD,EAAI,SAASoD,CAAM,CAAC,EACxC,GAAI,CAACE,EAAQ,OAAe,OAAAtD,EAC5B,UAAWuD,KAASD,EAAS,CAC3B,GAAI,CAACC,EAAM,OAAQ,SACb,KAAA,CAAE,OAAAC,CAAW,EAAAD,EACb,CAAE,MAAAE,CAAU,EAAAD,EAClBxD,EAAMA,EAAI,QAAQyD,EAAOJ,EAASG,CAAM,CAAC,CAC3C,CACO,OAAAxD,CACT,CAEA,SAAS0D,GAAO1D,EAAa2D,EAAO,EAAG,CACrC,IAAIC,EAAK,WAAaD,EACpBE,EAAK,WAAaF,EACpB,QAAS9B,EAAI,EAAGiC,EAAIjC,EAAI7B,EAAI,OAAQ6B,IAC7BiC,EAAA9D,EAAI,WAAW6B,CAAC,EACrB+B,EAAK,KAAK,KAAKA,EAAKE,EAAI,UAAU,EAClCD,EAAK,KAAK,KAAKA,EAAKC,EAAI,UAAU,EAEpC,OAAAF,EAAK,KAAK,KAAKA,EAAMA,IAAO,GAAK,UAAU,EAC3CA,GAAM,KAAK,KAAKC,EAAMA,IAAO,GAAK,UAAU,EAC5CA,EAAK,KAAK,KAAKA,EAAMA,IAAO,GAAK,UAAU,EAC3CA,GAAM,KAAK,KAAKD,EAAMA,IAAO,GAAK,UAAU,EAErC,YAAc,QAAUC,IAAOD,IAAO,EAC/C,CAEA,MAAMG,MAAmB,IACnBb,OAA8B,IAC9BD,MAA+B,IAC/Be,GAA2B,IAAI,MAC/BC,MAAW,IAEX7D,EAAsB,CAAA,EAEZ,SAAA8D,EACdC,EACAC,EAQA,CACI,GAAAD,EAAO,gBAAkBA,EAAc,MAAA,MAAM,wBAAwBA,CAAM,qBAAqB,EAChG,GAAAJ,EAAa,IAAII,CAAM,EACzB,MAAM,IAAI,MAAM,wBAAwBA,CAAM,sBAAsB,EAGhE,MAAAE,EAAOX,GAAOS,CAAM,EACbJ,EAAA,IAAII,EAAQE,CAAI,EAExBD,IACHA,EAAO,CAAA,GAGT,UAAWE,KAAaF,EAAK,oBAAsB,CAAA,EACjD,GAAIE,IAAcH,EAChB,MAAM,IAAI,MAAM,wBAAwBA,CAAM,yBAAyB,EAI3E,MAAMI,EAAuB,IAAI,IAAIR,EAAa,KAAM,CAAA,EACxD,UAAWS,KAAqBJ,EAAK,oBAAsB,CAAA,EACzD,GAAI,CAACG,EAAqB,IAAIC,CAAiB,EAC7C,MAAM,IAAI,MAAM,wBAAwBL,CAAM,wBAAwB,EAItE,OAAOC,GAAM,mBAAuB,MACtCA,EAAK,mBAAqB,IAGxBA,GAAM,uBAAyBA,EAAK,oBACbJ,GAAA,KAAK,GAAGI,EAAK,qBAAqB,EAG7D,MAAMK,EAAgC,CAAA,EACtC,GAAIL,GAAM,iBACG,UAAAM,KAAYN,EAAK,iBAAkB,CAC5C,MAAMpB,EAAI0B,aAAoB,OAASA,EAAW,IAAI,OAAOA,CAAQ,EACrED,EAAoB,KAAKzB,CAAC,CAC5B,CAGF,MAAM2B,EAAc,IAAI,IAAI,CAAC,GAAIP,GAAM,aAAe,CAAA,CAAG,EAAE,IAAKQ,GAAMA,EAAE,YAAA,CAAa,CAAC,EAEtF,SAASC,EAA2BC,EAAmB,CACzCnF,EAAAmF,EAAWC,GAAY,CAC3B,MAAAnF,EAAKoF,EAAmBD,CAAO,EACrC,GAAI,CAACnF,EAAI,OAEL,IAAAqF,EAAahC,EAAyB,IAAIrD,CAAE,EAM5C,GALCqF,IACHA,MAAiB,IACQhC,EAAA,IAAIrD,EAAIqF,CAAU,GAGzC,CAAAA,EAAW,IAAIZ,CAAI,EAGvB,IAFAY,EAAW,IAAIZ,CAAI,EAEfM,EAAY,KAAM,CACd,MAAAO,EAAWtF,EAAG,QAAQ,YAAY,EACpC,GAAA,CAAC+E,EAAY,IAAIO,CAAQ,EAAG,MAClC,CAES,QAAA,KAAKtF,EAAG,QAAS,CACpB,GAAA,CAAC,EAAE,WAAWuE,CAAM,EAAG,SAE3B,GAAI,CAACgB,EAAM,GAAGC,CAAoB,EAAI,EAAE,MAAM,GAAG,EAEjD,MAAMC,EAAKlB,EAAO,OACZmB,EAAMD,EAAK,EACVF,EAAAA,EAAK,MAAME,EAAIC,CAAG,EAAE,kBAAkB,EAAIH,EAAK,MAAMG,CAAG,EAE/D,MAAMC,EAAYH,EAAqB,IAAKpC,GAAM,CAChD,KAAM,CAACwC,EAAO,GAAGpB,CAAI,EAAIpB,EAAE,MAAM,GAAG,EAGpC,GAAI,CADcyB,EAAoB,KAAMgB,IAAoBA,GAAgB,KAAKD,CAAK,CAAC,EAEzF,MAAM,IAAI,MAAM,YAAYA,CAAK,uBAAuBL,CAAI,EAAE,EAGzD,MAAA,CAAE,MAAAK,EAAO,KAAApB,EAAK,CACtB,EAEKjE,EAAYuF,GAAc9F,CAAE,EAClC,IAAI+F,EAAa/F,EAAG,QAAQ,CAAC,GAAK,GAElC,UAAWgG,KAAgB5B,GACZ2B,EAAAxC,GAAayC,EAAcD,CAAU,EAGpD,GAAIvB,GAAM,uBAAyB,CAACA,GAAM,mBAC7B,UAAAwB,KAAgBxB,EAAK,sBACjBuB,EAAAxC,GAAayC,EAAcD,CAAU,EAItD,MAAME,EAAc5B,EAAK,IAAIrE,CAAE,GAAK,CAAA,EACpC,GAAIwE,GAAM,eAAgB,CAClB,MAAA0B,EAAiB1B,EAAK,eAAe,CACzC,KAAAe,EACA,WAAAQ,EACA,GAAA/F,EACA,UAAAO,EACA,WAAY,CACV,OAAAwC,GACA,SAAAE,GACA,OAAAC,GACA,UAAAP,EACF,EACA,QAAUiD,GAAkBO,GAAaR,EAAWC,CAAK,EACzD,OAASA,GAAkBQ,GAAYT,EAAWC,CAAK,EACvD,QAAApF,CAAA,CACD,EACG0F,GACK,OAAA,OAAOD,EAAaC,CAAc,CAE7C,CACK7B,EAAA,IAAIrE,EAAIiG,CAAW,CAC1B,EAAA,CACD,CACH,CAEAhB,EAA2B,SAAS,IAAI,EAChB3B,GAAA,IAAImB,EAAMQ,CAA0B,CAG9D,CAEA,SAASa,GAAc9F,EAAwC,CAC7D,MAAMqG,EAAqC,CAAA,EAEjCnG,EAAAF,EAAKA,GAAO,CACd,MAAAsG,EAASjC,EAAK,IAAIrE,CAAE,EACtBsG,GAAQD,EAAM,KAAKC,CAAM,CAAA,CAC9B,EAEDD,EAAM,QAAQ,EAEd,MAAM9F,EAAuC,CAAA,EAC7C,UAAWgG,KAAqBF,EAC9B,UAAWG,KAAgBD,EACpBhG,EAAUiG,CAAY,IACfjG,EAAAiG,CAAY,EAAI,IAE5B,OAAO,OAAOjG,EAAUiG,CAAY,EAAGD,EAAkBC,CAAY,CAAC,EAInE,OAAAjG,CACT,CAEO,SAAS6E,EAAmBpF,EAAa,CAC9C,OAAMA,aAAc,aAAeA,aAAc,WAG1CA,EAFE,IAGX,CAEgB,SAAAoG,GAAYT,EAAuBC,EAAe,CAChE,OAAOD,EAAU,KAAMvC,GAAMA,EAAE,QAAUwC,CAAK,CAChD,CAEgB,SAAAO,GAAaR,EAAuBC,EAAe,CACjE,OAAOD,EAAU,KAAMvC,GAAMA,EAAE,QAAUwC,CAAK,CAChD,CAEO,SAASa,GAAmBjC,EAKhC,CACD,KAAM,CAAE,KAAAe,EAAM,GAAA9E,EAAI,mBAAAiG,CAAA,EAAuBlC,EACnCmC,EAAkB,CAACC,EAAQ,GAAIF,GAAsB,CAAG,CAAA,EAE1D,GAAAnB,GAAQ7E,GAAS6E,CAAI,EACjB,MAAA,IAAI,MAAM,mBAAmB,EAGrC,UAAWsB,KAAOF,EAAiB,CACjC,GAAI,CAACxC,EAAa,IAAI0C,CAAG,EACvB,MAAM,IAAI,MAAM,cAActB,CAAI,gBAAgB,EAGpD,GAAIA,KAAQ/E,EACV,MAAM,IAAI,MAAM,KAAK+E,CAAI,sBAAsB,EAGjD/E,EAAQ+E,CAAI,EAAI9E,CAClB,CACF,CAEA,IAAIqG,GAAS,EACN,SAASC,IAAW,CAClB,OAAAD,IACT,CC/RO,MAAMF,EAAS,SAEf,SAASI,IAAyB,CACvC1C,EAAiBsC,EAAQ,CACvB,sBAAuB,CACrB,CACE,KAAM,SACN,YAAa,gDACb,OAAQ,IAAI,OAAO,0EAA0E,EAC7F,SAAU,CAAC,CAAE,OAAAK,EAAQ,KAAAzC,KAAW,WAAWyC,CAAM,6BAA6BzC,GAAQ,EAAE,GAC1F,CACF,CAAA,CACD,CACH,CCZa,MAAA0C,GAAO,OACb,SAASC,IAAuB,CACrC7C,EAAiB4C,GAAM,CACrB,mBAAoB,CAACE,CAAM,EAC3B,eAAgB,CAAC,CAAE,GAAApH,EAAI,KAAAuF,EAAM,WAAAQ,EAAY,UAAAxF,EAAW,QAAAC,EAAS,WAAY,CAAE,OAAA0C,CAAO,KAAQ,CAClF,MAAAmE,EAAWlH,EAAkB4F,CAAU,EAYtC,MAVwC,CAC7C,KAAM,CACJ,CAACR,CAAI,EAAGrC,EAAO,IAAM,CACnB,GAAI,CAAC3C,GAAW,QAAS,OACzB,MAAM+G,EAAMD,EAASrH,EAAIO,EAAWC,CAAO,EAC3CR,EAAG,aAAauF,EAAM,GAAG+B,CAAG,EAAE,CAAA,CAC/B,CACH,CAAA,CAIJ,CAAA,CACD,CACH,CCpBa,MAAAC,GAAQ,QACd,SAASC,IAAwB,CACtClD,EAAiBiD,GAAO,CACtB,mBAAoB,CAACH,CAAM,EAC3B,eAAgB,CAAC,CAAE,GAAApH,KAAS,CACpB,MAAAmF,EAAUC,EAAmBpF,CAAE,EACrC,GAAI,CAACmF,GAAS,MAAa,MAAA,IAAI,MAAM,kCAAkC,EACvE,OAAAA,EAAQ,MAAM,EACP,EACT,CAAA,CACD,CACH,CCdA,MAAMsC,MAA6B,QAK5B,SAASC,GAAUC,EAA6BC,EAA8BC,EAAS,CAAA,EAAI,CAC5FF,aAAmB,WACrBA,EAAUA,EAAQ,iBAGhB,IAAAG,EACA,OAAOF,GAAe,SACxBE,EAAgBC,GAAaH,CAAU,EAEvBE,EAAAF,EAGZ,MAAAI,EAAoBC,GAAiBH,CAAa,EAClDI,EAAMC,GAAmBR,EAASK,EAAmBH,CAAM,EAE1D,OAAAO,GAAuBT,EAASK,EAAmBE,CAAG,CAC/D,CAEA,SAASE,GAAuBT,EAAkBU,EAA+BH,EAAU,CACrF,GAAAA,EAAI,KAAK,MAAO,CACZ,MAAAI,EAAUX,EAAQ,cAAc,MAAM,EACtCY,EAAUF,EAAqB,cAAc,MAAM,EACzD,GAAIC,GAAWC,EAAS,CACtB,MAAMC,EAAWC,GAAkBF,EAASD,EAASJ,CAAG,EAExD,QAAQ,IAAIM,CAAQ,EAAE,KAAK,IAAM,CAC/BJ,GACET,EACAU,EACA,OAAO,OAAOH,EAAK,CACjB,KAAM,CACJ,MAAO,GACP,OAAQ,EACV,CAAA,CACD,CAAA,CACH,CACD,EACD,MACF,CACF,CAEI,GAAAA,EAAI,aAAe,YAEP,OAAAQ,GAAAL,EAAsBV,EAASO,CAAG,EACzCP,EAAQ,YACNO,EAAI,aAAe,aAAeA,EAAI,YAAc,KAAM,CAGnE,MAAMS,EAAYC,GAAkBP,EAAsBV,EAASO,CAAG,EACtE,GAAI,CAACS,EAAiB,MAAA,IAAI,MAAM,2BAA2B,EAG3D,MAAME,EAAkBF,GAAW,gBAC7BG,EAAcH,GAAW,YAGzBI,EAAcC,EAAerB,EAASgB,EAAWT,CAAG,EAE1D,OAAIS,EAGKM,GAAeJ,EAAiBE,EAAaD,CAAW,EAGxD,EACT,KAEA,MAAM,wCAA0CZ,EAAI,UAExD,CAQA,SAASc,EAAerB,EAAkBC,EAAqBM,EAAU,CACvE,GAAI,EAAAA,EAAI,cAAgBP,IAAY,SAAS,eAE7C,GAAWC,GAAc,KAAM,CAC7B,GAAIM,EAAI,UAAU,kBAAkBP,CAAO,IAAM,GAAO,OAExDA,EAAQ,OAAO,EACXO,EAAA,UAAU,iBAAiBP,CAAO,EACtC,MACS,KAAA,IAACuB,EAAYvB,EAASC,CAAU,EAUzC,OAAIM,EAAI,UAAU,kBAAkBP,EAASC,CAAU,IAAM,GAAO,QAEhED,aAAmB,iBAAmBO,EAAI,KAAK,SAGjDN,aAAsB,iBACtBD,aAAmB,iBACnBO,EAAI,KAAK,QAAU,QAEDO,GAAAb,EAAYD,EAASO,CAAG,GAE1CiB,GAAavB,EAAYD,CAAO,EAClBe,GAAAd,EAAYD,EAASO,CAAG,IAEpCA,EAAA,UAAU,iBAAiBP,EAASC,CAAU,EAC3CD,GAvBP,GADIO,EAAI,UAAU,kBAAkBP,CAAO,IAAM,IAC7CO,EAAI,UAAU,gBAAgBN,CAAU,IAAM,GAAO,OAEzD,GAAI,CAACD,EAAQ,cAAqB,MAAA,IAAI,MAAM,8BAA8B,EAClE,OAAAA,EAAA,cAAc,aAAaC,EAAYD,CAAO,EAClDO,EAAA,UAAU,eAAeN,CAAU,EACnCM,EAAA,UAAU,iBAAiBP,CAAO,EAC/BC,EAmBX,CAwBA,SAASc,GAAcU,EAAoBC,EAAoBnB,EAAU,CACvE,IAAIoB,EAAeF,EAAU,WACzBG,EAAiBF,EAAU,WAC3BG,EAGJ,KAAOF,GAAc,CAKnB,GAJWE,EAAAF,EACXA,EAAeE,EAAS,YAGpBD,GAAkB,KAAM,CAC1B,GAAIrB,EAAI,UAAU,gBAAgBsB,CAAQ,IAAM,GAAO,OAEvDH,EAAU,YAAYG,CAAQ,EAC1BtB,EAAA,UAAU,eAAesB,CAAQ,EACrCC,EAA2BvB,EAAKsB,CAAQ,EACxC,QACF,CAGA,GAAIE,GAAaF,EAAUD,EAAgBrB,CAAG,EAAG,CAChCc,EAAAO,EAAgBC,EAAUtB,CAAG,EAC5CqB,EAAiBA,EAAe,YAChCE,EAA2BvB,EAAKsB,CAAQ,EACxC,QACF,CAGA,IAAIG,EAAaC,GAAeR,EAAWC,EAAWG,EAAUD,EAAgBrB,CAAG,EAGnF,GAAIyB,EAAY,CACGJ,EAAAM,GAAmBN,EAAgBI,EAAYzB,CAAG,EACpDc,EAAAW,EAAYH,EAAUtB,CAAG,EACxCuB,EAA2BvB,EAAKsB,CAAQ,EACxC,QACF,CAGA,IAAIM,EAAYC,GAAcX,EAAWI,EAAUD,EAAgBrB,CAAG,EAGtE,GAAI4B,EAAW,CACIP,EAAAM,GAAmBN,EAAgBO,EAAW5B,CAAG,EACnDc,EAAAc,EAAWN,EAAUtB,CAAG,EACvCuB,EAA2BvB,EAAKsB,CAAQ,EACxC,QACF,CAIA,GAAItB,EAAI,UAAU,gBAAgBsB,CAAQ,IAAM,GAAO,OAE7CH,EAAA,aAAaG,EAAUD,CAAc,EAC3CrB,EAAA,UAAU,eAAesB,CAAQ,EACrCC,EAA2BvB,EAAKsB,CAAQ,CAC1C,CAGA,KAAOD,IAAmB,MAAM,CAC9B,IAAIS,EAAWT,EACfA,EAAiBA,EAAe,YAChCU,GAAWD,EAAU9B,CAAG,CAC1B,CACF,CAaA,SAASiB,GAAae,EAAeC,EAAa,CAChD,IAAIC,EAAOF,EAAK,SAIhB,GAAIE,IAAS,EAAsB,CACtB,UAAAC,KAAiBH,EAAK,WACXC,EAAG,aAAaE,EAAc,IAAI,IAClCA,EAAc,OAChCF,EAAG,aAAaE,EAAc,KAAMA,EAAc,KAAK,EAGhD,UAAAC,KAAeH,EAAG,WACtBD,EAAK,aAAaI,EAAY,IAAI,GAClCH,EAAA,gBAAgBG,EAAY,IAAI,CAGzC,CAeA,IAZIF,IAAS,KAAK,cAAgBA,IAAS,KAAK,YAC1CD,EAAG,YAAcD,EAAK,YACxBC,EAAG,UAAYD,EAAK,WAUpBA,aAAgB,kBAAoBC,aAAc,kBAAoBD,EAAK,OAAS,OACnFC,EAAA,MAAQD,EAAK,OAAS,GACXK,EAAAL,EAAMC,EAAI,OAAO,EAGjBI,EAAAL,EAAMC,EAAI,SAAS,EACnBI,EAAAL,EAAMC,EAAI,UAAU,UACzBD,aAAgB,kBACXK,EAAAL,EAAMC,EAAI,UAAU,UACzBD,aAAgB,qBAAuBC,aAAc,oBAAqB,CACnF,MAAMK,EAAYN,EAAK,MACjBO,EAAUN,EAAG,MACfK,IAAcC,IAChBN,EAAG,MAAQK,GAETL,EAAG,YAAcA,EAAG,WAAW,YAAcK,IAC/CL,EAAG,WAAW,UAAYK,EAE9B,CACF,CAEA,SAASD,EAAcL,EAAeC,EAAaO,EAAuB,CAClE,MAAAC,EAAQT,EAAK,aAAaQ,CAAa,EACvCE,EAAQT,EAAG,aAAaO,CAAa,EAEvCC,IAAUC,IACRD,EACCR,EAAA,aAAaO,EAAeC,CAAK,EAEpCR,EAAG,gBAAgBO,CAAa,EAGtC,CAKA,SAASjC,GAAkBoC,EAA6BC,EAA8B5C,EAAU,CAC9F,MAAM6C,EAAQ,CAAA,EACRC,EAAU,CAAA,EACVC,EAAY,CAAA,EACZC,EAAgB,CAAA,EAEhBC,EAAiBjD,EAAI,KAAK,MAG1BkD,MAAwB,IACnB,UAAAC,KAAgBR,EAAW,SAClBO,EAAA,IAAIC,EAAa,UAAWA,CAAY,EAIjD,UAAAC,KAAkBR,EAAY,SAAU,CAEjD,IAAIS,EAAeH,EAAkB,IAAIE,EAAe,SAAS,EAC7DE,EAAetD,EAAI,KAAK,eAAeoD,CAAc,EACrDG,EAAcvD,EAAI,KAAK,eAAeoD,CAAc,EACpDC,GAAgBE,EACdD,EAEFR,EAAQ,KAAKM,CAAc,GAITF,EAAA,OAAOE,EAAe,SAAS,EACjDL,EAAU,KAAKK,CAAc,GAG3BH,IAAmB,SAGjBK,IACFR,EAAQ,KAAKM,CAAc,EAC3BJ,EAAc,KAAKI,CAAc,GAI/BpD,EAAI,KAAK,aAAaoD,CAAc,IAAM,IAC5CN,EAAQ,KAAKM,CAAc,CAInC,CAIAJ,EAAc,KAAK,GAAGE,EAAkB,OAAQ,CAAA,EACxC,QAAA,IAAI,cAAeF,CAAa,EAExC,MAAM1C,EAAW,CAAA,EACjB,UAAWkD,KAAWR,EAAe,CAC3B,QAAA,IAAI,WAAYQ,CAAO,EAC/B,MAAMC,EAAS,SAAS,cAAc,yBAAyBD,EAAQ,SAAS,EAAE,WAClF,GAAI,CAACC,EAAQ,MAAM,IAAI,MAAM,sCAAwCD,EAAQ,SAAS,EAEtF,GADA,QAAQ,IAAIC,CAAM,EACZzD,EAAI,UAAU,gBAAgByD,CAAM,EAAG,CAC3C,GAAIA,EAAO,aAAa,MAAM,GAAKA,EAAO,aAAa,KAAK,EAAG,CACzD,IAAAC,EACJ,MAAMC,EAAU,IAAI,QAASC,GAAY,CAC5BF,EAAAE,CAAA,CACZ,EACMH,EAAA,iBAAiB,OAAQ,UAAY,CAC1CC,EAAS,MAAS,CAAA,CACnB,EACDpD,EAAS,KAAKqD,CAAO,CACvB,CACAf,EAAY,YAAYa,CAAM,EAC1BzD,EAAA,UAAU,eAAeyD,CAAM,EACnCZ,EAAM,KAAKY,CAAM,CACnB,CACF,CAIA,UAAWI,KAAkBf,EACvB9C,EAAI,UAAU,kBAAkB6D,CAAc,IAAM,KACtDjB,EAAY,YAAYiB,CAAc,EAClC7D,EAAA,UAAU,iBAAiB6D,CAAc,GAI7C,OAAA7D,EAAA,KAAK,iBAAiB4C,EAAa,CACrC,MAAAC,EACA,KAAME,EACN,QAAAD,CAAA,CACD,EACMxC,CACT,CAKA,SAASwD,GAAO,CAAC,CAEjB,SAAS7D,GAAmBR,EAAkBC,EAAqBC,EAAa,CACvE,MAAA,CACL,OAAQF,EACR,WAAAC,EACA,OAAAC,EACA,WAAYA,EAAO,WACnB,aAAcA,EAAO,aACrB,MAAOoE,GAAYtE,EAASC,CAAU,EACtC,YAAa,IACb,UAAW,OAAO,OAChB,CACE,gBAAiBoE,EACjB,eAAgBA,EAChB,kBAAmBA,EACnB,iBAAkBA,EAClB,kBAAmBA,EACnB,iBAAkBA,CACpB,EACAnE,EAAO,SACT,EACA,KAAM,OAAO,OACX,CACE,MAAO,QACP,eAAiBqE,GAAiBA,EAAI,aAAa,aAAa,IAAM,OACtE,eAAiBA,GAAiBA,EAAI,aAAa,cAAc,IAAM,OACvE,aAAcF,EACd,iBAAkBA,CACpB,EACAnE,EAAO,IACT,CAAA,CAEJ,CAEA,SAAS6B,GAAayC,EAAgBC,EAAgBlE,EAAU,CAC1D,MAAA,CAACiE,GAAS,CAACC,EAAc,GAEzBD,EAAM,WAAaC,EAAM,UAAYD,EAAM,UAAYC,EAAM,QAC3DD,GAAO,IAAI,QAAUA,EAAM,KAAOC,EAAM,GAAW,GAEhDC,EAAuBnE,EAAKiE,EAAOC,CAAK,EAAI,EAE9C,EACT,CAEA,SAASlD,EAAYiD,EAAgBC,EAAgB,CAC/C,MAAA,CAACD,GAAS,CAACC,EAAc,GAEtBD,EAAM,WAAaC,EAAM,UAAYD,EAAM,UAAYC,EAAM,OACtE,CAEA,SAASvC,GAAmByC,EAAyBC,EAAuBrE,EAAU,CACpF,KAAOoE,IAAmBC,GAAc,CACtC,MAAMvC,EAAWsC,EAEjB,GADAA,EAAiBA,GAAgB,YAC7B,CAACtC,EAAgB,MAAA,IAAI,MAAM,kBAAkB,EACjDC,GAAWD,EAAU9B,CAAG,CAC1B,CACA,OAAAuB,EAA2BvB,EAAKqE,CAAY,EACrCA,EAAa,WACtB,CAQA,SAAS3C,GAAehC,EAAqByB,EAAoBG,EAAmBD,EAAyBrB,EAAU,CAErH,MAAMsE,EAA2BH,EAAuBnE,EAAKsB,EAAUH,CAAS,EAEhF,IAAIoD,EAAiC,KAGrC,GAAID,EAA2B,EAAG,CACfC,EAAAlD,EAKjB,IAAImD,EAAkB,EACtB,KAAOD,GAAkB,MAAM,CAE7B,GAAI/C,GAAaF,EAAUiD,EAAgBvE,CAAG,EACrC,OAAAuE,EAKT,GADmBC,GAAAL,EAAuBnE,EAAKuE,EAAgB7E,CAAU,EACrE8E,EAAkBF,EAGb,OAAA,KAITC,EAAiBA,EAAe,WAClC,CACF,CACO,OAAAA,CACT,CAQA,SAAS1C,GAAcnC,EAAqB4B,EAAmBD,EAAyBrB,EAAU,CAChG,IAAIyE,EAAqBpD,EACrBT,EAAcU,EAAS,YAEvBoD,EAAwB,EAE5B,KAAOD,GAAsB7D,GAAa,CACxC,GAAIuD,EAAuBnE,EAAKyE,EAAoB/E,CAAU,EAAI,EAGzD,OAAA,KAIL,GAAAsB,EAAYM,EAAUmD,CAAkB,EACnC,OAAAA,EAGL,GAAAzD,EAAYJ,EAAa6D,CAAkB,IAG7CC,IACA9D,EAAcA,EAAY,YAItB8D,GAAyB,GACpB,OAAA,KAKXD,EAAqBA,EAAmB,WAC1C,CAEO,OAAAA,CACT,CAEA,MAAME,GAAS,IAAI,UACnB,SAAS9E,GAAaH,EAAoB,CAExC,MAAMkF,EAAyBlF,EAAW,QAAQ,uCAAwC,EAAE,EAI1F,GAAAkF,EAAuB,MAAM,UAAU,GACvCA,EAAuB,MAAM,UAAU,GACvCA,EAAuB,MAAM,UAAU,EACvC,CACA,MAAMC,EAAUF,GAAO,gBAAgBjF,EAAY,WAAW,EAE1D,GAAAkF,EAAuB,MAAM,UAAU,EACzC,OAAArF,EAAuB,IAAIsF,CAAO,EAC3BA,EACF,CAEL,IAAIC,EAAUD,EAAQ,WACtB,OAAIC,GACFvF,EAAuB,IAAIuF,CAAO,EAC3BA,GAEA,IAEX,CAAA,KACK,CAIL,MAAMD,EADcF,GAAO,gBAAgB,mBAAmBjF,CAAU,qBAAsB,WAAW,EAC7E,KAAK,cAAc,UAAU,GAAG,QAC5D,GAAI,CAACmF,EAAe,MAAA,IAAI,MAAM,iBAAiB,EAC/C,OAAAtF,EAAuB,IAAIsF,CAAO,EAC3BA,CACT,CACF,CAEA,SAAS9E,GAAiBL,EAAqB,CAC7C,GAAIA,GAAc,KAGT,OADa,SAAS,cAAc,KAAK,EAEvC,GAAAH,EAAuB,IAAIG,CAAU,EAEvC,OAAAA,EACT,GAAWA,aAAsB,KAAM,CAE/B,MAAAqF,EAAc,SAAS,cAAc,KAAK,EAChD,OAAAA,EAAY,OAAOrF,CAAU,EACtBqF,CAAA,KACF,CAGC,MAAAA,EAAc,SAAS,cAAc,KAAK,EAChD,UAAWf,IAAO,CAAC,GAAGtE,CAAU,EAC9BqF,EAAY,OAAOf,CAAG,EAEjB,OAAAe,CACT,CACF,CAEA,SAAShE,GAAeJ,EAA2BE,EAAuBD,EAAuB,CAC/F,MAAMzC,EAAQ,CAAA,EACR0E,EAAQ,CAAA,EACd,KAAOlC,GACLxC,EAAM,KAAKwC,CAAe,EAC1BA,EAAkBA,EAAgB,gBAE7B,KAAAxC,EAAM,OAAS,GAAG,CACjB,MAAA5E,EAAO4E,EAAM,MACnB0E,EAAM,KAAKtJ,CAAI,EACFsH,GAAA,eAAe,aAAatH,EAAMsH,CAAW,CAC5D,CAEA,IADAgC,EAAM,KAAKhC,CAAW,EACfD,GACLzC,EAAM,KAAKyC,CAAW,EACtBiC,EAAM,KAAKjC,CAAW,EACtBA,EAAcA,EAAY,YAE5B,KAAOzC,EAAM,QACX0C,GAAa,eAAe,aAAa1C,EAAM,MAAQ0C,EAAY,WAAW,EAEzE,OAAAgC,CACT,CAEA,SAASnC,GAAkBhB,EAAqBD,EAAkBO,EAAU,CAC1E,IAAIgF,EAAiBtF,EAAW,WAC5BuF,EAAcD,EACdE,EAAQ,EACZ,KAAOF,GAAgB,CACrB,IAAIG,EAAWC,GAAaJ,EAAgBvF,EAASO,CAAG,EACpDmF,EAAWD,IACCD,EAAAD,EACNE,EAAAC,GAEVH,EAAiBA,EAAe,WAClC,CACO,OAAAC,CACT,CAEA,SAASG,GAAanB,EAAgBC,EAAgBlE,EAAU,CAC1D,OAAAgB,EAAYiD,EAAOC,CAAK,EACnB,GAAMC,EAAuBnE,EAAKiE,EAAOC,CAAK,EAEhD,CACT,CAEA,SAASnC,GAAWD,EAAmB9B,EAAU,CAC/CuB,EAA2BvB,EAAK8B,CAAQ,EACpC9B,EAAI,UAAU,kBAAkB8B,CAAQ,IAAM,KAElDA,EAAS,OAAO,EACZ9B,EAAA,UAAU,iBAAiB8B,CAAQ,EACzC,CAMA,SAASuD,GAAoBrF,EAAUsF,EAAY,CACjD,MAAO,CAACtF,EAAI,QAAQ,IAAIsF,CAAE,CAC5B,CAEA,SAASC,GAAevF,EAAUsF,EAAYE,EAAqB,CACjE,OAAOxF,EAAI,MAAM,IAAIwF,CAAU,GAAG,IAAIF,CAAE,GAAK,EAC/C,CAEA,SAAS/D,EAA2BvB,EAAUzG,EAAe,CAC3D,MAAMkM,EAAQzF,EAAI,MAAM,IAAIzG,CAAI,EAChC,GAAKkM,EACL,UAAWH,KAAMG,EACXzF,EAAA,QAAQ,IAAIsF,CAAE,CAEtB,CAEA,SAASnB,EAAuBnE,EAAUiE,EAAgBC,EAAgB,CACxE,MAAMwB,EAAY1F,EAAI,MAAM,IAAIiE,CAAK,EACrC,GAAI,CAACyB,EAAkB,MAAA,GAEvB,IAAIC,EAAa,EACjB,UAAWL,KAAMI,EAGXL,GAAoBrF,EAAKsF,CAAE,GAAKC,GAAevF,EAAKsF,EAAIpB,CAAK,GAC7D,EAAAyB,EAGC,OAAAA,CACT,CAUA,SAASC,GAAqBrM,EAAesM,EAAkC,CAC7E,MAAMC,EAAavM,EAAK,cAElBwM,EAAaxM,EAAK,iBAAiB,MAAM,EAC/C,UAAWyK,KAAO+B,EAAY,CAC5B,IAAIC,EAAUhC,EAGd,KAAOgC,IAAYF,GAAgBE,GAAS,CACtC,IAAAP,EAAQI,EAAM,IAAIG,CAAO,EAEzBP,GAAS,OACXA,MAAY,IACNI,EAAA,IAAIG,EAASP,CAAK,GAEpBA,EAAA,IAAIzB,EAAI,EAAE,EAChBgC,EAAUA,EAAQ,aACpB,CACF,CACF,CAYA,SAASjC,GAAYkC,EAAqBvG,EAAqB,CACvD,MAAAmG,MAAY,IAClB,OAAAD,GAAqBK,EAAYJ,CAAK,EACtCD,GAAqBlG,EAAYmG,CAAK,EAC/BA,CACT,CCltBA,MAAMK,GAAI,IAAI,UACRC,GAAwB,WACxBC,EAAkB,GAAGD,EAAqB,aAC1CE,EAAgB,GAAGF,EAAqB,WACxCG,GAAS,SACbC,GAAY,YACZC,GAAe,eACfC,GAAmB,mBACnBC,GAAW,WACXC,GAAO,OAEIC,GAAM,MACNC,GAAkB,IAAMC,EAAeF,EAAG,EAC1CG,GAAO,OACPC,GAAmB,IAAMF,EAAeC,EAAI,EAC5CE,GAAM,MACNC,GAAkB,IAAMJ,EAAeG,EAAG,EAC1CE,GAAQ,QACRC,GAAoB,IAAMN,EAAeK,EAAK,EAC9CE,GAAS,SACTC,GAAqB,IAAMR,EAAeO,EAAM,EAEhDE,GAA2B,IAAM,CAC5BV,KACCG,KACDE,KACEE,KACCE,IACrB,EAEA,IAAIE,GAAoB,GACxB,SAASV,EAAeW,EAAgB,CACtC,GAAI,CAACD,GAAmB,CAChB,MAAAE,EAAQ,SAAS,cAAc,OAAO,EAC5CA,EAAM,UAAY;AAAA,GACnBtB,CAAe;AAAA;AAAA;AAAA;AAAA,GAIfC,CAAa,KAAKD,CAAe;AAAA;AAAA;AAAA,GAGjCC,CAAa,IAAID,CAAe;AAAA;AAAA;AAAA,MAItB,SAAA,KAAK,YAAYsB,CAAK,EACXF,GAAA,EACtB,CAEmBjJ,GAAA,CACjB,KAAMkJ,EACN,YAAa,UAAUA,CAAM,qBAAqBA,CAAM,UACxD,GAAI,MAAOnL,GAAqBqL,GAAQF,EAAQnL,CAAI,CAAA,CACrD,CACH,CAEA,eAAeqL,GAAQF,EAAgBnL,EAAkB,CACvD,KAAM,CAAE,GAAIsL,EAAO,UAAAvP,CAAA,EAAciE,EAE3BuL,EAA8BxP,EAAU,UAAUoP,CAAM,EAC9D,GAAI,CAACI,EAAW,MAAM,IAAI,MAAM,iBAAiBJ,CAAM,EAAE,EAEnD,MAAA3P,EAAKoF,EAAmB0K,CAAK,EACnC,GAAI,CAAC9P,EAAU,MAAA,IAAI,MAAM,8CAA8C,EAEpEA,EAAA,UAAU,IAAIuO,CAAa,EAE9B,MAAMyB,EAAM,IAAI,IAAID,EAAU,MAAO,OAAO,SAAS,MAAM,EAErDE,EAAU,IAAI,QAKpB,GAHQA,EAAA,OAAOzB,GAAQC,EAAS,EACxBwB,EAAA,OAAOvB,GAAcC,EAAgB,EAEzCpO,GAAW,QACJ,QAAAgF,KAAQhF,EAAU,QAAS,CAC5B,MAAAwC,EAASxC,EAAU,QAAQgF,CAAI,EAC7B0K,EAAA,OAAO1K,EAAMxC,EAAO,KAAK,CACnC,CAGF,MAAMmN,EAAgB,KAAK,UAAU3P,EAAW,CAAC4P,EAAGnO,IAC9CA,aAAiBN,GACfM,EAAM,SAAiB,OACpBA,EAAM,MAERA,CACR,EACKoO,EAAmB,CAAE,OAAAT,EAAQ,QAAAM,GACnC,GAAIN,IAAWb,GAAK,CAClB,MAAMuB,EAAc,IAAI,gBAAgBL,EAAI,MAAM,EACtCK,EAAA,OAAO,YAAaH,CAAa,EACzCF,EAAA,OAASK,EAAY,UAAS,MAElCD,EAAI,KAAOF,EAGb,MAAM5I,EAAM,MAAM,MAAM0I,EAAKI,CAAG,EAChC,GAAI,CAAC9I,EAAI,GAAU,MAAA,IAAI,MAAM,8BAA8B,EACrD,MAAAgJ,EAAO,MAAMhJ,EAAI,OAEjBiJ,EAAM,CAAC,GAAGnC,GAAE,gBAAgBkC,EAAM7B,EAAS,EAAE,KAAK,QAAQ,EAChE,QAASxM,EAAI,EAAGA,EAAIsO,EAAI,OAAQtO,IAAK,CAC7B,MAAAuO,EAAOD,EAAItO,CAAC,EACd,GAAA,EAAEuO,aAAgB,SACd,MAAA,IAAI,MAAM,gBAAgB,EAE5B,MAAAC,EAAcrL,EAAmBoL,CAAI,EAErChD,EAAKgD,EAAK,aAAa,IAAI,EAC3BE,EAAYzO,IAAM,EAClB0O,EAAQ,CAAC,CAACnD,GAAI,OACdoD,EAAgBF,GAAa,CAACC,EAEhC,IAAAE,EACJ,GAAID,EACFC,EAAU,CAACf,CAAK,MACX,CACL,GAAI,CAACa,EAAa,MAAA,IAAI,MAAM,OAAO,EAEnC,MAAMG,EAAiBL,GAAa,UAAU7B,EAAQ,GAAK,IAAIpB,CAAE,GACjEqD,EAAU,SAAS,iBAAiBC,CAAc,GAAK,CAAA,CACzD,CACI,GAAA,CAAGD,EAAe,MAAA,IAAI,MAAM,mBAAmB,EAEnD,UAAWE,KAAUF,EAEnB,OADcJ,GAAa,UAAU5B,EAAI,GAAK,QAC/B,CACb,IAAK,QACHnH,GAAUqJ,EAAQP,CAAI,EACtB,MACF,IAAK,QACHO,EAAO,UAAYP,EAAK,UACxB,MACF,IAAK,QACHO,EAAO,UAAYP,EAAK,UACxB,MACF,IAAK,UACIO,EAAA,QAAQP,EAAK,SAAS,EAC7B,MACF,IAAK,SACIO,EAAA,OAAOP,EAAK,SAAS,EAC5B,MACF,IAAK,SACHO,EAAO,OAAOP,CAAI,EAClB,MACF,IAAK,QACHO,EAAO,MAAMP,CAAI,EACjB,MACF,IAAK,SACHO,EAAO,OAAO,EACd,MACF,QACQ,MAAA,IAAI,MAAM,oBAAoB,CACxC,CAEJ,CAEG/Q,EAAA,UAAU,OAAOuO,CAAa,CACnC,CCjKO,MAAMyC,GAAQ,QACfC,GAAe,CAAC,SAAU,QAAS,SAAS,EAC3C,SAASC,IAAwB,CACtC5M,EAAiB0M,GAAO,CACtB,YAAa,CAAC,QAAS,WAAY,QAAQ,EAC3C,mBAAoB,CAAC5J,CAAM,EAE3B,eAAgB,CAAC,CAAE,KAAA7B,EAAM,GAAAvF,EAAI,WAAA+F,EAAY,UAAAxF,EAAW,WAAY,CAAE,OAAA2C,EAAQ,UAAAP,CAAU,KAAQ,CACpF,MAAAI,EAASxC,EAAU,QAAQwF,CAAU,EAC3C,GAAI,CAAChD,EACH,MAAM,IAAI,MAAM,UAAUgD,CAAU,YAAY,EAGlD,GAAI,EAAE,UAAW/F,GAAW,MAAA,IAAI,MAAM,oCAAoC,EAC1EA,EAAG,MAAQ+C,EAAO,MAElB,MAAMoO,EAAS,IAAM,CACnB,MAAMjD,EAAUnL,EAAO,MACnB,GAAA,OAAOmL,GAAY,SACdnL,EAAA,MAAQ,OAAO/C,EAAG,KAAK,UACrB,OAAOkO,GAAY,SAC5BnL,EAAO,MAAQ/C,EAAG,cACT,OAAOkO,GAAY,UACrBnL,EAAA,MAAQ,EAAQ/C,EAAG,UAEpB,OAAA,IAAI,MAAM,kBAAkB,CACpC,EAGK,MAAA,CACL,MAAO,CACL,CAAC,GAAGuF,CAAI,IAAIwB,IAAU,EAAE,EAAG7D,EAAO,IAAM,CACtClD,EAAG,MAAQ+C,EAAO,MAElB,UAAWqO,KAASH,GACfjR,EAAA,iBAAiBoR,EAAOD,CAAM,EAGnCxO,EAAU,IAAM,CACd,UAAWyO,KAASH,GACfjR,EAAA,oBAAoBoR,EAAOD,CAAM,CACtC,CACD,CAAA,CACF,CACH,CAAA,CAEJ,CAAA,CACD,CACH,CChDa,MAAAE,GAAK,KAEZC,GAAO,OACXC,GAAW,WACXC,GAAW,WACXC,GAAU,UAEL,SAASC,IAAqB,CACnCpN,EAAiB+M,GAAI,CACnB,mBAAoB,CAACjK,CAAM,EAC3B,iBAAkB,CAACkK,GAAMC,GAAUC,GAAUC,EAAO,EACpD,eAAgB,CAAC,CACf,GAAAzR,EACA,KAAAuF,EACA,OAAAoM,EACA,QAAAC,EACA,WAAA7L,EACA,UAAAxF,EACA,WAAY,CAAE,SAAA0C,EAAU,OAAAC,EAAQ,UAAAP,CAAU,EAC1C,QAAAnC,CAAA,IACI,CACE,MAAA6G,EAAWlH,EAAkB4F,CAAU,EAEvC8L,EAAUF,EAAOL,EAAI,EACrBQ,EAAcF,EAAQL,EAAQ,EAC9BQ,EAAcH,EAAQJ,EAAQ,EAC9BQ,EAAaL,EAAOF,EAAO,EAEjC,GAAIlM,IAAS,OAAQ,CACV,SAAA,iBAAiB,mBAAoB,IAAM8B,EAASrH,EAAIO,EAAWC,CAAO,EAAG,EAAI,EAC1F,MACF,CAEA,MAAMC,EAAK,IAAM4G,EAASrH,EAAIO,EAAWC,CAAO,EAChD,IAAIyR,EAA8BxR,EAC9BR,EAEJ,GAAI4R,EACFI,EAAoB,IAAM,CACrBxR,IACCR,GACCD,EAAA,oBAAoBuF,EAAMtF,CAAQ,CACvC,UAES6R,EAAa,CAClB,KAAA,CAACI,CAAe,EAAIJ,EAAY,KAChCK,EAAeD,EAAkB,OAAOA,CAAe,EAAI,IAEjE,IAAIE,EAAO,EACL,MAAAC,EAAcpP,EAAS,IAAM,CAC3B,MAAAqP,GAAM,KAAK,MAEjB,GADcA,GAAMF,GACPD,EACJ,OAAAC,EAAAE,GACA7R,EAAG,CACZ,CACD,EAEDwR,EAAoB,IAAMI,EAAY,KAAA,SAC3BN,EAAa,CAClB,KAAA,CAACQ,CAAe,EAAIR,EAAY,KAChCS,EAAeD,EAAkB,OAAOA,CAAe,EAAI,IAE7D,IAAAE,EACE,MAAAC,EAAczP,EAAS,IAAM,CAC7B+O,GAAc,CAACS,GACdhS,IAEL,aAAagS,CAAO,EACpBA,EAAU,WAAW,IAAM,CACrBT,EAAsBS,EAAA,OAClBhS,KACP+R,CAAY,CAAA,CAChB,EAEDP,EAAoB,IAAMS,EAAY,KACxC,CAEA,OAAAzS,EAAW,IAAMgS,IAEdjS,EAAA,iBAAiBuF,EAAMtF,CAAQ,EAEa,CAC7C,GAAI,CACF,CAACsF,CAAI,EAAGrC,EAAO,IAAM,CACnBP,EAAU,IAAM,CACVkP,GAED7R,EAAA,oBAAoBuF,EAAMtF,CAAQ,CAAA,CACtC,CAAA,CACF,CACH,CAAA,CAIJ,CAAA,CACD,CACH,CCjGa,MAAA0S,GAAM,MACZ,SAASC,IAAsB,CACpCtO,EAAiBqO,GAAK,CACpB,mBAAoB,CAACvL,CAAM,EAC3B,sBAAuB,CACrB,CACE,KAAM,MACN,YAAa,sCACb,OAAQ,IAAI,OAAO,+CAA+C,EAClE,SAAU,CAAC,CAAE,IAAAyL,CAAI,IAAM,aAAaA,CAAG,QACzC,CACF,EACA,eAAgB,CAAC,CAAE,GAAA7S,EAAI,KAAAuF,EAAM,WAAY,CAAE,OAAAxC,CAAO,MACD,CAC7C,KAAM,CACJ,CAACwC,CAAI,EAAGxC,EAAO/C,CAAE,CACnB,CAAA,EAGJ,CACD,CACH,CCrBA,MAAM8S,GAAY,YAChBC,GAAU,UACVC,GAAO,OAEIC,GAAO,OACb,SAASC,IAAuB,CACrC5O,EAAiB2O,GAAM,CACrB,mBAAoB,CAAC7L,CAAM,EAC3B,iBAAkB,CAAC0L,EAAS,EAC5B,eAAgB,CAAC,CAAE,GAAA9S,EAAI,KAAAuF,EAAM,UAAAhF,EAAW,WAAAwF,EAAY,OAAA4L,EAAQ,WAAY,CAAE,OAAAzO,CAAO,EAAG,QAAA1C,KAAc,CAC1F,MAAA6G,EAAWlH,EAAkB4F,CAAU,EAE7C,GAAI,EAAE/F,aAAc,aAAeA,aAAc,YACzC,MAAA,IAAI,MAAM,oCAAoC,EAIhD,MAAAmT,EADcxB,EAAOmB,EAAS,EACLA,GAAY,OAmBpC,MAjBwC,CAC7C,KAAM,CACJ,CAACvN,CAAI,EAAGrC,EAAO,IAAM,CACA,CAAC,CAACmE,EAASrH,EAAIO,EAAWC,CAAO,EAE9CR,EAAG,MAAM,SAAW,GAAKA,EAAG,MAAM,UAAYgT,GAC7ChT,EAAA,MAAM,eAAe+S,EAAO,EAE/B/S,EAAG,MAAM,YAAY+S,GAAS,GAAII,CAAQ,EAG5CnT,EAAG,MAAM,YAAY+S,GAASC,GAAMG,CAAQ,CAC9C,CACD,CACH,CAAA,CAIJ,CAAA,CACD,CACH,CCtCa,MAAA/L,EAAS,SAEhBgM,GAAc,UACb,SAASC,IAAyB,CACvC/O,EAAiB8C,EAAQ,CACvB,mBAAoB,CAACR,CAAM,EAC3B,sBAAuB,CACrB,CACE,KAAM,SACN,YAAa,oDACb,OAAQ,IAAI,OAAO,kDAAkD,EACrE,SAAU,CAAC,CAAE,OAAA7D,KAAa,aAAaqE,CAAM,KAAKrE,CAAM,QAC1D,CACF,EACA,iBAAkB,CAACqQ,EAAW,EAC9B,eAAgB,CAAC,CAAE,KAAA7N,EAAM,GAAAvF,EAAI,WAAA+F,EAAY,WAAAuN,EAAY,OAAA3B,EAAQ,QAAAnR,KAAc,CACnE,MAAAuC,EAASuQ,EAAW,OAAOhT,GAAaN,EAAI,GAAIQ,EAASuF,CAAU,CAAC,EAEtE,GAAA4L,EAAOyB,EAAW,EAAG,CACjB,MAAApR,EAAQ,aAAa,QAAQuD,CAAI,EACvC,GAAIvD,EAAO,CACH,MAAAuR,EAAc,KAAK,MAAMvR,CAAK,EACpCe,EAAO,MAAQwQ,CACjB,CAEAD,EAAW,OAAO,IAAM,CACtB,MAAMtR,EAAQ,KAAK,UAAUe,EAAO,KAAK,EAC5B,aAAA,QAAQwC,EAAMvD,CAAK,CAAA,CACjC,CACH,CAEO,MAAA,CACL,QAAS,CACP,CAACuD,CAAI,EAAGxC,CACV,CAAA,CAEJ,CAAA,CACD,CACH,CCvCA,MAAMyQ,GAAU,UACdC,GAAS,SACTC,GAAkB,+DAEPC,GAAW,WACjB,SAASC,IAA2B,CACzCtP,EAAiBqP,GAAU,CACzB,mBAAoB,CAACvM,CAAM,EAC3B,iBAAkB,CAACoM,GAASC,EAAM,EAClC,eAAgB,CAAC,CAAE,KAAAlO,EAAM,GAAAvF,EAAI,WAAA+F,EAAY,UAAAxF,EAAW,WAAY,CAAE,OAAA2C,CAAA,EAAU,OAAAyO,EAAQ,QAAAnR,KAAc,CAC5F,GAAA,EAAER,aAAc,qBACZ,MAAA,IAAI,MAAM,4BAA4B,EAGxC,MAAAqH,EAAWlH,EAAkB4F,CAAU,EA6BtC,MA3BwC,CAC7C,KAAM,CACJ,CAACR,CAAI,EAAGrC,EAAO,IAAM,CACnB,MAAMoE,EAAMD,EAASrH,EAAIO,EAAWC,CAAO,EAC3C,GAAI,OAAO8G,GAAQ,SAAgB,MAAA,IAAI,MAAM,2BAA2B,EAClE,MAAAyJ,EAAS,SAAS,cAAczJ,CAAG,EACzC,GAAI,CAACyJ,EAAQ,MAAM,IAAI,MAAM,6BAA6BzJ,CAAG,EAAE,EAE/D,GAAI,CAACtH,EAAG,QAAe,MAAA,IAAI,MAAM,oCAAoC,EACrE,MAAM6T,EAAI7T,EAAG,QAAQ,UAAU,EAAI,EAEnC,GADYoF,EAAmByO,CAAY,GAClC,kBAAyB,MAAA,IAAI,MAAM,gBAAgB,EAExD,GAAAlC,EAAO6B,EAAO,EAAG,CACnB,GAAI,CAACzC,EAAO,WAAkB,MAAA,IAAI,MAAM2C,EAAe,EAChD3C,EAAA,WAAW,aAAa8C,EAAG9C,CAAM,CAAA,SAC/BY,EAAO8B,EAAM,EAAG,CACzB,GAAI,CAAC1C,EAAO,WAAkB,MAAA,IAAI,MAAM2C,EAAe,EACvD3C,EAAO,WAAW,aAAa8C,EAAG9C,EAAO,WAAW,CAAA,MAEpDA,EAAO,YAAY8C,CAAC,EAEtB9C,EAAO,YAAY8C,CAAC,CAAA,CACrB,CACH,CAAA,CAIJ,CAAA,CACD,CACH,CC9Ca,MAAAC,GAAO,OACb,SAASC,IAAuB,CACrCzP,EAAiBwP,GAAM,CACrB,eAAgB,CAAC,CAAE,KAAAvO,EAAM,GAAAvF,EAAI,WAAA+F,EAAY,UAAAxF,EAAW,QAAAC,EAAS,WAAY,CAAE,OAAA0C,CAAO,KAAQ,CAClF,MAAAmE,EAAWlH,EAAkB4F,CAAU,EAYtC,MAVwC,CAC7C,KAAM,CACJ,CAACR,CAAI,EAAGrC,EAAO,IAAM,CACnB,GAAI,CAAC3C,GAAW,QAAS,OACzB,MAAM+G,EAAMD,EAASrH,EAAIO,EAAWC,CAAO,EACxCR,EAAA,YAAc,GAAGsH,CAAG,EAAA,CACxB,CACH,CAAA,CAIJ,CAAA,CACD,CACH,CCnBA,MAAM0M,GAAO,OACXC,GAAO,OACPC,GAAO,OAEIC,GAAa,aACnB,SAASC,IAAyB,CACvC9P,EAAiB6P,GAAY,CAC3B,mBAAoB,CAAC/M,CAAM,EAC3B,iBAAkB,CAAC4M,GAAMC,GAAMC,EAAI,EACnC,eAAgB,CAAC,CAAE,KAAA3O,EAAM,GAAAvF,EAAI,WAAA+F,EAAY,UAAAxF,EAAW,QAAAC,EAAS,OAAAmR,EAAQ,WAAY,CAAE,OAAAzO,EAAQ,UAAAP,MAAkB,CACrG,MAAA0E,EAAWlH,EAAkB4F,CAAU,EACvCtF,EAAK,IAAM4G,EAASrH,EAAIO,EAAWC,CAAO,EAE1C6T,EAAU,CAAE,UAAW,GACzB1C,EAAOsC,EAAI,EAAGI,EAAQ,UAAY,EAC7B1C,EAAOuC,EAAI,IAAGG,EAAQ,UAAY,IAE3C,MAAM5R,EAAW,IAAI,qBAAsB6R,GAAY,CAC7CA,EAAA,QAASC,GAAU,CACrBA,EAAM,iBACL9T,IAECkR,EAAOqC,EAAI,GACbvR,EAAS,WAAW,EAExB,CACD,GACA4R,CAAO,EAcH,MAZwC,CAC7C,GAAI,CACF,CAAC9O,CAAI,EAAGrC,EAAO,IAAM,CACnBT,EAAS,QAAQzC,CAAE,EAEnB2C,EAAU,IAAM,CACdF,EAAS,WAAW,CAAA,CACrB,CAAA,CACF,CACH,CAAA,CAIJ,CAAA,CACD,CACH,CCxBO,SAAS+R,IAA2B,CAClBxN,KACAqM,KACFlM,KACC+J,KACA1J,KACGiI,KACNiC,KACCkB,KACCM,KACIU,KACJG,IACvB,CCtBO,SAASU,GAAgBC,EAAyB,CACvD,QAAQ,KAAK,2EAA2E,EAElF,MAAAC,EAAY,MAAO3E,EAAwB4E,IAA0C,CACzF,MAAMxE,EAAM,IAAI,QAAQJ,EAAK4E,CAAI,EAEjC,GAAI,EAAE5E,aAAe,KAAY,MAAA,IAAI,MAAM,mBAAmB,EAExD,MAAA6E,EAAaH,EAAO1E,EAAI,QAAQ,EACtC,GAAI,CAAC6E,EAAY,MAAM,IAAI,MAAM,2BAA2BzE,EAAI,GAAG,EAAE,EAE/D,MAAA0E,EAAWD,EAAWzE,EAAI,MAAM,EACtC,GAAI,CAAC0E,EAAgB,MAAA,IAAI,MAAM,2BAA2B1E,EAAI,MAAM,IAAIA,EAAI,GAAG,EAAE,EAE7E,GAAA,CAAE,KAAAE,EAAM,OAAAyE,EAAQ,WAAAC,EAAY,QAAA/E,GAAY,MAAM6E,EAAS1E,CAAG,EAC9D,OAAKH,IAASA,EAAU,IAAI,SACvBA,EAAQ,IAAI,cAAc,GAAWA,EAAA,OAAO,eAAgB,WAAW,EAC5E8E,EAASA,GAAU,IACnBC,EAAaA,GAAc,KAEf,IAAI,SAAS1E,EAAM,CAAE,OAAAyE,EAAQ,WAAAC,EAAY,QAAA/E,EAAS,CACvD,EAGT,OAAO,MAAQ0E,CACjB"}