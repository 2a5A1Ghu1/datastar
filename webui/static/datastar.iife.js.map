{"version":3,"file":"datastar.iife.js","sources":["../node_modules/.pnpm/@maverick-js+signals@5.11.4/node_modules/@maverick-js/signals/dist/prod/symbols.js","../node_modules/.pnpm/@maverick-js+signals@5.11.4/node_modules/@maverick-js/signals/dist/prod/core.js","../node_modules/.pnpm/@maverick-js+signals@5.11.4/node_modules/@maverick-js/signals/dist/prod/signals.js","../src/lib/dom.ts","../src/lib/types.ts","../src/lib/core.ts","../src/lib/plugins/actions.ts","../src/lib/external/idiomorph.ts","../src/lib/plugins/reactivity.ts","../src/lib/plugins/shared.ts","../src/lib/plugins/backend.ts","../src/lib/plugins/binding.ts","../src/lib/plugins/visibility.ts","../src/lib/index.ts"],"sourcesContent":["const SCOPE = Symbol(0);\n\nexport { SCOPE };\n","import { SCOPE } from './symbols.js';\n\nlet scheduledEffects = false, runningEffects = false, currentScope = null, currentObserver = null, currentObservers = null, currentObserversIndex = 0, effects = [], defaultContext = {};\nconst NOOP = () => {\n}, STATE_CLEAN = 0, STATE_CHECK = 1, STATE_DIRTY = 2, STATE_DISPOSED = 3;\nfunction flushEffects() {\n  scheduledEffects = true;\n  queueMicrotask(runEffects);\n}\nfunction runEffects() {\n  if (!effects.length) {\n    scheduledEffects = false;\n    return;\n  }\n  runningEffects = true;\n  for (let i = 0; i < effects.length; i++) {\n    if (effects[i].$st !== STATE_CLEAN)\n      runTop(effects[i]);\n  }\n  effects = [];\n  scheduledEffects = false;\n  runningEffects = false;\n}\nfunction runTop(node) {\n  let ancestors = [node];\n  while (node = node[SCOPE]) {\n    if (node.$e && node.$st !== STATE_CLEAN)\n      ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    updateCheck(ancestors[i]);\n  }\n}\nfunction root(init) {\n  const scope = createScope();\n  return compute(scope, !init.length ? init : init.bind(null, dispose.bind(scope)), null);\n}\nfunction peek(fn) {\n  return compute(currentScope, fn, null);\n}\nfunction untrack(fn) {\n  return compute(null, fn, null);\n}\nfunction tick() {\n  if (!runningEffects)\n    runEffects();\n}\nfunction getScope() {\n  return currentScope;\n}\nfunction scoped(run, scope) {\n  try {\n    return compute(scope, run, null);\n  } catch (error) {\n    handleError(scope, error);\n    return;\n  }\n}\nfunction getContext(key, scope = currentScope) {\n  return scope?.$cx[key];\n}\nfunction setContext(key, value, scope = currentScope) {\n  if (scope)\n    scope.$cx = { ...scope.$cx, [key]: value };\n}\nfunction onError(handler) {\n  if (!currentScope)\n    return;\n  currentScope.$eh = currentScope.$eh ? [handler, ...currentScope.$eh] : [handler];\n}\nfunction onDispose(disposable) {\n  if (!disposable || !currentScope)\n    return disposable || NOOP;\n  const node = currentScope;\n  if (!node.$d) {\n    node.$d = disposable;\n  } else if (Array.isArray(node.$d)) {\n    node.$d.push(disposable);\n  } else {\n    node.$d = [node.$d, disposable];\n  }\n  return function removeDispose() {\n    if (node.$st === STATE_DISPOSED)\n      return;\n    disposable.call(null);\n    if (isFunction(node.$d)) {\n      node.$d = null;\n    } else if (Array.isArray(node.$d)) {\n      node.$d.splice(node.$d.indexOf(disposable), 1);\n    }\n  };\n}\nfunction dispose(self = true) {\n  if (this.$st === STATE_DISPOSED)\n    return;\n  let head = self ? this.$ps || this[SCOPE] : this, current = this.$ns, next = null;\n  while (current && current[SCOPE] === this) {\n    dispose.call(current, true);\n    disposeNode(current);\n    next = current.$ns;\n    current.$ns = null;\n    current = next;\n  }\n  if (self)\n    disposeNode(this);\n  if (current)\n    current.$ps = !self ? this : this.$ps;\n  if (head)\n    head.$ns = current;\n}\nfunction disposeNode(node) {\n  node.$st = STATE_DISPOSED;\n  if (node.$d)\n    emptyDisposal(node);\n  if (node.$s)\n    removeSourceObservers(node, 0);\n  if (node.$ps)\n    node.$ps.$ns = null;\n  node[SCOPE] = null;\n  node.$s = null;\n  node.$o = null;\n  node.$ps = null;\n  node.$cx = defaultContext;\n  node.$eh = null;\n}\nfunction emptyDisposal(scope) {\n  try {\n    if (Array.isArray(scope.$d)) {\n      for (let i = scope.$d.length - 1; i >= 0; i--) {\n        const callable = scope.$d[i];\n        callable.call(callable);\n      }\n    } else {\n      scope.$d.call(scope.$d);\n    }\n    scope.$d = null;\n  } catch (error) {\n    handleError(scope, error);\n  }\n}\nfunction compute(scope, compute2, observer) {\n  const prevScope = currentScope, prevObserver = currentObserver;\n  currentScope = scope;\n  currentObserver = observer;\n  try {\n    return compute2.call(scope);\n  } finally {\n    currentScope = prevScope;\n    currentObserver = prevObserver;\n  }\n}\nfunction handleError(scope, error) {\n  if (!scope || !scope.$eh)\n    throw error;\n  let i = 0, len = scope.$eh.length, coercedError = coerceError(error);\n  for (i = 0; i < len; i++) {\n    try {\n      scope.$eh[i](coercedError);\n      break;\n    } catch (error2) {\n      coercedError = coerceError(error2);\n    }\n  }\n  if (i === len)\n    throw coercedError;\n}\nfunction coerceError(error) {\n  return error instanceof Error ? error : Error(JSON.stringify(error));\n}\nfunction read() {\n  if (this.$st === STATE_DISPOSED)\n    return this.$v;\n  if (currentObserver && !this.$e) {\n    if (!currentObservers && currentObserver.$s && currentObserver.$s[currentObserversIndex] == this) {\n      currentObserversIndex++;\n    } else if (!currentObservers)\n      currentObservers = [this];\n    else\n      currentObservers.push(this);\n  }\n  if (this.$c)\n    updateCheck(this);\n  return this.$v;\n}\nfunction write(newValue) {\n  const value = isFunction(newValue) ? newValue(this.$v) : newValue;\n  if (this.$ch(this.$v, value)) {\n    this.$v = value;\n    if (this.$o) {\n      for (let i = 0; i < this.$o.length; i++) {\n        notify(this.$o[i], STATE_DIRTY);\n      }\n    }\n  }\n  return this.$v;\n}\nconst ScopeNode = function Scope() {\n  this[SCOPE] = null;\n  this.$ns = null;\n  this.$ps = null;\n  if (currentScope)\n    currentScope.append(this);\n};\nconst ScopeProto = ScopeNode.prototype;\nScopeProto.$cx = defaultContext;\nScopeProto.$eh = null;\nScopeProto.$c = null;\nScopeProto.$d = null;\nScopeProto.append = function(child) {\n  child[SCOPE] = this;\n  child.$ps = this;\n  if (this.$ns) {\n    if (child.$ns) {\n      let tail = child.$ns;\n      while (tail.$ns)\n        tail = tail.$ns;\n      tail.$ns = this.$ns;\n      this.$ns.$ps = tail;\n    } else {\n      child.$ns = this.$ns;\n      this.$ns.$ps = child;\n    }\n  }\n  this.$ns = child;\n  child.$cx = child.$cx === defaultContext ? this.$cx : { ...this.$cx, ...child.$cx };\n  if (this.$eh) {\n    child.$eh = !child.$eh ? this.$eh : [...child.$eh, ...this.$eh];\n  }\n};\nScopeProto.dispose = function() {\n  dispose.call(this);\n};\nfunction createScope() {\n  return new ScopeNode();\n}\nconst ComputeNode = function Computation(initialValue, compute2, options) {\n  ScopeNode.call(this);\n  this.$st = compute2 ? STATE_DIRTY : STATE_CLEAN;\n  this.$i = false;\n  this.$e = false;\n  this.$s = null;\n  this.$o = null;\n  this.$v = initialValue;\n  if (compute2)\n    this.$c = compute2;\n  if (options && options.dirty)\n    this.$ch = options.dirty;\n};\nconst ComputeProto = ComputeNode.prototype;\nObject.setPrototypeOf(ComputeProto, ScopeProto);\nComputeProto.$ch = isNotEqual;\nComputeProto.call = read;\nfunction createComputation(initialValue, compute2, options) {\n  return new ComputeNode(initialValue, compute2, options);\n}\nfunction isNotEqual(a, b) {\n  return a !== b;\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction updateCheck(node) {\n  if (node.$st === STATE_CHECK) {\n    for (let i = 0; i < node.$s.length; i++) {\n      updateCheck(node.$s[i]);\n      if (node.$st === STATE_DIRTY) {\n        break;\n      }\n    }\n  }\n  if (node.$st === STATE_DIRTY)\n    update(node);\n  else\n    node.$st = STATE_CLEAN;\n}\nfunction cleanup(node) {\n  if (node.$ns && node.$ns[SCOPE] === node)\n    dispose.call(node, false);\n  if (node.$d)\n    emptyDisposal(node);\n  node.$eh = node[SCOPE] ? node[SCOPE].$eh : null;\n}\nfunction update(node) {\n  let prevObservers = currentObservers, prevObserversIndex = currentObserversIndex;\n  currentObservers = null;\n  currentObserversIndex = 0;\n  try {\n    cleanup(node);\n    const result = compute(node, node.$c, node);\n    if (currentObservers) {\n      if (node.$s)\n        removeSourceObservers(node, currentObserversIndex);\n      if (node.$s && currentObserversIndex > 0) {\n        node.$s.length = currentObserversIndex + currentObservers.length;\n        for (let i = 0; i < currentObservers.length; i++) {\n          node.$s[currentObserversIndex + i] = currentObservers[i];\n        }\n      } else {\n        node.$s = currentObservers;\n      }\n      let source;\n      for (let i = currentObserversIndex; i < node.$s.length; i++) {\n        source = node.$s[i];\n        if (!source.$o)\n          source.$o = [node];\n        else\n          source.$o.push(node);\n      }\n    } else if (node.$s && currentObserversIndex < node.$s.length) {\n      removeSourceObservers(node, currentObserversIndex);\n      node.$s.length = currentObserversIndex;\n    }\n    if (!node.$e && node.$i) {\n      write.call(node, result);\n    } else {\n      node.$v = result;\n      node.$i = true;\n    }\n  } catch (error) {\n    handleError(node, error);\n    if (node.$st === STATE_DIRTY) {\n      cleanup(node);\n      if (node.$s)\n        removeSourceObservers(node, 0);\n    }\n    return;\n  }\n  currentObservers = prevObservers;\n  currentObserversIndex = prevObserversIndex;\n  node.$st = STATE_CLEAN;\n}\nfunction notify(node, state) {\n  if (node.$st >= state)\n    return;\n  if (node.$e && node.$st === STATE_CLEAN) {\n    effects.push(node);\n    if (!scheduledEffects)\n      flushEffects();\n  }\n  node.$st = state;\n  if (node.$o) {\n    for (let i = 0; i < node.$o.length; i++) {\n      notify(node.$o[i], STATE_CHECK);\n    }\n  }\n}\nfunction removeSourceObservers(node, index) {\n  let source, swap;\n  for (let i = index; i < node.$s.length; i++) {\n    source = node.$s[i];\n    if (source.$o) {\n      swap = source.$o.indexOf(node);\n      source.$o[swap] = source.$o[source.$o.length - 1];\n      source.$o.pop();\n    }\n  }\n}\n\nexport { compute, createComputation, createScope, dispose, getContext, getScope, isFunction, isNotEqual, onDispose, onError, peek, read, root, scoped, setContext, tick, untrack, update, write };\n","import { createComputation, read, write, isFunction, update, dispose, onDispose } from './core.js';\nimport { SCOPE } from './symbols.js';\n\nfunction signal(initialValue, options) {\n  const node = createComputation(initialValue, null, options), signal2 = read.bind(node);\n  signal2[SCOPE] = true;\n  signal2.set = write.bind(node);\n  return signal2;\n}\nfunction isReadSignal(fn) {\n  return isFunction(fn) && SCOPE in fn;\n}\nfunction computed(compute, options) {\n  const node = createComputation(\n    options?.initial,\n    compute,\n    options\n  ), signal2 = read.bind(node);\n  signal2[SCOPE] = true;\n  return signal2;\n}\nfunction effect(effect2, options) {\n  const signal2 = createComputation(\n    null,\n    function runEffect() {\n      let effectResult = effect2();\n      isFunction(effectResult) && onDispose(effectResult);\n      return null;\n    },\n    void 0\n  );\n  signal2.$e = true;\n  update(signal2);\n  return dispose.bind(signal2, true);\n}\nfunction readonly(signal2) {\n  const readonly2 = () => signal2();\n  readonly2[SCOPE] = true;\n  return readonly2;\n}\nfunction isWriteSignal(fn) {\n  return isReadSignal(fn) && \"set\" in fn;\n}\n\nexport { computed, effect, isReadSignal, isWriteSignal, readonly, signal };\n","import { AttributeContext, HTMLorSVGElement } from './types'\n\nexport function toHTMLorSVGElement(node: Node): HTMLorSVGElement | null {\n  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n    return null\n  }\n  return node\n}\n\nexport function walkDownDOM(el: Element | null, callback: (el: Element) => void) {\n  if (!el) return\n  callback(el)\n\n  el = el.firstElementChild\n\n  while (el) {\n    walkDownDOM(el, callback)\n    el = el.nextElementSibling\n  }\n}\n\nexport function functionGenerator(str: string): Function {\n  const fnContents = `return ${str}`\n  const fn = new Function('ctx', fnContents)\n  return fn\n}\n\nexport function functionEval(ctx: AttributeContext) {\n  const expression = ctx.expressionRaw\n  const fn = functionGenerator(expression)\n  try {\n    ctx.expressionEvaluated = fn(ctx)\n  } catch (e) {\n    console.error(`Error evaluating expression:\\n${expression}`)\n    throw e\n  }\n}\n","import { Dispose, MaybeDisposable, type Effect, type StopEffect } from '@maverick-js/signals'\n\nexport type HTMLorSVGElement = Element & (HTMLElement | SVGElement)\n\nexport type Context = {\n  get<T>(key: string): T | undefined\n  set<T>(key: string, value: T): void\n}\n\nexport abstract class DatastarPlugin {\n  abstract name: string\n  abstract description: string\n  requiredPluginTypes = new Set<typeof DatastarPlugin>()\n}\n\nexport type DatastarPluginConstructor = new () => DatastarPlugin\n\nexport type AttributeContext = Context & {\n  el: Readonly<HTMLorSVGElement>\n  key: Readonly<string>\n  expressionRaw: Readonly<string>\n  expressionEvaluated?: any\n  modifiers: Readonly<Map<string, Readonly<string>[]>>\n  effect: (\n    effect: Effect,\n    options?: {\n      id?: string\n    },\n  ) => StopEffect\n  cleanup: (disposable: MaybeDisposable) => Dispose\n}\n\nexport abstract class AttributePlugin extends DatastarPlugin {\n  abstract prefix: string\n  abstract onMount(ctx: AttributeContext): void\n  onUnmount?(ctx: AttributeContext): void\n  mustHaveEmptyExpression = false\n  mustHaveEmptyKey = false\n  allowedTags?: Set<string>\n  allowedModifiers?: Set<string>\n  allowedModifierArgs?: Record<string, (args: string[]) => boolean>\n}\n\nexport type Groups = Record<string, string>\n\nexport abstract class RunePlugin extends DatastarPlugin {\n  abstract regexp: RegExp\n  abstract replacer(groups: Groups): string\n}\n\nexport abstract class ActionPlugin extends DatastarPlugin {\n  abstract action(ctx: AttributeContext, ...args: any[]): Promise<void>\n}\n","import { effect, getContext, onDispose, root, setContext } from '@maverick-js/signals'\nimport { functionEval, toHTMLorSVGElement, walkDownDOM } from './dom'\nimport {\n  AttributeContext,\n  AttributePlugin,\n  DatastarPlugin,\n  DatastarPluginConstructor,\n  HTMLorSVGElement,\n  RunePlugin,\n} from './types'\n\nexport class Datastar {\n  attributePlugins: AttributePlugin[] = []\n  runePlugins: RunePlugin[] = []\n  attributeObserver: MutationObserver\n\n  constructor(...plugins: DatastarPluginConstructor[]) {\n    if (!plugins.length) throw new Error('No plugins provided')\n\n    this.attributeObserver = new MutationObserver((mutations) => {\n      for (const m of mutations) {\n        if (m.type === 'attributes') {\n          const el = toHTMLorSVGElement(m.target)\n          if (!el) return\n\n          // Old\n          this.handleAttributePlugin(el, (p, ctx) => {\n            p.onUnmount?.(ctx)\n            p.onMount(ctx)\n          })\n        } else {\n          m.removedNodes.forEach((node) => {\n            const el = toHTMLorSVGElement(node)\n            if (!el) return\n\n            this.handleAttributePlugin(el, (p, ctx) => {\n              p.onUnmount?.(ctx)\n            })\n          })\n        }\n      }\n    })\n\n    this.attributeObserver.observe(document.body, {\n      attributes: true,\n      attributeOldValue: true,\n      subtree: true,\n      childList: true,\n    })\n\n    const allPlugins: DatastarPlugin[] = []\n    for (const Plugin of plugins) {\n      const p = new Plugin()\n\n      p.requiredPluginTypes.forEach((requiredPluginType) => {\n        const requiredPlugin = allPlugins.find((plugin) => plugin instanceof requiredPluginType)\n        if (!requiredPlugin) {\n          throw new Error(`Plugin \"${p.name}\" requires plugin \"${requiredPluginType.name}\"`)\n        }\n\n        if (p instanceof AttributePlugin) {\n          if (p.allowedTags) {\n            p.allowedTags = new Set([...p.allowedTags].map((t) => t.toLowerCase()))\n          }\n          this.attributePlugins.push(p)\n        } else if (p instanceof RunePlugin) {\n          this.runePlugins.push(p)\n        } else {\n          throw new Error(`Unknown plugin type`)\n        }\n\n        allPlugins.push(p)\n      })\n    }\n  }\n\n  run() {\n    walkDownDOM(document.body, (element) => {\n      const el = toHTMLorSVGElement(element)\n      if (!el) return\n\n      let hasAttributePlugin = false\n      const reactiveRootDisposal = root((dispose) => {\n        this.handleAttributePlugin(el, (p, ctx) => {\n          p.onMount(ctx)\n          hasAttributePlugin = true\n        })\n\n        return dispose\n      })\n\n      if (!hasAttributePlugin) reactiveRootDisposal()\n    })\n  }\n\n  private handleAttributePlugin(el: HTMLorSVGElement, cb: (p: AttributePlugin, ctx: AttributeContext) => void) {\n    this.attributePlugins.forEach((p) => {\n      if (p.allowedTags) {\n        const elTagLower = el.tagName.toLowerCase()\n        if (!p.allowedTags.has(elTagLower)) return\n      }\n\n      const fullPrefix = `data-${p.prefix}`\n\n      for (const attr of el.attributes) {\n        if (!attr.name.startsWith(fullPrefix)) continue\n\n        let keyRaw = attr.name.slice(fullPrefix.length)\n        if (keyRaw.startsWith('-')) keyRaw = keyRaw.slice(1)\n\n        const [key, ...modifiersWithArgsArr] = keyRaw.split('.')\n\n        if (p.mustHaveEmptyKey && key.length > 0) {\n          throw new Error(`Attribute '${attr.name}' must have empty key`)\n        }\n\n        const modifiersArr = modifiersWithArgsArr.map((m) => {\n          const [label, ...args] = m.split('_')\n          return { label, args }\n        })\n        const expressionRaw = attr.value\n\n        if (p.mustHaveEmptyExpression && expressionRaw?.length > 0) {\n          throw new Error(`Attribute '${attr.name}' must have empty expression`)\n        }\n\n        if (p.allowedModifiers) {\n          for (const modifier of modifiersArr) {\n            if (!p.allowedModifiers.has(modifier.label)) {\n              throw new Error(`Modifier '${modifier.label}' is not allowed`)\n            }\n\n            if (p.allowedModifierArgs) {\n              const allowedArgs = p.allowedModifierArgs[modifier.label]\n              if (allowedArgs) {\n                if (!allowedArgs(modifier.args)) {\n                  throw new Error(`Modifier '${modifier.label}' arguments are not allowed`)\n                }\n              }\n            }\n          }\n        }\n\n        const modifiers = new Map<string, string[]>()\n        for (const modifier of modifiersArr) {\n          modifiers.set(modifier.label, modifier.args)\n        }\n\n        const ctx: AttributeContext = {\n          get(k: string) {\n            return getContext(k)\n          },\n          set(k, v) {\n            setContext(k, v)\n          },\n          el,\n          key,\n          expressionRaw,\n          modifiers,\n          effect,\n          cleanup: onDispose,\n        }\n\n        ctx.expressionEvaluated = functionEval(ctx)\n\n        cb(p, ctx)\n      }\n    })\n  }\n}\n","import { Groups, RunePlugin } from '../types'\n\nexport class ActionRunePlugin extends RunePlugin {\n  name = 'ActionRune'\n  description = 'A action rune'\n  regexp = new RegExp(/(?<whole>@(?<action>[a-zA-Z_$][0-9a-zA-Z_$]*)(?<call>\\((?<args>.*)\\))?)/g)\n  replacer({ action, args }: Groups) {\n    return `get('${action}')(ctx, ${args || ''})`\n  }\n}\n","const generatedByIdiomorphId = new WeakSet()\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function idiomorph(oldNode: Document | Element, newContent: string | Element, config = {}) {\n  if (oldNode instanceof Document) {\n    oldNode = oldNode.documentElement\n  }\n\n  let parsedContent: Element\n  if (typeof newContent === 'string') {\n    parsedContent = parseContent(newContent) as Element\n  } else {\n    parsedContent = newContent\n  }\n\n  const normalizedContent = normalizeContent(parsedContent)\n  const ctx = createMorphContext(oldNode, normalizedContent, config)\n\n  return morphNormalizedContent(oldNode, normalizedContent, ctx)\n}\n\nfunction morphNormalizedContent(oldNode: Element, normalizedNewContent: Element, ctx: any) {\n  if (ctx.head.block) {\n    const oldHead = oldNode.querySelector('head')\n    const newHead = normalizedNewContent.querySelector('head')\n    if (oldHead && newHead) {\n      const promises = handleHeadElement(newHead, oldHead, ctx)\n      // when head promises resolve, call morph again, ignoring the head tag\n      Promise.all(promises).then(() => {\n        morphNormalizedContent(\n          oldNode,\n          normalizedNewContent,\n          Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          }),\n        )\n      })\n      return\n    }\n  }\n\n  if (ctx.morphStyle === 'innerHTML') {\n    // innerHTML, so we are only updating the children\n    morphChildren(normalizedNewContent, oldNode, ctx)\n    return oldNode.children\n  } else if (ctx.morphStyle === 'outerHTML' || ctx.morphStyle == null) {\n    // otherwise find the best element match in the new content, morph that, and merge its siblings\n    // into either side of the best match\n    const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx)\n    if (!bestMatch) throw new Error('Could not find best match')\n\n    // stash the siblings that will need to be inserted on either side of the best match\n    const previousSibling = bestMatch?.previousSibling as Element\n    const nextSibling = bestMatch?.nextSibling as Element\n\n    // morph it\n    const morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx)\n\n    if (bestMatch) {\n      // if there was a best match, merge the siblings in too and return the\n      // whole bunch\n      return insertSiblings(previousSibling, morphedNode, nextSibling)\n    } else {\n      // otherwise nothing was added to the DOM\n      return []\n    }\n  } else {\n    throw 'Do not understand how to morph style ' + ctx.morphStyle\n  }\n}\n\n/**\n * @param oldNode root node to merge content into\n * @param newContent new content to merge\n * @param ctx the merge context\n * @returns {Element} the element that ended up in the DOM\n */\nfunction morphOldNodeTo(oldNode: Element, newContent: Element, ctx: any) {\n  if (ctx.ignoreActive && oldNode === document.activeElement) {\n    // don't morph focused element\n  } else if (newContent == null) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n\n    oldNode.remove()\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return\n  } else if (!isSoftMatch(oldNode, newContent)) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n    if (ctx.callbacks.beforeNodeAdded(newContent) === false) return\n\n    if (!oldNode.parentElement) throw new Error('oldNode has no parentElement')\n    oldNode.parentElement.replaceChild(newContent, oldNode)\n    ctx.callbacks.afterNodeAdded(newContent)\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return newContent\n  } else {\n    if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return\n\n    if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n      // ignore the head element\n    } else if (\n      newContent instanceof HTMLHeadElement &&\n      oldNode instanceof HTMLHeadElement &&\n      ctx.head.style !== 'morph'\n    ) {\n      handleHeadElement(newContent, oldNode, ctx)\n    } else {\n      syncNodeFrom(newContent, oldNode)\n      morphChildren(newContent, oldNode, ctx)\n    }\n    ctx.callbacks.afterNodeMorphed(oldNode, newContent)\n    return oldNode\n  }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n * @param {Element} newParent the parent element of the new content\n * @param {Element } oldParent the old content that we are merging the new content into\n * @param ctx the merge context\n */\nfunction morphChildren(newParent: Element, oldParent: Element, ctx: any) {\n  let nextNewChild = newParent.firstChild as Element | null\n  let insertionPoint = oldParent.firstChild as Element | null\n  let newChild\n\n  // run through all the new content\n  while (nextNewChild) {\n    newChild = nextNewChild\n    nextNewChild = newChild.nextSibling as Element | null\n\n    // if we are at the end of the exiting parent's children, just append\n    if (insertionPoint == null) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n      oldParent.appendChild(newChild)\n      ctx.callbacks.afterNodeAdded(newChild)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // if the current node has an id set match then morph\n    if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n      morphOldNodeTo(insertionPoint, newChild, ctx)\n      insertionPoint = insertionPoint.nextSibling as Element | null\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // otherwise search forward in the existing old children for an id set match\n    let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx)\n\n    // if we found a potential match, remove the nodes until that point and morph\n    if (idSetMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx)\n      morphOldNodeTo(idSetMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // no id set match found, so scan forward for a soft match for the current node\n    let softMatch = findSoftMatch(newParent, newChild, insertionPoint, ctx)\n\n    // if we found a soft match for the current node, morph\n    if (softMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx)\n      morphOldNodeTo(softMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // abandon all hope of morphing, just insert the new child before the insertion point\n    // and move on\n    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n    oldParent.insertBefore(newChild, insertionPoint)\n    ctx.callbacks.afterNodeAdded(newChild)\n    removeIdsFromConsideration(ctx, newChild)\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint !== null) {\n    let tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling as Element | null\n    removeNode(tempNode, ctx)\n  }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\n/**\n * syncs a given node with another node, copying over all attributes and\n * inner element state from the 'from' node to the 'to' node\n *\n * @param {Element} from the element to copy attributes & state from\n * @param {Element} to the element to copy attributes & state to\n */\nfunction syncNodeFrom(from: Element, to: Element) {\n  let type = from.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    for (const fromAttribute of from.attributes) {\n      const toAttribute = to.getAttribute(fromAttribute.name)\n      if (toAttribute !== fromAttribute.value) {\n        to.setAttribute(fromAttribute.name, fromAttribute.value)\n      }\n    }\n    for (const toAttribute of to.attributes) {\n      if (!from.hasAttribute(toAttribute.name)) {\n        to.removeAttribute(toAttribute.name)\n      }\n    }\n  }\n\n  // sync text nodes\n  if (type === Node.COMMENT_NODE || type === Node.TEXT_NODE) {\n    if (to.nodeValue !== from.nodeValue) {\n      to.nodeValue = from.nodeValue\n    }\n  }\n\n  // NB: many bothans died to bring us information:\n  //\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  // https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n\n  // sync input value\n  if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== 'file') {\n    to.value = from.value || ''\n    syncAttribute(from, to, 'value')\n\n    // sync boolean attributes\n    syncAttribute(from, to, 'checked')\n    syncAttribute(from, to, 'disabled')\n  } else if (from instanceof HTMLOptionElement) {\n    syncAttribute(from, to, 'selected')\n  } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n    const fromValue = from.value\n    const toValue = to.value\n    if (fromValue !== toValue) {\n      to.value = fromValue\n    }\n    if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n      to.firstChild.nodeValue = fromValue\n    }\n  }\n}\n\nfunction syncAttribute(from: Element, to: Element, attributeName: string) {\n  const fAttr = from.getAttribute(attributeName)\n  const tAttr = to.getAttribute(attributeName)\n\n  if (fAttr !== tAttr) {\n    if (fAttr) {\n      to.setAttribute(attributeName, fAttr)\n    } else {\n      to.removeAttribute(attributeName)\n    }\n  }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(newHeadTag: HTMLHeadElement, currentHead: HTMLHeadElement, ctx: any) {\n  const added = []\n  const removed = []\n  const preserved = []\n  const nodesToAppend = []\n\n  const headMergeStyle = ctx.head.style\n\n  // put all new head elements into a Map, by their outerHTML\n  const srcToNewHeadNodes = new Map()\n  for (const newHeadChild of newHeadTag.children) {\n    srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild)\n  }\n\n  // for each elt in the current head\n  for (const currentHeadElt of currentHead.children) {\n    // If the current head element is in the map\n    let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML)\n    let isReAppended = ctx.head.shouldReAppend(currentHeadElt)\n    let isPreserved = ctx.head.shouldPreserve(currentHeadElt)\n    if (inNewContent || isPreserved) {\n      if (isReAppended) {\n        // remove the current version and let the new version replace it and re-execute\n        removed.push(currentHeadElt)\n      } else {\n        // this element already exists and should not be re-appended, so remove it from\n        // the new content map, preserving it in the DOM\n        srcToNewHeadNodes.delete(currentHeadElt.outerHTML)\n        preserved.push(currentHeadElt)\n      }\n    } else {\n      if (headMergeStyle === 'append') {\n        // we are appending and this existing element is not new content\n        // so if and only if it is marked for re-append do we do anything\n        if (isReAppended) {\n          removed.push(currentHeadElt)\n          nodesToAppend.push(currentHeadElt)\n        }\n      } else {\n        // if this is a merge, we remove this content since it is not in the new head\n        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n          removed.push(currentHeadElt)\n        }\n      }\n    }\n  }\n\n  // Push the remaining new head elements in the Map into the\n  // nodes to append to the head tag\n  nodesToAppend.push(...srcToNewHeadNodes.values())\n  console.log('to append: ', nodesToAppend)\n\n  const promises = []\n  for (const newNode of nodesToAppend) {\n    console.log('adding: ', newNode)\n    const newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild as Element | null\n    if (!newElt) throw new Error('could not create new element from: ' + newNode.outerHTML)\n    console.log(newElt)\n    if (!!ctx.callbacks.beforeNodeAdded(newElt)) {\n      if (newElt.hasAttribute('href') || newElt.hasAttribute('src')) {\n        let resolver: (value: unknown) => void\n        const promise = new Promise((resolve) => {\n          resolver = resolve\n        })\n        newElt.addEventListener('load', function () {\n          resolver(undefined)\n        })\n        promises.push(promise)\n      }\n      currentHead.appendChild(newElt)\n      ctx.callbacks.afterNodeAdded(newElt)\n      added.push(newElt)\n    }\n  }\n\n  // remove all removed elements, after we have appended the new elements to avoid\n  // additional network requests for things like style sheets\n  for (const removedElement of removed) {\n    if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n      currentHead.removeChild(removedElement)\n      ctx.callbacks.afterNodeRemoved(removedElement)\n    }\n  }\n\n  ctx.head.afterHeadMorphed(currentHead, {\n    added: added,\n    kept: preserved,\n    removed: removed,\n  })\n  return promises\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\nfunction noOp() {}\n\nfunction createMorphContext(oldNode: Element, newContent: Element, config: any) {\n  return {\n    target: oldNode,\n    newContent: newContent,\n    config: config,\n    morphStyle: config.morphStyle,\n    ignoreActive: config.ignoreActive,\n    idMap: createIdMap(oldNode, newContent),\n    deadIds: new Set(),\n    callbacks: Object.assign(\n      {\n        beforeNodeAdded: noOp,\n        afterNodeAdded: noOp,\n        beforeNodeMorphed: noOp,\n        afterNodeMorphed: noOp,\n        beforeNodeRemoved: noOp,\n        afterNodeRemoved: noOp,\n      },\n      config.callbacks,\n    ),\n    head: Object.assign(\n      {\n        style: 'merge',\n        shouldPreserve: (elt: Element) => elt.getAttribute('im-preserve') === 'true',\n        shouldReAppend: (elt: Element) => elt.getAttribute('im-re-append') === 'true',\n        shouldRemove: noOp,\n        afterHeadMorphed: noOp,\n      },\n      config.head,\n    ),\n  }\n}\n\nfunction isIdSetMatch(node1: Element, node2: Element, ctx: any) {\n  if (!node1 || !node2) return false\n\n  if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n    if (node1?.id?.length && node1.id === node2.id) return true\n\n    return getIdIntersectionCount(ctx, node1, node2) > 0\n  }\n  return false\n}\n\nfunction isSoftMatch(node1: Element, node2: Element) {\n  if (!node1 || !node2) return false\n\n  return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n}\n\nfunction removeNodesBetween(startInclusive: Element, endExclusive: Element, ctx: any) {\n  while (startInclusive !== endExclusive) {\n    const tempNode = startInclusive\n    startInclusive = startInclusive?.nextSibling as Element\n    if (!tempNode) throw new Error('tempNode is null')\n    removeNode(tempNode, ctx)\n  }\n  removeIdsFromConsideration(ctx, endExclusive)\n  return endExclusive.nextSibling as Element | null\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(newContent: Element, oldParent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  // max id matches we are willing to discard in our search\n  const newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent)\n\n  let potentialMatch: Element | null = null\n\n  // only search forward if there is a possibility of an id match\n  if (newChildPotentialIdCount > 0) {\n    potentialMatch = insertionPoint\n    // if there is a possibility of an id match, scan forward\n    // keep track of the potential id match count we are discarding (the\n    // newChildPotentialIdCount must be greater than this to make it likely\n    // worth it)\n    let otherMatchCount = 0\n    while (potentialMatch != null) {\n      // If we have an id match, return the current potential match\n      if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n        return potentialMatch\n      }\n\n      // computer the other potential matches of this new content\n      otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent)\n      if (otherMatchCount > newChildPotentialIdCount) {\n        // if we have more potential id matches in _other_ content, we\n        // do not have a good candidate for an id match, so return null\n        return null\n      }\n\n      // advanced to the next old content child\n      potentialMatch = potentialMatch.nextSibling as Element | null\n    }\n  }\n  return potentialMatch\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(newContent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  let potentialSoftMatch = insertionPoint as Element | null\n  let nextSibling = newChild.nextSibling as Element | null\n\n  let siblingSoftMatchCount = 0\n\n  while (potentialSoftMatch && nextSibling) {\n    if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n      // the current potential soft match has a potential id set match with the remaining new\n      // content so bail out of looking\n      return null\n    }\n\n    // if we have a soft match with the current node, return it\n    if (isSoftMatch(newChild, potentialSoftMatch)) {\n      return potentialSoftMatch\n    }\n\n    if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n      // the next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling as Element | null\n\n      // If there are two future soft matches, bail to allow the siblings to soft match\n      // so that we don't consume future soft matches for the sake of the current node\n      if (siblingSoftMatchCount >= 2) {\n        return null\n      }\n    }\n\n    // advanced to the next old content child\n    potentialSoftMatch = potentialSoftMatch.nextSibling as Element | null\n  }\n\n  return potentialSoftMatch\n}\n\nconst parser = new DOMParser()\nfunction parseContent(newContent: string) {\n  // remove svgs to avoid false-positive matches on head, etc.\n  const contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '')\n\n  // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n  if (\n    contentWithSvgsRemoved.match(/<\\/html>/) ||\n    contentWithSvgsRemoved.match(/<\\/head>/) ||\n    contentWithSvgsRemoved.match(/<\\/body>/)\n  ) {\n    const content = parser.parseFromString(newContent, 'text/html')\n    // if it is a full HTML document, return the document itself as the parent container\n    if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n      generatedByIdiomorphId.add(content)\n      return content\n    } else {\n      // otherwise return the html element as the parent container\n      let Element = content.firstChild\n      if (Element) {\n        generatedByIdiomorphId.add(Element)\n        return Element as Element\n      } else {\n        return null\n      }\n    }\n  } else {\n    // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n    // deal with touchy tags like tr, tbody, etc.\n    const responseDoc = parser.parseFromString(`<body><template>${newContent}</template></body>`, 'text/html')\n    const content = responseDoc.body.querySelector('template')?.content\n    if (!content) throw new Error('content is null')\n    generatedByIdiomorphId.add(content)\n    return content\n  }\n}\n\nfunction normalizeContent(newContent: Element) {\n  if (newContent == null) {\n    // noinspection UnnecessaryLocalVariableJS\n    const dummyParent = document.createElement('div')\n    return dummyParent\n  } else if (generatedByIdiomorphId.has(newContent)) {\n    // the template tag created by idiomorph parsing can serve as a dummy parent\n    return newContent\n  } else if (newContent instanceof Node) {\n    // a single node is added as a child to a dummy parent\n    const dummyParent = document.createElement('div')\n    dummyParent.append(newContent)\n    return dummyParent\n  } else {\n    // all nodes in the array or Element collection are consolidated under\n    // a single dummy parent element\n    const dummyParent = document.createElement('div')\n    for (const elt of [...newContent]) {\n      dummyParent.append(elt)\n    }\n    return dummyParent\n  }\n}\n\nfunction insertSiblings(previousSibling?: Element, morphedNode?: Element, nextSibling?: Element) {\n  const stack = []\n  const added = []\n  while (previousSibling) {\n    stack.push(previousSibling)\n    previousSibling = previousSibling.previousSibling as Element\n  }\n  while (stack.length > 0) {\n    const node = stack.pop()!\n    added.push(node) // push added preceding siblings on in order and insert\n    morphedNode?.parentElement?.insertBefore(node, morphedNode)\n  }\n  added.push(morphedNode)\n  while (nextSibling) {\n    stack.push(nextSibling)\n    added.push(nextSibling) // here we are going in order, so push on as we scan, rather than add\n    nextSibling = nextSibling.nextSibling as Element\n  }\n  while (stack.length) {\n    morphedNode?.parentElement?.insertBefore(stack.pop()!, morphedNode.nextSibling)\n  }\n  return added\n}\n\nfunction findBestNodeMatch(newContent: Element, oldNode: Element, ctx: any) {\n  let currentElement = newContent.firstChild as Element | null\n  let bestElement = currentElement\n  let score = 0\n  while (currentElement) {\n    let newScore = scoreElement(currentElement, oldNode, ctx)\n    if (newScore > score) {\n      bestElement = currentElement\n      score = newScore\n    }\n    currentElement = currentElement.nextSibling as Element | null\n  }\n  return bestElement\n}\n\nfunction scoreElement(node1: Element, node2: Element, ctx: any) {\n  if (isSoftMatch(node1, node2)) {\n    return 0.5 + getIdIntersectionCount(ctx, node1, node2)\n  }\n  return 0\n}\n\nfunction removeNode(tempNode: Element, ctx: any) {\n  removeIdsFromConsideration(ctx, tempNode)\n  if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return\n\n  tempNode.remove()\n  ctx.callbacks.afterNodeRemoved(tempNode)\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: any, id: string) {\n  return !ctx.deadIds.has(id)\n}\n\nfunction idIsWithinNode(ctx: any, id: string, targetNode: Element) {\n  return ctx.idMap.get(targetNode)?.has(id) || false\n}\n\nfunction removeIdsFromConsideration(ctx: any, node: Element) {\n  const idSet = ctx.idMap.get(node)\n  if (!idSet) return\n  for (const id of idSet) {\n    ctx.deadIds.add(id)\n  }\n}\n\nfunction getIdIntersectionCount(ctx: any, node1: Element, node2: Element) {\n  const sourceSet = ctx.idMap.get(node1)\n  if (!sourceSet) return 0\n\n  let matchCount = 0\n  for (const id of sourceSet) {\n    // a potential match is an id in the source and potentialIdsSet, but\n    // that has not already been merged into the DOM\n    if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n      ++matchCount\n    }\n  }\n  return matchCount\n}\n\n/**\n * A bottom up algorithm that finds all elements with ids inside of the node\n * argument and populates id sets for those nodes and all their parents, generating\n * a set of ids contained within all nodes for the entire hierarchy in the DOM\n *\n * @param node {Element}\n * @param {Map<Node, Set<String>>} idMap\n */\nfunction populateIdMapForNode(node: Element, idMap: Map<Element, Set<string>>) {\n  const nodeParent = node.parentElement\n  // find all elements with an id property\n  const idElements = node.querySelectorAll('[id]')\n  for (const elt of idElements) {\n    let current = elt as Element | null\n    // walk up the parent hierarchy of that element, adding the id\n    // of element to the parent's id set\n    while (current !== nodeParent && !!current) {\n      let idSet = idMap.get(current)\n      // if the id set doesn't exist, create it and insert it in the  map\n      if (idSet == null) {\n        idSet = new Set()\n        idMap.set(current, idSet)\n      }\n      idSet.add(elt.id)\n      current = current.parentElement\n    }\n  }\n}\n\n/**\n * This function computes a map of nodes to all ids contained within that node (inclusive of the\n * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n * to contribute to a parent nodes matching.\n *\n * @param {Element} oldContent  the old content that will be morphed\n * @param {Element} newContent  the new content to morph to\n * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n */\nfunction createIdMap(oldContent: Element, newContent: Element) {\n  const idMap = new Map()\n  populateIdMapForNode(oldContent, idMap)\n  populateIdMapForNode(newContent, idMap)\n  return idMap\n}\n","import { computed, effect, signal, type ReadSignal, type WriteSignal } from '@maverick-js/signals'\nimport { AttributeContext, AttributePlugin, Groups, RunePlugin } from '../types'\n\nexport class ReactivityRunePlugin extends RunePlugin {\n  name = 'ReactivityRune'\n  description = 'A reactivity rune'\n  regexp = new RegExp(/(?<whole>\\$(?<signal>[a-zA-Z_$][0-9a-zA-Z_$]*))/g)\n  replacer(groups: Groups) {\n    const { signal } = groups\n    return `get(${signal}).value`\n  }\n}\n\nexport class Signal<T> {\n  private val: WriteSignal<T>\n  constructor(value: T) {\n    this.val = signal(value)\n  }\n\n  get value() {\n    return this.val()\n  }\n\n  set value(v: T) {\n    this.val.set(v)\n  }\n}\n\nexport class SignalAttributePlugin extends AttributePlugin {\n  name = 'Signal'\n  description = 'A signal attribute'\n  prefix = 'signal'\n\n  onMount({ key, set, expressionEvaluated }: AttributeContext) {\n    set(key, new Signal(expressionEvaluated))\n  }\n}\n\nexport class Computed<T> {\n  private val: ReadSignal<T>\n  constructor(value: () => T) {\n    this.val = computed(value)\n  }\n\n  get value() {\n    return this.val()\n  }\n}\n\nexport class ComputedAttributePlugin extends AttributePlugin {\n  name = 'Computed'\n  description = 'A computed attribute'\n  prefix = 'computed'\n\n  onMount({ key, set, expressionEvaluated }: AttributeContext) {\n    set(key, new Computed(expressionEvaluated))\n  }\n}\n\nexport class EffectAttributePlugin extends AttributePlugin {\n  name = 'Effect'\n  description = 'An effect attribute'\n  prefix = 'effect'\n\n  onMount({ key, set, expressionEvaluated }: AttributeContext) {\n    if (typeof expressionEvaluated !== 'function') {\n      throw new Error('Effect attribute must be a function')\n    }\n\n    set(key, effect(expressionEvaluated))\n  }\n}\n\nexport const reactivityPlugins = new Set([\n  ReactivityRunePlugin,\n  SignalAttributePlugin,\n  ComputedAttributePlugin,\n  EffectAttributePlugin,\n])\n","export const noArgs = (args: string[]) => args.length === 0\n","import { toHTMLorSVGElement } from '../dom'\nimport { idiomorph } from '../external/idiomorph'\nimport { ActionPlugin, AttributeContext, AttributePlugin, HTMLorSVGElement } from '../types'\n\nimport { Signal, reactivityPlugins } from './reactivity'\nimport { noArgs } from './shared'\n\nexport const SELECTOR = 'selector'\nexport const SWAP = 'swap'\nexport const REQ_HEADERS_CTX_KEY = 'reqHeaders'\n\nexport class FetchRequestHeadersPlugin extends AttributePlugin {\n  name = 'FetchRequestHeaders'\n  prefix = 'header'\n  description = 'Sets the headers of the fetch request'\n  mustHaveEmptyKey = true\n\n  onMount({ key, get, set, expressionEvaluated }: AttributeContext) {\n    let headers: Headers | undefined = get(REQ_HEADERS_CTX_KEY)\n\n    if (!headers) {\n      headers = new Headers()\n    }\n\n    headers.set(key, expressionEvaluated)\n    set(REQ_HEADERS_CTX_KEY, headers)\n  }\n}\n\nexport const GET = 'get'\nexport const POST = 'post'\nexport const PUT = 'put'\nexport const PATCH = 'patch'\nexport const DELETE = 'delete'\n\nconst DATASTAR_CLASS_PREFIX = 'datastar'\nconst INDICATOR_CLASS = `${DATASTAR_CLASS_PREFIX}-indicator`\nconst LOADING_CLASS = `${DATASTAR_CLASS_PREFIX}-request`\n\ntype Method = typeof GET | typeof POST | typeof PUT | typeof PATCH | typeof DELETE\n\nabstract class FetchAction extends ActionPlugin {\n  static hasInjectedStyles = false\n  name: string\n  description: string\n\n  constructor(public readonly method: Method) {\n    super()\n    this.name = `Fetch${method}`\n    this.description = `fetches fragments from the server using ${method}`\n    this.requiredPluginTypes = new Set([FetchRequestHeadersPlugin, ...reactivityPlugins])\n\n    if (!FetchAction.hasInjectedStyles) {\n      const style = document.createElement('style')\n      style.innerHTML = `\n.${INDICATOR_CLASS}{\n  opacity:0;\n  transition: opacity 500ms ease-in;\n}\n.${LOADING_CLASS} .${INDICATOR_CLASS}{\n    opacity:1\n}\n.${LOADING_CLASS}.${INDICATOR_CLASS}{\n    opacity:1\n}\n    `\n      document.head.appendChild(style)\n      FetchAction.hasInjectedStyles = true\n    }\n  }\n\n  async action(ctx: AttributeContext) {\n    await fetcher(this.method, ctx)\n  }\n}\n\nexport class FetchGetActionPlugin extends FetchAction {\n  constructor() {\n    super(GET)\n  }\n}\n\nexport class FetchPostActionPlugin extends FetchAction {\n  constructor() {\n    super(POST)\n  }\n}\n\nexport class FetchPutActionPlugin extends FetchAction {\n  constructor() {\n    super(PUT)\n  }\n}\n\nexport class FetchPatchActionPlugin extends FetchAction {\n  constructor() {\n    super(PATCH)\n  }\n}\n\nexport class FetchDeleteActionPlugin extends FetchAction {\n  constructor() {\n    super(DELETE)\n  }\n}\n\nexport class FetchAttributePlugin extends AttributePlugin {\n  name = 'Fetch'\n  prefix = 'fetch'\n  description = 'URL to fetch from'\n  allowedModifiers = new Set([GET, POST, PUT, PATCH, DELETE])\n  allowedModifierArgs = {\n    [GET]: noArgs,\n    [POST]: noArgs,\n    [PUT]: noArgs,\n    [PATCH]: noArgs,\n    [DELETE]: noArgs,\n  }\n  mustHaveEmptyKey = true\n\n  onMount({ expressionEvaluated, modifiers, set }: AttributeContext): void {\n    if (typeof expressionEvaluated !== 'string') throw new Error('expressionEvaluated must be a string')\n\n    if (modifiers.has(POST)) {\n      set(POST, expressionEvaluated)\n    } else if (modifiers.has(PUT)) {\n      set(PUT, expressionEvaluated)\n    } else if (modifiers.has(PATCH)) {\n      set(PATCH, expressionEvaluated)\n    } else if (modifiers.has(DELETE)) {\n      set(DELETE, expressionEvaluated)\n    } else {\n      set(GET, expressionEvaluated)\n    }\n  }\n\n  onUnmount({ set, modifiers }: AttributeContext): void {\n    if (modifiers.has(POST)) {\n      set(POST, undefined)\n    } else if (modifiers.has(PUT)) {\n      set(PUT, undefined)\n    } else if (modifiers.has(PATCH)) {\n      set(PATCH, undefined)\n    } else if (modifiers.has(DELETE)) {\n      set(DELETE, undefined)\n    } else {\n      set(GET, undefined)\n    }\n  }\n}\n\nexport class ServerSentEventsAttributePlugin extends AttributePlugin {\n  name = 'ServerSentEvents'\n  prefix = 'sse'\n  description = 'Sets the value of the element'\n  mustHaveEmptyKey = true\n  eventSources = new Map<HTMLorSVGElement, EventSource>()\n\n  onMount({ el, key, expressionEvaluated, effect, cleanup }: AttributeContext) {\n    const isString = typeof expressionEvaluated === 'string'\n\n    const addEventListeners = (eventSource: EventSource) => {\n      eventSource.addEventListener('message', (evt) => {\n        mergeHTMLFragments(el, evt.data)\n      })\n      eventSource.addEventListener('error', (evt) => {\n        console.error('SSE error', evt)\n      })\n    }\n\n    if (isString) {\n      const eventSource = new EventSource(key)\n      addEventListeners(eventSource)\n      this.eventSources.set(el, eventSource)\n    } else {\n      const isSignal = expressionEvaluated instanceof Signal\n      if (!isSignal) throw new Error(`Signal ${expressionEvaluated} not found`)\n\n      const eventSource = new EventSource(expressionEvaluated.value)\n      effect(() => {\n        addEventListeners(eventSource)\n        cleanup(() => eventSource.close())\n      })\n    }\n  }\n\n  onUnmount({ el }: AttributeContext): void {\n    const eventSource = this.eventSources.get(el)\n    if (eventSource) {\n      eventSource.close()\n    }\n  }\n}\n\nexport const ACCEPT = 'Accept'\nexport const CONTENT_TYPE = 'Content-Type'\nexport const TEXT_HTML = 'text/html'\nexport const APPLICATION_JSON = 'application/json'\n\nasync function fetcher(method: Method, { el, get, expressionEvaluated }: AttributeContext) {\n  const urlSignal = get(method)\n  if (!urlSignal) throw new Error(`No url for ${method}`)\n\n  el.classList.add(LOADING_CLASS)\n\n  const headers = new Headers()\n  headers.append(ACCEPT, TEXT_HTML)\n  headers.append(CONTENT_TYPE, APPLICATION_JSON)\n\n  const ctxHeaders = get(REQ_HEADERS_CTX_KEY) as Headers\n  if (ctxHeaders) {\n    for (const [name, value] of ctxHeaders.entries()) {\n      headers.append(name, value)\n    }\n  }\n\n  const url = new URL(expressionEvaluated, window.location.origin)\n  const dataStack = {}\n  const dataStackJSON = JSON.stringify(dataStack)\n  const req: RequestInit = { method, headers }\n  if (method === GET) {\n    const queryParams = new URLSearchParams(url.search)\n    queryParams.append('dataStack', dataStackJSON)\n    url.search = queryParams.toString()\n  } else {\n    req.body = dataStackJSON\n  }\n  const res = await fetch(url, req)\n  if (!res.ok) throw new Error('Network response was not ok.')\n  const html = await res.text()\n  mergeHTMLFragments(el, html)\n  el.classList.remove(LOADING_CLASS)\n}\n\nconst p = new DOMParser()\nfunction mergeHTMLFragments(el: Element, html: string) {\n  const dom = [...p.parseFromString(html, TEXT_HTML).body.children]\n  for (let i = 0; i < dom.length; i++) {\n    const frag = dom[i]\n    if (!(frag instanceof Element)) {\n      throw new Error('Not an element')\n    }\n    const fragElement = toHTMLorSVGElement(frag)\n\n    const id = frag.getAttribute('id')\n    const firstFrag = i === 0\n    const hasID = !!id?.length\n    const useElAsTarget = firstFrag && !hasID\n\n    let targets: Iterable<Element>\n    if (useElAsTarget) {\n      targets = [el]\n    } else {\n      if (!hasID) throw new Error('No id')\n\n      const targetSelector = fragElement?.dataset?.[SELECTOR] || `#${id}`\n      targets = document.querySelectorAll(targetSelector) || []\n    }\n    if (!!!targets) throw new Error('No target element')\n\n    for (const target of targets) {\n      const merge = fragElement?.dataset?.[SWAP] || 'morph'\n      switch (merge) {\n        case 'morph':\n          idiomorph(target, frag)\n          break\n        case 'inner':\n          target.innerHTML = frag.innerHTML //  The default, replace the inner html of the target element\n          break\n        case 'outer':\n          target.outerHTML = frag.outerHTML //  Replace the entire target element with the response\n          break\n        case 'prepend':\n          target.prepend(frag.outerHTML) //  Insert the response before the first child of the target element\n          break\n        case 'append':\n          target.append(frag.outerHTML) //  Insert the response after the last child of the target element\n          break\n        case 'before':\n          target.before(frag) //  Insert the response before the target element\n          break\n        case 'after':\n          target.after(frag) //  Insert the response after the target element\n          break\n        case 'delete':\n          target.remove() //  Deletes the target element regardless of the response\n          break\n        default:\n          throw new Error('Invalid merge mode')\n      }\n    }\n  }\n}\n","import { AttributeContext, AttributePlugin, Groups, HTMLorSVGElement, RunePlugin } from '../types'\nimport { Signal, SignalAttributePlugin } from './reactivity'\nimport { noArgs } from './shared'\n\nexport class BindAttributePlugin extends AttributePlugin {\n  name = 'Bind'\n  prefix = 'bind'\n  description = 'Sets the value of the element'\n\n  onMount({ el, key, expressionEvaluated }: AttributeContext) {\n    el.setAttribute(key, `${expressionEvaluated}`)\n  }\n}\n\nexport class RefRunePlugin extends RunePlugin {\n  name = 'RefRune'\n  description = 'turns #ref into data.refs.ref.value'\n  regexp = new RegExp(/(?<whole>\\#(?<ref>[a-zA-Z_$][0-9a-zA-Z_$]*))/g)\n  replacer({ ref }: Groups) {\n    return `data.refs.${ref}.value`\n  }\n}\n\nexport class RefAttributePlugin extends AttributePlugin {\n  name = 'Ref'\n  prefix = 'ref'\n  description = 'Sets the value of the element'\n  mustHaveEmptyExpression = true\n\n  onMount({ el, key, set }: AttributeContext) {\n    set(key, el)\n  }\n}\n\nexport function getRef(ctx: AttributeContext, key: string) {\n  return ctx.get(key) as HTMLorSVGElement\n}\n\nexport class ModelAttributePlugin extends AttributePlugin {\n  name = 'Model'\n  prefix = 'model'\n  description = 'Sets the value of the element'\n  allowedTags = new Set(['input', 'textarea', 'select'])\n  requiredPluginTypes = new Set([SignalAttributePlugin])\n  updateEvents = ['change', 'input', 'keydown']\n  mustHaveEmptyExpression = true\n  mustHaveEmptyKey = true\n\n  onMount({ el, expressionEvaluated, effect, cleanup }: AttributeContext) {\n    if (!('value' in el)) throw new Error('Element must have a value property')\n    const signal = expressionEvaluated as Signal<any>\n    if (!signal) throw new Error(`Signal ${expressionEvaluated} not found`)\n    el.value = `${signal.value}`\n\n    const setter = () => {\n      const current = signal.value\n      if (typeof current === 'number') {\n        signal.value = Number(el.value)\n      } else if (typeof current === 'string') {\n        signal.value = el.value\n      } else if (typeof current === 'boolean') {\n        signal.value = Boolean(el.value)\n      } else {\n        throw new Error('Unsupported type')\n      }\n    }\n\n    effect(() => {\n      for (const event of this.updateEvents) {\n        el.addEventListener(event, setter)\n      }\n\n      cleanup(() => {\n        for (const event of this.updateEvents) {\n          el.removeEventListener(event, setter)\n        }\n      })\n    })\n  }\n}\n\nexport class EventListenerAttributePlugin extends AttributePlugin {\n  name = 'EventListener'\n  prefix = 'on'\n  description = 'Sets the value of the element'\n  allowedModifiers = new Set(['prevent', 'stop', 'capture'])\n  allowedModifierArgs = {\n    prevent: noArgs,\n    stop: noArgs,\n    capture: noArgs,\n  }\n\n  onMount({ el, key, modifiers, expressionEvaluated, effect, cleanup }: AttributeContext) {\n    const fn = expressionEvaluated as EventListener\n    if (!fn) throw new Error(`Function ${expressionEvaluated} not found`)\n\n    const options: AddEventListenerOptions = {}\n    if (modifiers.has('capture')) options.capture = true\n    if (modifiers.has('prevent')) options.passive = false\n    if (modifiers.has('stop')) options.once = true\n\n    effect(() => {\n      el.addEventListener(key, fn, options)\n      cleanup(() => el.removeEventListener(key, fn, options))\n    })\n  }\n}\n\nexport class TextNodeAttributePlugin extends AttributePlugin {\n  name = 'TextNode'\n  prefix = 'text'\n  description = 'Sets the textContent of the element'\n  mustHaveEmptyKey = true\n  mustHaveEmptyExpression = true\n\n  onMount({ el, expressionEvaluated }: AttributeContext) {\n    if (!(el instanceof HTMLElement)) throw new Error('Element is not HTMLElement')\n    el.textContent = `${expressionEvaluated}`\n  }\n}\n\nexport class FocusElementAttributePlugin extends AttributePlugin {\n  name = 'FocusElement'\n  prefix = 'focus'\n  description = 'Sets the textContent of the element'\n  mustHaveEmptyKey = true\n  mustHaveEmptyExpression = true\n\n  onMount({ el }: AttributeContext) {\n    el.focus()\n  }\n}\n","import { toHTMLorSVGElement } from '../dom'\nimport { AttributeContext, AttributePlugin } from '../types'\nimport { reactivityPlugins } from './reactivity'\nimport { noArgs } from './shared'\n\nexport const DISPLAY = 'display'\nexport const NONE = 'none'\nexport const PREPEND = 'prepend'\nexport const APPEND = 'append'\nexport const INTERSECTS = 'intersects'\nexport const IMPORTANT = 'important'\n\nexport class ShowPlugin extends AttributePlugin {\n  name = 'Show'\n  description = 'Sets the display of the element'\n  prefix = 'show'\n  allowedModifiers = new Set([IMPORTANT])\n  allowedModifierArgs = { [IMPORTANT]: noArgs }\n\n  onMount({ el, expressionEvaluated, modifiers }: AttributeContext) {\n    const shouldShow = !!expressionEvaluated\n\n    const isImportant = modifiers.has(IMPORTANT)\n    const priority = isImportant ? IMPORTANT : undefined\n\n    if (shouldShow) {\n      if (el.style.length === 1 && el.style.display === NONE) {\n        el.style.removeProperty(DISPLAY)\n      } else {\n        el.style.setProperty(DISPLAY, '', priority)\n      }\n    } else {\n      el.style.setProperty(DISPLAY, NONE, priority)\n    }\n  }\n}\n\nexport const ONCE = 'once'\nexport const FULL = 'full'\nexport const HALF = 'half'\n\nexport class IntersectionAttributePlugin extends AttributePlugin {\n  name = 'Intersection'\n  prefix = INTERSECTS\n  description = 'Sets the value of the element'\n  requiredPluginTypes = reactivityPlugins\n  allowedModifiers = new Set([ONCE, FULL, HALF])\n  allowedModifierArgs = {\n    [ONCE]: noArgs,\n    [FULL]: noArgs,\n    [HALF]: noArgs,\n  }\n\n  onMount({ modifiers, el, set, effect, cleanup }: AttributeContext) {\n    const options = { threshold: 0 }\n    if (modifiers.has(FULL)) options.threshold = 1\n    else if (modifiers.has(HALF)) options.threshold = 0.5\n\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          set(INTERSECTS, true)\n          if (modifiers.has(ONCE)) {\n            observer.disconnect()\n          }\n        }\n      })\n    }, options)\n\n    effect(() => {\n      observer.observe(el)\n\n      cleanup(() => observer.disconnect())\n    })\n  }\n}\n\nexport class TeleportAttributePlugin extends AttributePlugin {\n  name = 'Teleport'\n  prefix = 'teleport'\n  description = 'Teleports the element to another element'\n  allowedModifiers = new Set([PREPEND, APPEND])\n  allowedModifierArgs = {\n    [PREPEND]: noArgs,\n    [APPEND]: noArgs,\n  }\n  allowedTags = new Set(['template'])\n  static parentErr = new Error('Target element must have a parent if using prepend or append')\n\n  onMount({ el, modifiers, effect, expressionEvaluated }: AttributeContext) {\n    if (!(el instanceof HTMLTemplateElement)) {\n      throw new Error('Element must be a template')\n    }\n\n    effect(() => {\n      if (typeof expressionEvaluated !== 'string') {\n        throw new Error('Only string selectors are supported')\n      }\n\n      const target = document.querySelector(expressionEvaluated)\n      if (!target) throw new Error(`Target element not found: ${expressionEvaluated}`)\n\n      if (!el.content) {\n        throw new Error('Template element must have content')\n      }\n\n      const n = el.content.cloneNode(true)\n      const nEl = toHTMLorSVGElement(n as Element)\n      if (nEl?.firstElementChild) throw new Error('Empty template')\n\n      if (modifiers.has(PREPEND)) {\n        if (!target.parentNode) throw TeleportAttributePlugin.parentErr\n        target.parentNode.insertBefore(n, target)\n      } else if (modifiers.has(APPEND)) {\n        if (!target.parentNode) throw TeleportAttributePlugin.parentErr\n        target.parentNode.insertBefore(n, target.nextSibling)\n      } else {\n        target.appendChild(n)\n      }\n    })\n  }\n}\n","// function mergeActions<T extends unknown[]>(...actions: T): UnionToIntersection<T[number]> {\n//   const all = {}\n//   for (const action of actions) {\n//     Object.assign(all, action)\n//   }\n//   return all as UnionToIntersection<T[number]>\n// }\n\nimport { Datastar } from './core'\nimport { ActionRunePlugin } from './plugins/actions'\nimport {\n  FetchAttributePlugin,\n  FetchDeleteActionPlugin,\n  FetchGetActionPlugin,\n  FetchPatchActionPlugin,\n  FetchPostActionPlugin,\n  FetchPutActionPlugin,\n} from './plugins/backend'\nimport {\n  BindAttributePlugin,\n  EventListenerAttributePlugin,\n  ModelAttributePlugin,\n  RefAttributePlugin,\n  RefRunePlugin,\n  TextNodeAttributePlugin,\n} from './plugins/binding'\nimport {\n  ComputedAttributePlugin,\n  EffectAttributePlugin,\n  ReactivityRunePlugin,\n  SignalAttributePlugin,\n} from './plugins/reactivity'\nimport { IntersectionAttributePlugin, ShowPlugin, TeleportAttributePlugin } from './plugins/visibility'\n\nconst ds = new Datastar(\n  ActionRunePlugin,\n  ReactivityRunePlugin,\n  RefRunePlugin,\n  SignalAttributePlugin,\n  ComputedAttributePlugin,\n  EffectAttributePlugin,\n  BindAttributePlugin,\n  RefAttributePlugin,\n  ModelAttributePlugin,\n  EventListenerAttributePlugin,\n  TextNodeAttributePlugin,\n  ShowPlugin,\n  IntersectionAttributePlugin,\n  TeleportAttributePlugin,\n  FetchAttributePlugin,\n  FetchGetActionPlugin,\n  FetchPostActionPlugin,\n  FetchPatchActionPlugin,\n  FetchPutActionPlugin,\n  FetchDeleteActionPlugin,\n)\nds.run()\n"],"names":["SCOPE","scheduledEffects","currentScope","currentObserver","currentObservers","currentObserversIndex","effects","defaultContext","NOOP","STATE_CLEAN","STATE_CHECK","STATE_DIRTY","STATE_DISPOSED","flushEffects","runEffects","i","runTop","node","ancestors","updateCheck","root","init","scope","createScope","compute","dispose","getContext","key","setContext","value","onDispose","disposable","isFunction","self","head","current","next","disposeNode","emptyDisposal","removeSourceObservers","callable","error","handleError","compute2","observer","prevScope","prevObserver","len","coercedError","coerceError","error2","read","write","newValue","notify","ScopeNode","ScopeProto","child","tail","ComputeNode","initialValue","options","ComputeProto","isNotEqual","createComputation","a","b","update","cleanup","prevObservers","prevObserversIndex","result","source","state","index","swap","signal","signal2","computed","effect","effect2","effectResult","toHTMLorSVGElement","walkDownDOM","el","callback","functionGenerator","str","fnContents","functionEval","ctx","expression","fn","e","DatastarPlugin","AttributePlugin","RunePlugin","ActionPlugin","Datastar","plugins","mutations","m","p","allPlugins","Plugin","requiredPluginType","plugin","t","element","hasAttributePlugin","reactiveRootDisposal","cb","elTagLower","fullPrefix","attr","keyRaw","modifiersWithArgsArr","modifiersArr","label","args","expressionRaw","modifier","allowedArgs","modifiers","k","v","ActionRunePlugin","action","generatedByIdiomorphId","idiomorph","oldNode","newContent","config","parsedContent","parseContent","normalizedContent","normalizeContent","createMorphContext","morphNormalizedContent","normalizedNewContent","oldHead","newHead","promises","handleHeadElement","morphChildren","bestMatch","findBestNodeMatch","previousSibling","nextSibling","morphedNode","morphOldNodeTo","insertSiblings","isSoftMatch","syncNodeFrom","newParent","oldParent","nextNewChild","insertionPoint","newChild","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","from","to","type","fromAttribute","toAttribute","syncAttribute","fromValue","toValue","attributeName","fAttr","tAttr","newHeadTag","currentHead","added","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","newHeadChild","currentHeadElt","inNewContent","isReAppended","isPreserved","newNode","newElt","resolver","promise","resolve","removedElement","noOp","createIdMap","elt","node1","node2","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","parser","contentWithSvgsRemoved","content","Element","dummyParent","stack","currentElement","bestElement","score","newScore","scoreElement","isIdInConsideration","id","idIsWithinNode","targetNode","idSet","sourceSet","matchCount","populateIdMapForNode","idMap","nodeParent","idElements","oldContent","ReactivityRunePlugin","groups","Signal","SignalAttributePlugin","set","expressionEvaluated","Computed","ComputedAttributePlugin","EffectAttributePlugin","reactivityPlugins","noArgs","SELECTOR","SWAP","REQ_HEADERS_CTX_KEY","FetchRequestHeadersPlugin","get","headers","GET","POST","PUT","PATCH","DELETE","DATASTAR_CLASS_PREFIX","INDICATOR_CLASS","LOADING_CLASS","FetchAction","method","style","fetcher","FetchGetActionPlugin","FetchPostActionPlugin","FetchPutActionPlugin","FetchPatchActionPlugin","FetchDeleteActionPlugin","FetchAttributePlugin","ACCEPT","CONTENT_TYPE","TEXT_HTML","APPLICATION_JSON","ctxHeaders","name","url","dataStackJSON","req","queryParams","res","html","mergeHTMLFragments","dom","frag","fragElement","firstFrag","hasID","useElAsTarget","targets","targetSelector","target","BindAttributePlugin","RefRunePlugin","ref","RefAttributePlugin","ModelAttributePlugin","setter","event","EventListenerAttributePlugin","TextNodeAttributePlugin","DISPLAY","NONE","PREPEND","APPEND","INTERSECTS","IMPORTANT","ShowPlugin","shouldShow","priority","ONCE","FULL","HALF","IntersectionAttributePlugin","entries","entry","TeleportAttributePlugin","n"],"mappings":"yBAAA,MAAMA,EAAQ,OAAO,CAAC,ECEnB,IAACC,EAAmB,GAA+BC,EAAe,KAAMC,EAAkB,KAAMC,EAAmB,KAAMC,EAAwB,EAAGC,EAAU,CAAE,EAAEC,EAAiB,CAAG,EACzL,MAAMC,GAAO,IAAM,CACnB,EAAGC,EAAc,EAAGC,GAAc,EAAGC,EAAc,EAAGC,EAAiB,EACvE,SAASC,IAAe,CACtBZ,EAAmB,GACnB,eAAea,EAAU,CAC3B,CACA,SAASA,IAAa,CACpB,GAAI,CAACR,EAAQ,OAAQ,CACnBL,EAAmB,GACnB,MACD,CAED,QAASc,EAAI,EAAGA,EAAIT,EAAQ,OAAQS,IAC9BT,EAAQS,CAAC,EAAE,MAAQN,GACrBO,GAAOV,EAAQS,CAAC,CAAC,EAErBT,EAAU,CAAA,EACVL,EAAmB,EAErB,CACA,SAASe,GAAOC,EAAM,CACpB,IAAIC,EAAY,CAACD,CAAI,EACrB,KAAOA,EAAOA,EAAKjB,CAAK,GAClBiB,EAAK,IAAMA,EAAK,MAAQR,GAC1BS,EAAU,KAAKD,CAAI,EAEvB,QAASF,EAAIG,EAAU,OAAS,EAAGH,GAAK,EAAGA,IACzCI,GAAYD,EAAUH,CAAC,CAAC,CAE5B,CACA,SAASK,GAAKC,EAAM,CAClB,MAAMC,EAAQC,KACd,OAAOC,GAAQF,EAAQD,EAAK,OAAgBA,EAAK,KAAK,KAAMI,EAAQ,KAAKH,CAAK,CAAC,EAA1CD,EAA6C,IAAI,CACxF,CAsBA,SAASK,GAAWC,EAAKL,EAAQpB,EAAc,CAC7C,OAAOoB,GAAO,IAAIK,CAAG,CACvB,CACA,SAASC,GAAWD,EAAKE,EAAOP,EAAQpB,EAAc,CAChDoB,IACFA,EAAM,IAAM,CAAE,GAAGA,EAAM,IAAK,CAACK,CAAG,EAAGE,GACvC,CAMA,SAASC,GAAUC,EAAY,CAC7B,GAAI,CAACA,GAAc,CAAC7B,EAClB,OAAO6B,GAAcvB,GACvB,MAAMS,EAAOf,EACb,OAAKe,EAAK,GAEC,MAAM,QAAQA,EAAK,EAAE,EAC9BA,EAAK,GAAG,KAAKc,CAAU,EAEvBd,EAAK,GAAK,CAACA,EAAK,GAAIc,CAAU,EAJ9Bd,EAAK,GAAKc,EAML,UAAyB,CAC1Bd,EAAK,MAAQL,IAEjBmB,EAAW,KAAK,IAAI,EAChBC,EAAWf,EAAK,EAAE,EACpBA,EAAK,GAAK,KACD,MAAM,QAAQA,EAAK,EAAE,GAC9BA,EAAK,GAAG,OAAOA,EAAK,GAAG,QAAQc,CAAU,EAAG,CAAC,EAEnD,CACA,CACA,SAASN,EAAQQ,EAAO,GAAM,CAC5B,GAAI,KAAK,MAAQrB,EACf,OACF,IAAIsB,EAAOD,EAAO,KAAK,KAAO,KAAKjC,CAAK,EAAI,KAAMmC,EAAU,KAAK,IAAKC,EAAO,KAC7E,KAAOD,GAAWA,EAAQnC,CAAK,IAAM,MACnCyB,EAAQ,KAAKU,EAAS,EAAI,EAC1BE,GAAYF,CAAO,EACnBC,EAAOD,EAAQ,IACfA,EAAQ,IAAM,KACdA,EAAUC,EAERH,GACFI,GAAY,IAAI,EACdF,IACFA,EAAQ,IAAOF,EAAc,KAAK,IAAZ,MACpBC,IACFA,EAAK,IAAMC,EACf,CACA,SAASE,GAAYpB,EAAM,CACzBA,EAAK,IAAML,EACPK,EAAK,IACPqB,GAAcrB,CAAI,EAChBA,EAAK,IACPsB,EAAsBtB,EAAM,CAAC,EAC3BA,EAAK,MACPA,EAAK,IAAI,IAAM,MACjBA,EAAKjB,CAAK,EAAI,KACdiB,EAAK,GAAK,KACVA,EAAK,GAAK,KACVA,EAAK,IAAM,KACXA,EAAK,IAAMV,EACXU,EAAK,IAAM,IACb,CACA,SAASqB,GAAchB,EAAO,CAC5B,GAAI,CACF,GAAI,MAAM,QAAQA,EAAM,EAAE,EACxB,QAASP,EAAIO,EAAM,GAAG,OAAS,EAAGP,GAAK,EAAGA,IAAK,CAC7C,MAAMyB,EAAWlB,EAAM,GAAGP,CAAC,EAC3ByB,EAAS,KAAKA,CAAQ,CACvB,MAEDlB,EAAM,GAAG,KAAKA,EAAM,EAAE,EAExBA,EAAM,GAAK,IACZ,OAAQmB,EAAO,CACdC,GAAYpB,EAAOmB,CAAK,CACzB,CACH,CACA,SAASjB,GAAQF,EAAOqB,EAAUC,EAAU,CAC1C,MAAMC,EAAY3C,EAAc4C,EAAe3C,EAC/CD,EAAeoB,EACfnB,EAAkByC,EAClB,GAAI,CACF,OAAOD,EAAS,KAAKrB,CAAK,CAC9B,QAAY,CACRpB,EAAe2C,EACf1C,EAAkB2C,CACnB,CACH,CACA,SAASJ,GAAYpB,EAAOmB,EAAO,CACjC,GAAI,CAACnB,GAAS,CAACA,EAAM,IACnB,MAAMmB,EACR,IAAI1B,EAAI,EAAGgC,EAAMzB,EAAM,IAAI,OAAQ0B,EAAeC,GAAYR,CAAK,EACnE,IAAK1B,EAAI,EAAGA,EAAIgC,EAAKhC,IACnB,GAAI,CACFO,EAAM,IAAIP,CAAC,EAAEiC,CAAY,EACzB,KACD,OAAQE,EAAQ,CACfF,EAAeC,GAAYC,CAAM,CAClC,CAEH,GAAInC,IAAMgC,EACR,MAAMC,CACV,CACA,SAASC,GAAYR,EAAO,CAC1B,OAAOA,aAAiB,MAAQA,EAAQ,MAAM,KAAK,UAAUA,CAAK,CAAC,CACrE,CACA,SAASU,GAAO,CACd,OAAI,KAAK,MAAQvC,EACR,KAAK,IACVT,GAAmB,CAAC,KAAK,KACvB,CAACC,GAAoBD,EAAgB,IAAMA,EAAgB,GAAGE,CAAqB,GAAK,KAC1FA,IACUD,EAGVA,EAAiB,KAAK,IAAI,EAF1BA,EAAmB,CAAC,IAAI,GAIxB,KAAK,IACPe,GAAY,IAAI,EACX,KAAK,GACd,CACA,SAASiC,GAAMC,EAAU,CACvB,MAAMxB,EAAQG,EAAWqB,CAAQ,EAAIA,EAAS,KAAK,EAAE,EAAIA,EACzD,GAAI,KAAK,IAAI,KAAK,GAAIxB,CAAK,IACzB,KAAK,GAAKA,EACN,KAAK,IACP,QAASd,EAAI,EAAGA,EAAI,KAAK,GAAG,OAAQA,IAClCuC,GAAO,KAAK,GAAGvC,CAAC,EAAGJ,CAAW,EAIpC,OAAO,KAAK,EACd,CACA,MAAM4C,EAAY,UAAiB,CACjC,KAAKvD,CAAK,EAAI,KACd,KAAK,IAAM,KACX,KAAK,IAAM,KACPE,GACFA,EAAa,OAAO,IAAI,CAC5B,EACMsD,EAAaD,EAAU,UAC7BC,EAAW,IAAMjD,EACjBiD,EAAW,IAAM,KACjBA,EAAW,GAAK,KAChBA,EAAW,GAAK,KAChBA,EAAW,OAAS,SAASC,EAAO,CAGlC,GAFAA,EAAMzD,CAAK,EAAI,KACfyD,EAAM,IAAM,KACR,KAAK,IACP,GAAIA,EAAM,IAAK,CACb,IAAIC,EAAOD,EAAM,IACjB,KAAOC,EAAK,KACVA,EAAOA,EAAK,IACdA,EAAK,IAAM,KAAK,IAChB,KAAK,IAAI,IAAMA,CACrB,MACMD,EAAM,IAAM,KAAK,IACjB,KAAK,IAAI,IAAMA,EAGnB,KAAK,IAAMA,EACXA,EAAM,IAAMA,EAAM,MAAQlD,EAAiB,KAAK,IAAM,CAAE,GAAG,KAAK,IAAK,GAAGkD,EAAM,GAAG,EAC7E,KAAK,MACPA,EAAM,IAAOA,EAAM,IAAiB,CAAC,GAAGA,EAAM,IAAK,GAAG,KAAK,GAAG,EAArC,KAAK,IAElC,EACAD,EAAW,QAAU,UAAW,CAC9B/B,EAAQ,KAAK,IAAI,CACnB,EACA,SAASF,IAAc,CACrB,OAAO,IAAIgC,CACb,CACA,MAAMI,GAAc,SAAqBC,EAAcjB,EAAUkB,EAAS,CACxEN,EAAU,KAAK,IAAI,EACnB,KAAK,IAAMZ,EAAWhC,EAAcF,EACpC,KAAK,GAAK,GACV,KAAK,GAAK,GACV,KAAK,GAAK,KACV,KAAK,GAAK,KACV,KAAK,GAAKmD,EACNjB,IACF,KAAK,GAAKA,GACRkB,GAAWA,EAAQ,QACrB,KAAK,IAAMA,EAAQ,MACvB,EACMC,EAAeH,GAAY,UACjC,OAAO,eAAeG,EAAcN,CAAU,EAC9CM,EAAa,IAAMC,GACnBD,EAAa,KAAOX,EACpB,SAASa,EAAkBJ,EAAcjB,EAAUkB,EAAS,CAC1D,OAAO,IAAIF,GAAYC,EAAcjB,EAAUkB,CAAO,CACxD,CACA,SAASE,GAAWE,EAAGC,EAAG,CACxB,OAAOD,IAAMC,CACf,CACA,SAASlC,EAAWH,EAAO,CACzB,OAAO,OAAOA,GAAU,UAC1B,CACA,SAASV,GAAYF,EAAM,CACzB,GAAIA,EAAK,MAAQP,GACf,QAASK,EAAI,EAAGA,EAAIE,EAAK,GAAG,SAC1BE,GAAYF,EAAK,GAAGF,CAAC,CAAC,EAClBE,EAAK,MAAQN,GAFiBI,IAElC,CAKAE,EAAK,MAAQN,EACfwD,GAAOlD,CAAI,EAEXA,EAAK,IAAMR,CACf,CACA,SAAS2D,GAAQnD,EAAM,CACjBA,EAAK,KAAOA,EAAK,IAAIjB,CAAK,IAAMiB,GAClCQ,EAAQ,KAAKR,EAAM,EAAK,EACtBA,EAAK,IACPqB,GAAcrB,CAAI,EACpBA,EAAK,IAAMA,EAAKjB,CAAK,EAAIiB,EAAKjB,CAAK,EAAE,IAAM,IAC7C,CACA,SAASmE,GAAOlD,EAAM,CACpB,IAAIoD,EAAgBjE,EAAkBkE,EAAqBjE,EAC3DD,EAAmB,KACnBC,EAAwB,EACxB,GAAI,CACF+D,GAAQnD,CAAI,EACZ,MAAMsD,EAAS/C,GAAQP,EAAMA,EAAK,GAAIA,CAAI,EAC1C,GAAIb,EAAkB,CAGpB,GAFIa,EAAK,IACPsB,EAAsBtB,EAAMZ,CAAqB,EAC/CY,EAAK,IAAMZ,EAAwB,EAAG,CACxCY,EAAK,GAAG,OAASZ,EAAwBD,EAAiB,OAC1D,QAAS,EAAI,EAAG,EAAIA,EAAiB,OAAQ,IAC3Ca,EAAK,GAAGZ,EAAwB,CAAC,EAAID,EAAiB,CAAC,CAEjE,MACQa,EAAK,GAAKb,EAEZ,IAAIoE,EACJ,QAAS,EAAInE,EAAuB,EAAIY,EAAK,GAAG,OAAQ,IACtDuD,EAASvD,EAAK,GAAG,CAAC,EACbuD,EAAO,GAGVA,EAAO,GAAG,KAAKvD,CAAI,EAFnBuD,EAAO,GAAK,CAACvD,CAAI,CAI3B,MAAeA,EAAK,IAAMZ,EAAwBY,EAAK,GAAG,SACpDsB,EAAsBtB,EAAMZ,CAAqB,EACjDY,EAAK,GAAG,OAASZ,GAEf,CAACY,EAAK,IAAMA,EAAK,GACnBmC,GAAM,KAAKnC,EAAMsD,CAAM,GAEvBtD,EAAK,GAAKsD,EACVtD,EAAK,GAAK,GAEb,OAAQwB,EAAO,CACdC,GAAYzB,EAAMwB,CAAK,EACnBxB,EAAK,MAAQN,IACfyD,GAAQnD,CAAI,EACRA,EAAK,IACPsB,EAAsBtB,EAAM,CAAC,GAEjC,MACD,CACDb,EAAmBiE,EACnBhE,EAAwBiE,EACxBrD,EAAK,IAAMR,CACb,CACA,SAAS6C,GAAOrC,EAAMwD,EAAO,CAC3B,GAAI,EAAAxD,EAAK,KAAOwD,KAEZxD,EAAK,IAAMA,EAAK,MAAQR,IAC1BH,EAAQ,KAAKW,CAAI,EACZhB,GACHY,MAEJI,EAAK,IAAMwD,EACPxD,EAAK,IACP,QAASF,EAAI,EAAGA,EAAIE,EAAK,GAAG,OAAQF,IAClCuC,GAAOrC,EAAK,GAAGF,CAAC,EAAGL,EAAW,CAGpC,CACA,SAAS6B,EAAsBtB,EAAMyD,EAAO,CAC1C,IAAIF,EAAQG,EACZ,QAAS5D,EAAI2D,EAAO3D,EAAIE,EAAK,GAAG,OAAQF,IACtCyD,EAASvD,EAAK,GAAGF,CAAC,EACdyD,EAAO,KACTG,EAAOH,EAAO,GAAG,QAAQvD,CAAI,EAC7BuD,EAAO,GAAGG,CAAI,EAAIH,EAAO,GAAGA,EAAO,GAAG,OAAS,CAAC,EAChDA,EAAO,GAAG,MAGhB,CCjWA,SAASI,GAAOhB,EAAcC,EAAS,CACrC,MAAM5C,EAAO+C,EAAkBJ,EAAc,KAAMC,CAAO,EAAGgB,EAAU1B,EAAK,KAAKlC,CAAI,EACrF,OAAA4D,EAAQ7E,CAAK,EAAI,GACjB6E,EAAQ,IAAMzB,GAAM,KAAKnC,CAAI,EACtB4D,CACT,CAIA,SAASC,GAAStD,EAASqC,EAAS,CAClC,MAAM5C,EAAO+C,EACXH,GAAS,QACTrC,EACAqC,CACD,EAAEgB,EAAU1B,EAAK,KAAKlC,CAAI,EAC3B,OAAA4D,EAAQ7E,CAAK,EAAI,GACV6E,CACT,CACA,SAASE,GAAOC,EAASnB,EAAS,CAChC,MAAMgB,EAAUb,EACd,KACA,UAAqB,CACnB,IAAIiB,EAAeD,IACnB,OAAAhD,EAAWiD,CAAY,GAAKnD,GAAUmD,CAAY,EAC3C,IACR,EACD,MACJ,EACE,OAAAJ,EAAQ,GAAK,GACbV,GAAOU,CAAO,EACPpD,EAAQ,KAAKoD,EAAS,EAAI,CACnC,CChCO,SAASK,EAAmBjE,EAAqC,CACtE,OAAMA,aAAgB,aAAeA,aAAgB,WAG9CA,EAFE,IAGX,CAEgB,SAAAkE,GAAYC,EAAoBC,EAAiC,CAC/E,GAAKD,EAKL,IAJAC,EAASD,CAAE,EAEXA,EAAKA,EAAG,kBAEDA,GACLD,GAAYC,EAAIC,CAAQ,EACxBD,EAAKA,EAAG,kBAEZ,CAEO,SAASE,GAAkBC,EAAuB,CACjD,MAAAC,EAAa,UAAUD,CAAG,GAEzB,OADI,IAAI,SAAS,MAAOC,CAAU,CAE3C,CAEO,SAASC,GAAaC,EAAuB,CAClD,MAAMC,EAAaD,EAAI,cACjBE,EAAKN,GAAkBK,CAAU,EACnC,GAAA,CACED,EAAA,oBAAsBE,EAAGF,CAAG,QACzBG,EAAG,CACV,cAAQ,MAAM;AAAA,EAAiCF,CAAU,EAAE,EACrDE,CACR,CACF,CC3BO,MAAeC,EAAe,CAGnC,wBAA0B,GAC5B,CAmBO,MAAeC,UAAwBD,EAAe,CAI3D,wBAA0B,GAC1B,iBAAmB,GACnB,YACA,iBACA,mBACF,CAIO,MAAeE,UAAmBF,EAAe,CAGxD,CAEO,MAAeG,WAAqBH,EAAe,CAE1D,CCzCO,MAAMI,EAAS,CACpB,iBAAsC,CAAA,EACtC,YAA4B,CAAA,EAC5B,kBAEA,eAAeC,EAAsC,CACnD,GAAI,CAACA,EAAQ,OAAc,MAAA,IAAI,MAAM,qBAAqB,EAE1D,KAAK,kBAAoB,IAAI,iBAAkBC,GAAc,CAC3D,UAAWC,KAAKD,EACV,GAAAC,EAAE,OAAS,aAAc,CACrB,MAAAjB,EAAKF,EAAmBmB,EAAE,MAAM,EACtC,GAAI,CAACjB,EAAI,OAGT,KAAK,sBAAsBA,EAAI,CAACkB,EAAGZ,IAAQ,CACzCY,EAAE,YAAYZ,CAAG,EACjBY,EAAE,QAAQZ,CAAG,CAAA,CACd,CAAA,MAECW,EAAA,aAAa,QAASpF,GAAS,CACzB,MAAAmE,EAAKF,EAAmBjE,CAAI,EAC7BmE,GAEL,KAAK,sBAAsBA,EAAI,CAACkB,EAAGZ,IAAQ,CACzCY,EAAE,YAAYZ,CAAG,CAAA,CAClB,CAAA,CACF,CAEL,CACD,EAEI,KAAA,kBAAkB,QAAQ,SAAS,KAAM,CAC5C,WAAY,GACZ,kBAAmB,GACnB,QAAS,GACT,UAAW,EAAA,CACZ,EAED,MAAMa,EAA+B,CAAA,EACrC,UAAWC,KAAUL,EAAS,CACtB,MAAAG,EAAI,IAAIE,EAEZF,EAAA,oBAAoB,QAASG,GAAuB,CAEpD,GAAI,CADmBF,EAAW,KAAMG,GAAWA,aAAkBD,CAAkB,EAE/E,MAAA,IAAI,MAAM,WAAWH,EAAE,IAAI,sBAAsBG,EAAmB,IAAI,GAAG,EAGnF,GAAIH,aAAaP,EACXO,EAAE,cACJA,EAAE,YAAc,IAAI,IAAI,CAAC,GAAGA,EAAE,WAAW,EAAE,IAAKK,GAAMA,EAAE,YAAA,CAAa,CAAC,GAEnE,KAAA,iBAAiB,KAAKL,CAAC,UACnBA,aAAaN,EACjB,KAAA,YAAY,KAAKM,CAAC,MAEjB,OAAA,IAAI,MAAM,qBAAqB,EAGvCC,EAAW,KAAKD,CAAC,CAAA,CAClB,CACH,CACF,CAEA,KAAM,CACQnB,GAAA,SAAS,KAAOyB,GAAY,CAChC,MAAAxB,EAAKF,EAAmB0B,CAAO,EACrC,GAAI,CAACxB,EAAI,OAET,IAAIyB,EAAqB,GACnB,MAAAC,EAAuB1F,GAAMK,IACjC,KAAK,sBAAsB2D,EAAI,CAACkB,EAAGZ,IAAQ,CACzCY,EAAE,QAAQZ,CAAG,EACQmB,EAAA,EAAA,CACtB,EAEMpF,EACR,EAEIoF,GAAyCC,GAAA,CAC/C,CACH,CAEQ,sBAAsB1B,EAAsB2B,EAAyD,CACtG,KAAA,iBAAiB,QAAST,GAAM,CACnC,GAAIA,EAAE,YAAa,CACX,MAAAU,EAAa5B,EAAG,QAAQ,YAAY,EAC1C,GAAI,CAACkB,EAAE,YAAY,IAAIU,CAAU,EAAG,MACtC,CAEM,MAAAC,EAAa,QAAQX,EAAE,MAAM,GAExB,UAAAY,KAAQ9B,EAAG,WAAY,CAChC,GAAI,CAAC8B,EAAK,KAAK,WAAWD,CAAU,EAAG,SAEvC,IAAIE,EAASD,EAAK,KAAK,MAAMD,EAAW,MAAM,EAC1CE,EAAO,WAAW,GAAG,IAAYA,EAAAA,EAAO,MAAM,CAAC,GAEnD,KAAM,CAACxF,EAAK,GAAGyF,CAAoB,EAAID,EAAO,MAAM,GAAG,EAEvD,GAAIb,EAAE,kBAAoB3E,EAAI,OAAS,EACrC,MAAM,IAAI,MAAM,cAAcuF,EAAK,IAAI,uBAAuB,EAGhE,MAAMG,EAAeD,EAAqB,IAAKf,GAAM,CACnD,KAAM,CAACiB,EAAO,GAAGC,EAAI,EAAIlB,EAAE,MAAM,GAAG,EAC7B,MAAA,CAAE,MAAAiB,EAAO,KAAAC,GAAK,CACtB,EACKC,EAAgBN,EAAK,MAE3B,GAAIZ,EAAE,yBAA2BkB,GAAe,OAAS,EACvD,MAAM,IAAI,MAAM,cAAcN,EAAK,IAAI,8BAA8B,EAGvE,GAAIZ,EAAE,iBACJ,UAAWmB,KAAYJ,EAAc,CACnC,GAAI,CAACf,EAAE,iBAAiB,IAAImB,EAAS,KAAK,EACxC,MAAM,IAAI,MAAM,aAAaA,EAAS,KAAK,kBAAkB,EAG/D,GAAInB,EAAE,oBAAqB,CACzB,MAAMoB,EAAcpB,EAAE,oBAAoBmB,EAAS,KAAK,EACxD,GAAIC,GACE,CAACA,EAAYD,EAAS,IAAI,EAC5B,MAAM,IAAI,MAAM,aAAaA,EAAS,KAAK,6BAA6B,CAG9E,CACF,CAGI,MAAAE,MAAgB,IACtB,UAAWF,KAAYJ,EACrBM,EAAU,IAAIF,EAAS,MAAOA,EAAS,IAAI,EAG7C,MAAM/B,EAAwB,CAC5B,IAAIkC,EAAW,CACb,OAAOlG,GAAWkG,CAAC,CACrB,EACA,IAAIA,EAAGC,EAAG,CACRjG,GAAWgG,EAAGC,CAAC,CACjB,EACA,GAAAzC,EACA,IAAAzD,EACA,cAAA6F,EACA,UAAAG,EACA,OAAA5C,GACA,QAASjD,EAAA,EAGP4D,EAAA,oBAAsBD,GAAaC,CAAG,EAE1CqB,EAAGT,EAAGZ,CAAG,CACX,CAAA,CACD,CACH,CACF,CCvKO,MAAMoC,WAAyB9B,CAAW,CAC/C,KAAO,aACP,YAAc,gBACd,OAAS,IAAI,OAAO,0EAA0E,EAC9F,SAAS,CAAE,OAAA+B,EAAQ,KAAAR,GAAgB,CACjC,MAAO,QAAQQ,CAAM,WAAWR,GAAQ,EAAE,GAC5C,CACF,CCTA,MAAMS,MAA6B,QAK5B,SAASC,GAAUC,EAA6BC,EAA8BC,EAAS,CAAA,EAAI,CAC5FF,aAAmB,WACrBA,EAAUA,EAAQ,iBAGhB,IAAAG,EACA,OAAOF,GAAe,SACxBE,EAAgBC,GAAaH,CAAU,EAEvBE,EAAAF,EAGZ,MAAAI,EAAoBC,GAAiBH,CAAa,EAClD3C,EAAM+C,GAAmBP,EAASK,EAAmBH,CAAM,EAE1D,OAAAM,GAAuBR,EAASK,EAAmB7C,CAAG,CAC/D,CAEA,SAASgD,GAAuBR,EAAkBS,EAA+BjD,EAAU,CACrF,GAAAA,EAAI,KAAK,MAAO,CACZ,MAAAkD,EAAUV,EAAQ,cAAc,MAAM,EACtCW,EAAUF,EAAqB,cAAc,MAAM,EACzD,GAAIC,GAAWC,EAAS,CACtB,MAAMC,EAAWC,GAAkBF,EAASD,EAASlD,CAAG,EAExD,QAAQ,IAAIoD,CAAQ,EAAE,KAAK,IAAM,CAC/BJ,GACER,EACAS,EACA,OAAO,OAAOjD,EAAK,CACjB,KAAM,CACJ,MAAO,GACP,OAAQ,EACV,CAAA,CACD,CAAA,CACH,CACD,EACD,MACF,CACF,CAEI,GAAAA,EAAI,aAAe,YAEP,OAAAsD,GAAAL,EAAsBT,EAASxC,CAAG,EACzCwC,EAAQ,YACNxC,EAAI,aAAe,aAAeA,EAAI,YAAc,KAAM,CAGnE,MAAMuD,EAAYC,GAAkBP,EAAsBT,EAASxC,CAAG,EACtE,GAAI,CAACuD,EAAiB,MAAA,IAAI,MAAM,2BAA2B,EAG3D,MAAME,EAAkBF,GAAW,gBAC7BG,EAAcH,GAAW,YAGzBI,EAAcC,EAAepB,EAASe,EAAWvD,CAAG,EAE1D,OAAIuD,EAGKM,GAAeJ,EAAiBE,EAAaD,CAAW,EAGxD,EACT,KAEA,MAAM,wCAA0C1D,EAAI,UAExD,CAQA,SAAS4D,EAAepB,EAAkBC,EAAqBzC,EAAU,CACvE,GAAI,EAAAA,EAAI,cAAgBwC,IAAY,SAAS,eAE7C,GAAWC,GAAc,KAAM,CAC7B,GAAIzC,EAAI,UAAU,kBAAkBwC,CAAO,IAAM,GAAO,OAExDA,EAAQ,OAAO,EACXxC,EAAA,UAAU,iBAAiBwC,CAAO,EACtC,MACS,KAAA,IAACsB,EAAYtB,EAASC,CAAU,EAUzC,OAAIzC,EAAI,UAAU,kBAAkBwC,EAASC,CAAU,IAAM,GAAO,QAEhED,aAAmB,iBAAmBxC,EAAI,KAAK,SAGjDyC,aAAsB,iBACtBD,aAAmB,iBACnBxC,EAAI,KAAK,QAAU,QAEDqD,GAAAZ,EAAYD,EAASxC,CAAG,GAE1C+D,GAAatB,EAAYD,CAAO,EAClBc,GAAAb,EAAYD,EAASxC,CAAG,IAEpCA,EAAA,UAAU,iBAAiBwC,EAASC,CAAU,EAC3CD,GAvBP,GADIxC,EAAI,UAAU,kBAAkBwC,CAAO,IAAM,IAC7CxC,EAAI,UAAU,gBAAgByC,CAAU,IAAM,GAAO,OAEzD,GAAI,CAACD,EAAQ,cAAqB,MAAA,IAAI,MAAM,8BAA8B,EAClE,OAAAA,EAAA,cAAc,aAAaC,EAAYD,CAAO,EAClDxC,EAAA,UAAU,eAAeyC,CAAU,EACnCzC,EAAA,UAAU,iBAAiBwC,CAAO,EAC/BC,EAmBX,CAwBA,SAASa,GAAcU,EAAoBC,EAAoBjE,EAAU,CACvE,IAAIkE,EAAeF,EAAU,WACzBG,EAAiBF,EAAU,WAC3BG,EAGJ,KAAOF,GAAc,CAKnB,GAJWE,EAAAF,EACXA,EAAeE,EAAS,YAGpBD,GAAkB,KAAM,CAC1B,GAAInE,EAAI,UAAU,gBAAgBoE,CAAQ,IAAM,GAAO,OAEvDH,EAAU,YAAYG,CAAQ,EAC1BpE,EAAA,UAAU,eAAeoE,CAAQ,EACrCC,EAA2BrE,EAAKoE,CAAQ,EACxC,QACF,CAGA,GAAIE,GAAaF,EAAUD,EAAgBnE,CAAG,EAAG,CAChC4D,EAAAO,EAAgBC,EAAUpE,CAAG,EAC5CmE,EAAiBA,EAAe,YAChCE,EAA2BrE,EAAKoE,CAAQ,EACxC,QACF,CAGA,IAAIG,EAAaC,GAAeR,EAAWC,EAAWG,EAAUD,EAAgBnE,CAAG,EAGnF,GAAIuE,EAAY,CACGJ,EAAAM,GAAmBN,EAAgBI,EAAYvE,CAAG,EACpD4D,EAAAW,EAAYH,EAAUpE,CAAG,EACxCqE,EAA2BrE,EAAKoE,CAAQ,EACxC,QACF,CAGA,IAAIM,EAAYC,GAAcX,EAAWI,EAAUD,EAAgBnE,CAAG,EAGtE,GAAI0E,EAAW,CACIP,EAAAM,GAAmBN,EAAgBO,EAAW1E,CAAG,EACnD4D,EAAAc,EAAWN,EAAUpE,CAAG,EACvCqE,EAA2BrE,EAAKoE,CAAQ,EACxC,QACF,CAIA,GAAIpE,EAAI,UAAU,gBAAgBoE,CAAQ,IAAM,GAAO,OAE7CH,EAAA,aAAaG,EAAUD,CAAc,EAC3CnE,EAAA,UAAU,eAAeoE,CAAQ,EACrCC,EAA2BrE,EAAKoE,CAAQ,CAC1C,CAGA,KAAOD,IAAmB,MAAM,CAC9B,IAAIS,EAAWT,EACfA,EAAiBA,EAAe,YAChCU,GAAWD,EAAU5E,CAAG,CAC1B,CACF,CAaA,SAAS+D,GAAae,EAAeC,EAAa,CAChD,IAAIC,EAAOF,EAAK,SAIhB,GAAIE,IAAS,EAAsB,CACtB,UAAAC,KAAiBH,EAAK,WACXC,EAAG,aAAaE,EAAc,IAAI,IAClCA,EAAc,OAChCF,EAAG,aAAaE,EAAc,KAAMA,EAAc,KAAK,EAGhD,UAAAC,KAAeH,EAAG,WACtBD,EAAK,aAAaI,EAAY,IAAI,GAClCH,EAAA,gBAAgBG,EAAY,IAAI,CAGzC,CAeA,IAZIF,IAAS,KAAK,cAAgBA,IAAS,KAAK,YAC1CD,EAAG,YAAcD,EAAK,YACxBC,EAAG,UAAYD,EAAK,WAUpBA,aAAgB,kBAAoBC,aAAc,kBAAoBD,EAAK,OAAS,OACnFC,EAAA,MAAQD,EAAK,OAAS,GACXK,EAAAL,EAAMC,EAAI,OAAO,EAGjBI,EAAAL,EAAMC,EAAI,SAAS,EACnBI,EAAAL,EAAMC,EAAI,UAAU,UACzBD,aAAgB,kBACXK,EAAAL,EAAMC,EAAI,UAAU,UACzBD,aAAgB,qBAAuBC,aAAc,oBAAqB,CACnF,MAAMK,EAAYN,EAAK,MACjBO,EAAUN,EAAG,MACfK,IAAcC,IAChBN,EAAG,MAAQK,GAETL,EAAG,YAAcA,EAAG,WAAW,YAAcK,IAC/CL,EAAG,WAAW,UAAYK,EAE9B,CACF,CAEA,SAASD,EAAcL,EAAeC,EAAaO,EAAuB,CAClE,MAAAC,EAAQT,EAAK,aAAaQ,CAAa,EACvCE,EAAQT,EAAG,aAAaO,CAAa,EAEvCC,IAAUC,IACRD,EACCR,EAAA,aAAaO,EAAeC,CAAK,EAEpCR,EAAG,gBAAgBO,CAAa,EAGtC,CAKA,SAASjC,GAAkBoC,EAA6BC,EAA8B1F,EAAU,CAC9F,MAAM2F,EAAQ,CAAA,EACRC,EAAU,CAAA,EACVC,EAAY,CAAA,EACZC,EAAgB,CAAA,EAEhBC,EAAiB/F,EAAI,KAAK,MAG1BgG,MAAwB,IACnB,UAAAC,KAAgBR,EAAW,SAClBO,EAAA,IAAIC,EAAa,UAAWA,CAAY,EAIjD,UAAAC,KAAkBR,EAAY,SAAU,CAEjD,IAAIS,EAAeH,EAAkB,IAAIE,EAAe,SAAS,EAC7DE,EAAepG,EAAI,KAAK,eAAekG,CAAc,EACrDG,EAAcrG,EAAI,KAAK,eAAekG,CAAc,EACpDC,GAAgBE,EACdD,EAEFR,EAAQ,KAAKM,CAAc,GAITF,EAAA,OAAOE,EAAe,SAAS,EACjDL,EAAU,KAAKK,CAAc,GAG3BH,IAAmB,SAGjBK,IACFR,EAAQ,KAAKM,CAAc,EAC3BJ,EAAc,KAAKI,CAAc,GAI/BlG,EAAI,KAAK,aAAakG,CAAc,IAAM,IAC5CN,EAAQ,KAAKM,CAAc,CAInC,CAIAJ,EAAc,KAAK,GAAGE,EAAkB,OAAQ,CAAA,EACxC,QAAA,IAAI,cAAeF,CAAa,EAExC,MAAM1C,EAAW,CAAA,EACjB,UAAWkD,KAAWR,EAAe,CAC3B,QAAA,IAAI,WAAYQ,CAAO,EAC/B,MAAMC,EAAS,SAAS,cAAc,yBAAyBD,EAAQ,SAAS,EAAE,WAClF,GAAI,CAACC,EAAQ,MAAM,IAAI,MAAM,sCAAwCD,EAAQ,SAAS,EAEtF,GADA,QAAQ,IAAIC,CAAM,EACZvG,EAAI,UAAU,gBAAgBuG,CAAM,EAAG,CAC3C,GAAIA,EAAO,aAAa,MAAM,GAAKA,EAAO,aAAa,KAAK,EAAG,CACzD,IAAAC,EACJ,MAAMC,EAAU,IAAI,QAASC,GAAY,CAC5BF,EAAAE,CAAA,CACZ,EACMH,EAAA,iBAAiB,OAAQ,UAAY,CAC1CC,EAAS,MAAS,CAAA,CACnB,EACDpD,EAAS,KAAKqD,CAAO,CACvB,CACAf,EAAY,YAAYa,CAAM,EAC1BvG,EAAA,UAAU,eAAeuG,CAAM,EACnCZ,EAAM,KAAKY,CAAM,CACnB,CACF,CAIA,UAAWI,KAAkBf,EACvB5F,EAAI,UAAU,kBAAkB2G,CAAc,IAAM,KACtDjB,EAAY,YAAYiB,CAAc,EAClC3G,EAAA,UAAU,iBAAiB2G,CAAc,GAI7C,OAAA3G,EAAA,KAAK,iBAAiB0F,EAAa,CACrC,MAAAC,EACA,KAAME,EACN,QAAAD,CAAA,CACD,EACMxC,CACT,CAKA,SAASwD,GAAO,CAAC,CAEjB,SAAS7D,GAAmBP,EAAkBC,EAAqBC,EAAa,CACvE,MAAA,CACL,OAAQF,EACR,WAAAC,EACA,OAAAC,EACA,WAAYA,EAAO,WACnB,aAAcA,EAAO,aACrB,MAAOmE,GAAYrE,EAASC,CAAU,EACtC,YAAa,IACb,UAAW,OAAO,OAChB,CACE,gBAAiBmE,EACjB,eAAgBA,EAChB,kBAAmBA,EACnB,iBAAkBA,EAClB,kBAAmBA,EACnB,iBAAkBA,CACpB,EACAlE,EAAO,SACT,EACA,KAAM,OAAO,OACX,CACE,MAAO,QACP,eAAiBoE,GAAiBA,EAAI,aAAa,aAAa,IAAM,OACtE,eAAiBA,GAAiBA,EAAI,aAAa,cAAc,IAAM,OACvE,aAAcF,EACd,iBAAkBA,CACpB,EACAlE,EAAO,IACT,CAAA,CAEJ,CAEA,SAAS4B,GAAayC,EAAgBC,EAAgBhH,EAAU,CAC1D,MAAA,CAAC+G,GAAS,CAACC,EAAc,GAEzBD,EAAM,WAAaC,EAAM,UAAYD,EAAM,UAAYC,EAAM,QAC3DD,GAAO,IAAI,QAAUA,EAAM,KAAOC,EAAM,GAAW,GAEhDC,EAAuBjH,EAAK+G,EAAOC,CAAK,EAAI,EAE9C,EACT,CAEA,SAASlD,EAAYiD,EAAgBC,EAAgB,CAC/C,MAAA,CAACD,GAAS,CAACC,EAAc,GAEtBD,EAAM,WAAaC,EAAM,UAAYD,EAAM,UAAYC,EAAM,OACtE,CAEA,SAASvC,GAAmByC,EAAyBC,EAAuBnH,EAAU,CACpF,KAAOkH,IAAmBC,GAAc,CACtC,MAAMvC,EAAWsC,EAEjB,GADAA,EAAiBA,GAAgB,YAC7B,CAACtC,EAAgB,MAAA,IAAI,MAAM,kBAAkB,EACjDC,GAAWD,EAAU5E,CAAG,CAC1B,CACA,OAAAqE,EAA2BrE,EAAKmH,CAAY,EACrCA,EAAa,WACtB,CAQA,SAAS3C,GAAe/B,EAAqBwB,EAAoBG,EAAmBD,EAAyBnE,EAAU,CAErH,MAAMoH,EAA2BH,EAAuBjH,EAAKoE,EAAUH,CAAS,EAEhF,IAAIoD,EAAiC,KAGrC,GAAID,EAA2B,EAAG,CACfC,EAAAlD,EAKjB,IAAImD,EAAkB,EACtB,KAAOD,GAAkB,MAAM,CAE7B,GAAI/C,GAAaF,EAAUiD,EAAgBrH,CAAG,EACrC,OAAAqH,EAKT,GADmBC,GAAAL,EAAuBjH,EAAKqH,EAAgB5E,CAAU,EACrE6E,EAAkBF,EAGb,OAAA,KAITC,EAAiBA,EAAe,WAClC,CACF,CACO,OAAAA,CACT,CAQA,SAAS1C,GAAclC,EAAqB2B,EAAmBD,EAAyBnE,EAAU,CAChG,IAAIuH,EAAqBpD,EACrBT,EAAcU,EAAS,YAEvBoD,EAAwB,EAE5B,KAAOD,GAAsB7D,GAAa,CACxC,GAAIuD,EAAuBjH,EAAKuH,EAAoB9E,CAAU,EAAI,EAGzD,OAAA,KAIL,GAAAqB,EAAYM,EAAUmD,CAAkB,EACnC,OAAAA,EAGL,GAAAzD,EAAYJ,EAAa6D,CAAkB,IAG7CC,IACA9D,EAAcA,EAAY,YAItB8D,GAAyB,GACpB,OAAA,KAKXD,EAAqBA,EAAmB,WAC1C,CAEO,OAAAA,CACT,CAEA,MAAME,GAAS,IAAI,UACnB,SAAS7E,GAAaH,EAAoB,CAExC,MAAMiF,EAAyBjF,EAAW,QAAQ,uCAAwC,EAAE,EAI1F,GAAAiF,EAAuB,MAAM,UAAU,GACvCA,EAAuB,MAAM,UAAU,GACvCA,EAAuB,MAAM,UAAU,EACvC,CACA,MAAMC,EAAUF,GAAO,gBAAgBhF,EAAY,WAAW,EAE1D,GAAAiF,EAAuB,MAAM,UAAU,EACzC,OAAApF,EAAuB,IAAIqF,CAAO,EAC3BA,EACF,CAEL,IAAIC,EAAUD,EAAQ,WACtB,OAAIC,GACFtF,EAAuB,IAAIsF,CAAO,EAC3BA,GAEA,IAEX,CAAA,KACK,CAIL,MAAMD,EADcF,GAAO,gBAAgB,mBAAmBhF,CAAU,qBAAsB,WAAW,EAC7E,KAAK,cAAc,UAAU,GAAG,QAC5D,GAAI,CAACkF,EAAe,MAAA,IAAI,MAAM,iBAAiB,EAC/C,OAAArF,EAAuB,IAAIqF,CAAO,EAC3BA,CACT,CACF,CAEA,SAAS7E,GAAiBL,EAAqB,CAC7C,GAAIA,GAAc,KAGT,OADa,SAAS,cAAc,KAAK,EAEvC,GAAAH,EAAuB,IAAIG,CAAU,EAEvC,OAAAA,EACT,GAAWA,aAAsB,KAAM,CAE/B,MAAAoF,EAAc,SAAS,cAAc,KAAK,EAChD,OAAAA,EAAY,OAAOpF,CAAU,EACtBoF,CAAA,KACF,CAGC,MAAAA,EAAc,SAAS,cAAc,KAAK,EAChD,UAAWf,IAAO,CAAC,GAAGrE,CAAU,EAC9BoF,EAAY,OAAOf,CAAG,EAEjB,OAAAe,CACT,CACF,CAEA,SAAShE,GAAeJ,EAA2BE,EAAuBD,EAAuB,CAC/F,MAAMoE,EAAQ,CAAA,EACRnC,EAAQ,CAAA,EACd,KAAOlC,GACLqE,EAAM,KAAKrE,CAAe,EAC1BA,EAAkBA,EAAgB,gBAE7B,KAAAqE,EAAM,OAAS,GAAG,CACjB,MAAAvM,EAAOuM,EAAM,MACnBnC,EAAM,KAAKpK,CAAI,EACFoI,GAAA,eAAe,aAAapI,EAAMoI,CAAW,CAC5D,CAEA,IADAgC,EAAM,KAAKhC,CAAW,EACfD,GACLoE,EAAM,KAAKpE,CAAW,EACtBiC,EAAM,KAAKjC,CAAW,EACtBA,EAAcA,EAAY,YAE5B,KAAOoE,EAAM,QACXnE,GAAa,eAAe,aAAamE,EAAM,MAAQnE,EAAY,WAAW,EAEzE,OAAAgC,CACT,CAEA,SAASnC,GAAkBf,EAAqBD,EAAkBxC,EAAU,CAC1E,IAAI+H,EAAiBtF,EAAW,WAC5BuF,EAAcD,EACdE,EAAQ,EACZ,KAAOF,GAAgB,CACrB,IAAIG,EAAWC,GAAaJ,EAAgBvF,EAASxC,CAAG,EACpDkI,EAAWD,IACCD,EAAAD,EACNE,EAAAC,GAEVH,EAAiBA,EAAe,WAClC,CACO,OAAAC,CACT,CAEA,SAASG,GAAapB,EAAgBC,EAAgBhH,EAAU,CAC1D,OAAA8D,EAAYiD,EAAOC,CAAK,EACnB,GAAMC,EAAuBjH,EAAK+G,EAAOC,CAAK,EAEhD,CACT,CAEA,SAASnC,GAAWD,EAAmB5E,EAAU,CAC/CqE,EAA2BrE,EAAK4E,CAAQ,EACpC5E,EAAI,UAAU,kBAAkB4E,CAAQ,IAAM,KAElDA,EAAS,OAAO,EACZ5E,EAAA,UAAU,iBAAiB4E,CAAQ,EACzC,CAMA,SAASwD,GAAoBpI,EAAUqI,EAAY,CACjD,MAAO,CAACrI,EAAI,QAAQ,IAAIqI,CAAE,CAC5B,CAEA,SAASC,GAAetI,EAAUqI,EAAYE,EAAqB,CACjE,OAAOvI,EAAI,MAAM,IAAIuI,CAAU,GAAG,IAAIF,CAAE,GAAK,EAC/C,CAEA,SAAShE,EAA2BrE,EAAUzE,EAAe,CAC3D,MAAMiN,EAAQxI,EAAI,MAAM,IAAIzE,CAAI,EAChC,GAAKiN,EACL,UAAWH,KAAMG,EACXxI,EAAA,QAAQ,IAAIqI,CAAE,CAEtB,CAEA,SAASpB,EAAuBjH,EAAU+G,EAAgBC,EAAgB,CACxE,MAAMyB,EAAYzI,EAAI,MAAM,IAAI+G,CAAK,EACrC,GAAI,CAAC0B,EAAkB,MAAA,GAEvB,IAAIC,EAAa,EACjB,UAAWL,KAAMI,EAGXL,GAAoBpI,EAAKqI,CAAE,GAAKC,GAAetI,EAAKqI,EAAIrB,CAAK,GAC7D,EAAA0B,EAGC,OAAAA,CACT,CAUA,SAASC,GAAqBpN,EAAeqN,EAAkC,CAC7E,MAAMC,EAAatN,EAAK,cAElBuN,EAAavN,EAAK,iBAAiB,MAAM,EAC/C,UAAWuL,KAAOgC,EAAY,CAC5B,IAAIrM,EAAUqK,EAGd,KAAOrK,IAAYoM,GAAgBpM,GAAS,CACtC,IAAA+L,EAAQI,EAAM,IAAInM,CAAO,EAEzB+L,GAAS,OACXA,MAAY,IACNI,EAAA,IAAInM,EAAS+L,CAAK,GAEpBA,EAAA,IAAI1B,EAAI,EAAE,EAChBrK,EAAUA,EAAQ,aACpB,CACF,CACF,CAYA,SAASoK,GAAYkC,EAAqBtG,EAAqB,CACvD,MAAAmG,MAAY,IAClB,OAAAD,GAAqBI,EAAYH,CAAK,EACtCD,GAAqBlG,EAAYmG,CAAK,EAC/BA,CACT,CCntBO,MAAMI,WAA6B1I,CAAW,CACnD,KAAO,iBACP,YAAc,oBACd,OAAS,IAAI,OAAO,kDAAkD,EACtE,SAAS2I,EAAgB,CACjB,KAAA,CAAE,OAAA/J,CAAW,EAAA+J,EACnB,MAAO,OAAO/J,CAAM,SACtB,CACF,CAEO,MAAMgK,EAAU,CACb,IACR,YAAY/M,EAAU,CACf,KAAA,IAAM+C,GAAO/C,CAAK,CACzB,CAEA,IAAI,OAAQ,CACV,OAAO,KAAK,KACd,CAEA,IAAI,MAAMgG,EAAM,CACT,KAAA,IAAI,IAAIA,CAAC,CAChB,CACF,CAEO,MAAMgH,WAA8B9I,CAAgB,CACzD,KAAO,SACP,YAAc,qBACd,OAAS,SAET,QAAQ,CAAE,IAAApE,EAAK,IAAAmN,EAAK,oBAAAC,GAAyC,CAC3DD,EAAInN,EAAK,IAAIiN,GAAOG,CAAmB,CAAC,CAC1C,CACF,CAEO,MAAMC,EAAY,CACf,IACR,YAAYnN,EAAgB,CACrB,KAAA,IAAMiD,GAASjD,CAAK,CAC3B,CAEA,IAAI,OAAQ,CACV,OAAO,KAAK,KACd,CACF,CAEO,MAAMoN,WAAgClJ,CAAgB,CAC3D,KAAO,WACP,YAAc,uBACd,OAAS,WAET,QAAQ,CAAE,IAAApE,EAAK,IAAAmN,EAAK,oBAAAC,GAAyC,CAC3DD,EAAInN,EAAK,IAAIqN,GAASD,CAAmB,CAAC,CAC5C,CACF,CAEO,MAAMG,WAA8BnJ,CAAgB,CACzD,KAAO,SACP,YAAc,sBACd,OAAS,SAET,QAAQ,CAAE,IAAApE,EAAK,IAAAmN,EAAK,oBAAAC,GAAyC,CACvD,GAAA,OAAOA,GAAwB,WAC3B,MAAA,IAAI,MAAM,qCAAqC,EAGnDD,EAAAnN,EAAKoD,GAAOgK,CAAmB,CAAC,CACtC,CACF,CAEa,MAAAI,OAAwB,IAAI,CACvCT,GACAG,GACAI,GACAC,EACF,CAAC,EC9EYE,EAAU7H,GAAmBA,EAAK,SAAW,ECO7C8H,GAAW,WACXC,GAAO,OACPC,GAAsB,aAE5B,MAAMC,WAAkCzJ,CAAgB,CAC7D,KAAO,sBACP,OAAS,SACT,YAAc,wCACd,iBAAmB,GAEnB,QAAQ,CAAE,IAAApE,EAAK,IAAA8N,EAAK,IAAAX,EAAK,oBAAAC,GAAyC,CAC5D,IAAAW,EAA+BD,EAAIF,EAAmB,EAErDG,IACHA,EAAU,IAAI,SAGRA,EAAA,IAAI/N,EAAKoN,CAAmB,EACpCD,EAAIS,GAAqBG,CAAO,CAClC,CACF,CAEO,MAAMC,EAAM,MACNC,EAAO,OACPC,EAAM,MACNC,EAAQ,QACRC,EAAS,SAEhBC,GAAwB,WACxBC,GAAkB,GAAGD,EAAqB,aAC1CE,EAAgB,GAAGF,EAAqB,WAI9C,MAAeG,UAAoBlK,EAAa,CAK9C,YAA4BmK,EAAgB,CAMtC,GALE,QADoB,KAAA,OAAAA,EAErB,KAAA,KAAO,QAAQA,CAAM,GACrB,KAAA,YAAc,2CAA2CA,CAAM,GACpE,KAAK,oBAA0B,IAAA,IAAI,CAACZ,GAA2B,GAAGL,EAAiB,CAAC,EAEhF,CAACgB,EAAY,kBAAmB,CAC5B,MAAAE,EAAQ,SAAS,cAAc,OAAO,EAC5CA,EAAM,UAAY;AAAA,GACrBJ,EAAe;AAAA;AAAA;AAAA;AAAA,GAIfC,CAAa,KAAKD,EAAe;AAAA;AAAA;AAAA,GAGjCC,CAAa,IAAID,EAAe;AAAA;AAAA;AAAA,MAIpB,SAAA,KAAK,YAAYI,CAAK,EAC/BF,EAAY,kBAAoB,EAClC,CACF,CA3BA,OAAO,kBAAoB,GAC3B,KACA,YA2BA,MAAM,OAAOzK,EAAuB,CAC5B,MAAA4K,GAAQ,KAAK,OAAQ5K,CAAG,CAChC,CACF,CAEO,MAAM6K,WAA6BJ,CAAY,CACpD,aAAc,CACZ,MAAMR,CAAG,CACX,CACF,CAEO,MAAMa,WAA8BL,CAAY,CACrD,aAAc,CACZ,MAAMP,CAAI,CACZ,CACF,CAEO,MAAMa,WAA6BN,CAAY,CACpD,aAAc,CACZ,MAAMN,CAAG,CACX,CACF,CAEO,MAAMa,WAA+BP,CAAY,CACtD,aAAc,CACZ,MAAML,CAAK,CACb,CACF,CAEO,MAAMa,WAAgCR,CAAY,CACvD,aAAc,CACZ,MAAMJ,CAAM,CACd,CACF,CAEO,MAAMa,WAA6B7K,CAAgB,CACxD,KAAO,QACP,OAAS,QACT,YAAc,oBACd,qBAAuB,IAAI,CAAC4J,EAAKC,EAAMC,EAAKC,EAAOC,CAAM,CAAC,EAC1D,oBAAsB,CACpB,CAACJ,CAAG,EAAGP,EACP,CAACQ,CAAI,EAAGR,EACR,CAACS,CAAG,EAAGT,EACP,CAACU,CAAK,EAAGV,EACT,CAACW,CAAM,EAAGX,CAAA,EAEZ,iBAAmB,GAEnB,QAAQ,CAAE,oBAAAL,EAAqB,UAAApH,EAAW,IAAAmH,GAA+B,CACvE,GAAI,OAAOC,GAAwB,SAAgB,MAAA,IAAI,MAAM,sCAAsC,EAE/FpH,EAAU,IAAIiI,CAAI,EACpBd,EAAIc,EAAMb,CAAmB,EACpBpH,EAAU,IAAIkI,CAAG,EAC1Bf,EAAIe,EAAKd,CAAmB,EACnBpH,EAAU,IAAImI,CAAK,EAC5BhB,EAAIgB,EAAOf,CAAmB,EACrBpH,EAAU,IAAIoI,CAAM,EAC7BjB,EAAIiB,EAAQhB,CAAmB,EAE/BD,EAAIa,EAAKZ,CAAmB,CAEhC,CAEA,UAAU,CAAE,IAAAD,EAAK,UAAAnH,GAAqC,CAChDA,EAAU,IAAIiI,CAAI,EACpBd,EAAIc,EAAM,MAAS,EACVjI,EAAU,IAAIkI,CAAG,EAC1Bf,EAAIe,EAAK,MAAS,EACTlI,EAAU,IAAImI,CAAK,EAC5BhB,EAAIgB,EAAO,MAAS,EACXnI,EAAU,IAAIoI,CAAM,EAC7BjB,EAAIiB,EAAQ,MAAS,EAErBjB,EAAIa,EAAK,MAAS,CAEtB,CACF,CA6CO,MAAMkB,GAAS,SACTC,GAAe,eACfC,GAAY,YACZC,GAAmB,mBAEhC,eAAeV,GAAQF,EAAgB,CAAE,GAAAhL,EAAI,IAAAqK,EAAK,oBAAAV,GAAyC,CAEzF,GAAI,CADcU,EAAIW,CAAM,EACZ,MAAM,IAAI,MAAM,cAAcA,CAAM,EAAE,EAEnDhL,EAAA,UAAU,IAAI8K,CAAa,EAExB,MAAAR,EAAU,IAAI,QACZA,EAAA,OAAOmB,GAAQE,EAAS,EACxBrB,EAAA,OAAOoB,GAAcE,EAAgB,EAEvC,MAAAC,EAAaxB,EAAIF,EAAmB,EAC1C,GAAI0B,EACF,SAAW,CAACC,EAAMrP,CAAK,IAAKoP,EAAW,UAC7BvB,EAAA,OAAOwB,EAAMrP,CAAK,EAI9B,MAAMsP,EAAM,IAAI,IAAIpC,EAAqB,OAAO,SAAS,MAAM,EAEzDqC,EAAgB,KAAK,UADT,CAAA,CAC4B,EACxCC,EAAmB,CAAE,OAAAjB,EAAQ,QAAAV,GACnC,GAAIU,IAAWT,EAAK,CAClB,MAAM2B,EAAc,IAAI,gBAAgBH,EAAI,MAAM,EACtCG,EAAA,OAAO,YAAaF,CAAa,EACzCD,EAAA,OAASG,EAAY,UAAS,MAElCD,EAAI,KAAOD,EAEb,MAAMG,EAAM,MAAM,MAAMJ,EAAKE,CAAG,EAChC,GAAI,CAACE,EAAI,GAAU,MAAA,IAAI,MAAM,8BAA8B,EACrD,MAAAC,EAAO,MAAMD,EAAI,OACvBE,GAAmBrM,EAAIoM,CAAI,EACxBpM,EAAA,UAAU,OAAO8K,CAAa,CACnC,CAEA,MAAM5J,GAAI,IAAI,UACd,SAASmL,GAAmBrM,EAAaoM,EAAc,CAC/C,MAAAE,EAAM,CAAC,GAAGpL,GAAE,gBAAgBkL,EAAMT,EAAS,EAAE,KAAK,QAAQ,EAChE,QAAShQ,EAAI,EAAGA,EAAI2Q,EAAI,OAAQ3Q,IAAK,CAC7B,MAAA4Q,EAAOD,EAAI3Q,CAAC,EACd,GAAA,EAAE4Q,aAAgB,SACd,MAAA,IAAI,MAAM,gBAAgB,EAE5B,MAAAC,EAAc1M,EAAmByM,CAAI,EAErC5D,EAAK4D,EAAK,aAAa,IAAI,EAC3BE,EAAY9Q,IAAM,EAClB+Q,EAAQ,CAAC,CAAC/D,GAAI,OACdgE,EAAgBF,GAAa,CAACC,EAEhC,IAAAE,EACJ,GAAID,EACFC,EAAU,CAAC5M,CAAE,MACR,CACL,GAAI,CAAC0M,EAAa,MAAA,IAAI,MAAM,OAAO,EAEnC,MAAMG,EAAiBL,GAAa,UAAUvC,EAAQ,GAAK,IAAItB,CAAE,GACjEiE,EAAU,SAAS,iBAAiBC,CAAc,GAAK,CAAA,CACzD,CACI,GAAA,CAAGD,EAAe,MAAA,IAAI,MAAM,mBAAmB,EAEnD,UAAWE,KAAUF,EAEnB,OADcJ,GAAa,UAAUtC,EAAI,GAAK,QAC/B,CACb,IAAK,QACHrH,GAAUiK,EAAQP,CAAI,EACtB,MACF,IAAK,QACHO,EAAO,UAAYP,EAAK,UACxB,MACF,IAAK,QACHO,EAAO,UAAYP,EAAK,UACxB,MACF,IAAK,UACIO,EAAA,QAAQP,EAAK,SAAS,EAC7B,MACF,IAAK,SACIO,EAAA,OAAOP,EAAK,SAAS,EAC5B,MACF,IAAK,SACHO,EAAO,OAAOP,CAAI,EAClB,MACF,IAAK,QACHO,EAAO,MAAMP,CAAI,EACjB,MACF,IAAK,SACHO,EAAO,OAAO,EACd,MACF,QACQ,MAAA,IAAI,MAAM,oBAAoB,CACxC,CAEJ,CACF,CChSO,MAAMC,WAA4BpM,CAAgB,CACvD,KAAO,OACP,OAAS,OACT,YAAc,gCAEd,QAAQ,CAAE,GAAAX,EAAI,IAAAzD,EAAK,oBAAAoN,GAAyC,CAC1D3J,EAAG,aAAazD,EAAK,GAAGoN,CAAmB,EAAE,CAC/C,CACF,CAEO,MAAMqD,WAAsBpM,CAAW,CAC5C,KAAO,UACP,YAAc,sCACd,OAAS,IAAI,OAAO,+CAA+C,EACnE,SAAS,CAAE,IAAAqM,GAAe,CACxB,MAAO,aAAaA,CAAG,QACzB,CACF,CAEO,MAAMC,WAA2BvM,CAAgB,CACtD,KAAO,MACP,OAAS,MACT,YAAc,gCACd,wBAA0B,GAE1B,QAAQ,CAAE,GAAAX,EAAI,IAAAzD,EAAK,IAAAmN,GAAyB,CAC1CA,EAAInN,EAAKyD,CAAE,CACb,CACF,CAMO,MAAMmN,WAA6BxM,CAAgB,CACxD,KAAO,QACP,OAAS,QACT,YAAc,gCACd,YAAkB,IAAA,IAAI,CAAC,QAAS,WAAY,QAAQ,CAAC,EACrD,oBAAsB,IAAI,IAAI,CAAC8I,EAAqB,CAAC,EACrD,aAAe,CAAC,SAAU,QAAS,SAAS,EAC5C,wBAA0B,GAC1B,iBAAmB,GAEnB,QAAQ,CAAE,GAAAzJ,EAAI,oBAAA2J,EAAqB,OAAAhK,EAAQ,QAAAX,GAA6B,CACtE,GAAI,EAAE,UAAWgB,GAAW,MAAA,IAAI,MAAM,oCAAoC,EAC1E,MAAMR,EAASmK,EACf,GAAI,CAACnK,EAAQ,MAAM,IAAI,MAAM,UAAUmK,CAAmB,YAAY,EACnE3J,EAAA,MAAQ,GAAGR,EAAO,KAAK,GAE1B,MAAM4N,EAAS,IAAM,CACnB,MAAMrQ,EAAUyC,EAAO,MACnB,GAAA,OAAOzC,GAAY,SACdyC,EAAA,MAAQ,OAAOQ,EAAG,KAAK,UACrB,OAAOjD,GAAY,SAC5ByC,EAAO,MAAQQ,EAAG,cACT,OAAOjD,GAAY,UACrByC,EAAA,MAAQ,EAAQQ,EAAG,UAEpB,OAAA,IAAI,MAAM,kBAAkB,CACpC,EAGFL,EAAO,IAAM,CACA,UAAA0N,KAAS,KAAK,aACpBrN,EAAA,iBAAiBqN,EAAOD,CAAM,EAGnCpO,EAAQ,IAAM,CACD,UAAAqO,KAAS,KAAK,aACpBrN,EAAA,oBAAoBqN,EAAOD,CAAM,CACtC,CACD,CAAA,CACF,CACH,CACF,CAEO,MAAME,WAAqC3M,CAAgB,CAChE,KAAO,gBACP,OAAS,KACT,YAAc,gCACd,iBAAuB,IAAA,IAAI,CAAC,UAAW,OAAQ,SAAS,CAAC,EACzD,oBAAsB,CACpB,QAASqJ,EACT,KAAMA,EACN,QAASA,CAAA,EAGX,QAAQ,CAAE,GAAAhK,EAAI,IAAAzD,EAAK,UAAAgG,EAAW,oBAAAoH,EAAqB,OAAAhK,EAAQ,QAAAX,GAA6B,CACtF,MAAMwB,EAAKmJ,EACX,GAAI,CAACnJ,EAAI,MAAM,IAAI,MAAM,YAAYmJ,CAAmB,YAAY,EAEpE,MAAMlL,EAAmC,CAAA,EACrC8D,EAAU,IAAI,SAAS,IAAG9D,EAAQ,QAAU,IAC5C8D,EAAU,IAAI,SAAS,IAAG9D,EAAQ,QAAU,IAC5C8D,EAAU,IAAI,MAAM,IAAG9D,EAAQ,KAAO,IAE1CkB,EAAO,IAAM,CACRK,EAAA,iBAAiBzD,EAAKiE,EAAI/B,CAAO,EACpCO,EAAQ,IAAMgB,EAAG,oBAAoBzD,EAAKiE,EAAI/B,CAAO,CAAC,CAAA,CACvD,CACH,CACF,CAEO,MAAM8O,WAAgC5M,CAAgB,CAC3D,KAAO,WACP,OAAS,OACT,YAAc,sCACd,iBAAmB,GACnB,wBAA0B,GAE1B,QAAQ,CAAE,GAAAX,EAAI,oBAAA2J,GAAyC,CACrD,GAAI,EAAE3J,aAAc,aAAoB,MAAA,IAAI,MAAM,4BAA4B,EAC3EA,EAAA,YAAc,GAAG2J,CAAmB,EACzC,CACF,CClHO,MAAM6D,GAAU,UACVC,GAAO,OACPC,GAAU,UACVC,GAAS,SACTC,GAAa,aACbC,EAAY,YAElB,MAAMC,WAAmBnN,CAAgB,CAC9C,KAAO,OACP,YAAc,kCACd,OAAS,OACT,iBAAmB,IAAI,IAAI,CAACkN,CAAS,CAAC,EACtC,oBAAsB,CAAE,CAACA,CAAS,EAAG7D,GAErC,QAAQ,CAAE,GAAAhK,EAAI,oBAAA2J,EAAqB,UAAApH,GAA+B,CAC1D,MAAAwL,EAAa,CAAC,CAACpE,EAGfqE,EADczL,EAAU,IAAIsL,CAAS,EACZA,EAAY,OAEvCE,EACE/N,EAAG,MAAM,SAAW,GAAKA,EAAG,MAAM,UAAYyN,GAC7CzN,EAAA,MAAM,eAAewN,EAAO,EAE/BxN,EAAG,MAAM,YAAYwN,GAAS,GAAIQ,CAAQ,EAG5ChO,EAAG,MAAM,YAAYwN,GAASC,GAAMO,CAAQ,CAEhD,CACF,CAEO,MAAMC,GAAO,OACPC,GAAO,OACPC,GAAO,OAEb,MAAMC,WAAoCzN,CAAgB,CAC/D,KAAO,eACP,OAASiN,GACT,YAAc,gCACd,oBAAsB7D,GACtB,iBAAuB,IAAA,IAAI,CAACkE,GAAMC,GAAMC,EAAI,CAAC,EAC7C,oBAAsB,CACpB,CAACF,EAAI,EAAGjE,EACR,CAACkE,EAAI,EAAGlE,EACR,CAACmE,EAAI,EAAGnE,CAAA,EAGV,QAAQ,CAAE,UAAAzH,EAAW,GAAAvC,EAAI,IAAA0J,EAAK,OAAA/J,EAAQ,QAAAX,GAA6B,CAC3D,MAAAP,EAAU,CAAE,UAAW,GACzB8D,EAAU,IAAI2L,EAAI,EAAGzP,EAAQ,UAAY,EACpC8D,EAAU,IAAI4L,EAAI,IAAG1P,EAAQ,UAAY,IAElD,MAAMjB,EAAW,IAAI,qBAAsB6Q,GAAY,CAC7CA,EAAA,QAASC,GAAU,CACrBA,EAAM,iBACR5E,EAAIkE,GAAY,EAAI,EAChBrL,EAAU,IAAI0L,EAAI,GACpBzQ,EAAS,WAAW,EAExB,CACD,GACAiB,CAAO,EAEVkB,EAAO,IAAM,CACXnC,EAAS,QAAQwC,CAAE,EAEXhB,EAAA,IAAMxB,EAAS,WAAA,CAAY,CAAA,CACpC,CACH,CACF,CAEO,MAAM+Q,UAAgC5N,CAAgB,CAC3D,KAAO,WACP,OAAS,WACT,YAAc,2CACd,iBAAuB,IAAA,IAAI,CAAC+M,GAASC,EAAM,CAAC,EAC5C,oBAAsB,CACpB,CAACD,EAAO,EAAG1D,EACX,CAAC2D,EAAM,EAAG3D,CAAA,EAEZ,YAAc,IAAI,IAAI,CAAC,UAAU,CAAC,EAClC,OAAO,UAAY,IAAI,MAAM,8DAA8D,EAE3F,QAAQ,CAAE,GAAAhK,EAAI,UAAAuC,EAAW,OAAA5C,EAAQ,oBAAAgK,GAAyC,CACpE,GAAA,EAAE3J,aAAc,qBACZ,MAAA,IAAI,MAAM,4BAA4B,EAG9CL,EAAO,IAAM,CACP,GAAA,OAAOgK,GAAwB,SAC3B,MAAA,IAAI,MAAM,qCAAqC,EAGjD,MAAAmD,EAAS,SAAS,cAAcnD,CAAmB,EACzD,GAAI,CAACmD,EAAQ,MAAM,IAAI,MAAM,6BAA6BnD,CAAmB,EAAE,EAE3E,GAAA,CAAC3J,EAAG,QACA,MAAA,IAAI,MAAM,oCAAoC,EAGtD,MAAMwO,EAAIxO,EAAG,QAAQ,UAAU,EAAI,EAEnC,GADYF,EAAmB0O,CAAY,GAClC,kBAAyB,MAAA,IAAI,MAAM,gBAAgB,EAExD,GAAAjM,EAAU,IAAImL,EAAO,EAAG,CAC1B,GAAI,CAACZ,EAAO,WAAY,MAAMyB,EAAwB,UAC/CzB,EAAA,WAAW,aAAa0B,EAAG1B,CAAM,CAC/B,SAAAvK,EAAU,IAAIoL,EAAM,EAAG,CAChC,GAAI,CAACb,EAAO,WAAY,MAAMyB,EAAwB,UACtDzB,EAAO,WAAW,aAAa0B,EAAG1B,EAAO,WAAW,CAAA,MAEpDA,EAAO,YAAY0B,CAAC,CACtB,CACD,CACH,CACF,CCvFW,IAAI1N,GACb4B,GACA4G,GACA0D,GACAvD,GACAI,GACAC,GACAiD,GACAG,GACAC,GACAG,GACAC,GACAO,GACAM,GACAG,EACA/C,GACAL,GACAC,GACAE,GACAD,GACAE,EACF,EACG,IAAI","x_google_ignoreList":[0,1,2]}