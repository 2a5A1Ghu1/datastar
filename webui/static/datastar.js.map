{"version":3,"file":"datastar.js","sources":["../node_modules/.pnpm/@maverick-js+signals@5.11.4/node_modules/@maverick-js/signals/dist/prod/symbols.js","../node_modules/.pnpm/@maverick-js+signals@5.11.4/node_modules/@maverick-js/signals/dist/prod/core.js","../node_modules/.pnpm/@maverick-js+signals@5.11.4/node_modules/@maverick-js/signals/dist/prod/signals.js","../src/lib/dom.ts","../src/lib/types.ts","../src/lib/core.ts","../src/lib/plugins/actions.ts","../src/lib/external/idiomorph.ts","../src/lib/plugins/reactivity.ts","../src/lib/plugins/shared.ts","../src/lib/plugins/backend.ts","../src/lib/plugins/binding.ts","../src/lib/plugins/visibility.ts","../src/lib/index.ts"],"sourcesContent":["const SCOPE = Symbol(0);\n\nexport { SCOPE };\n","import { SCOPE } from './symbols.js';\n\nlet scheduledEffects = false, runningEffects = false, currentScope = null, currentObserver = null, currentObservers = null, currentObserversIndex = 0, effects = [], defaultContext = {};\nconst NOOP = () => {\n}, STATE_CLEAN = 0, STATE_CHECK = 1, STATE_DIRTY = 2, STATE_DISPOSED = 3;\nfunction flushEffects() {\n  scheduledEffects = true;\n  queueMicrotask(runEffects);\n}\nfunction runEffects() {\n  if (!effects.length) {\n    scheduledEffects = false;\n    return;\n  }\n  runningEffects = true;\n  for (let i = 0; i < effects.length; i++) {\n    if (effects[i].$st !== STATE_CLEAN)\n      runTop(effects[i]);\n  }\n  effects = [];\n  scheduledEffects = false;\n  runningEffects = false;\n}\nfunction runTop(node) {\n  let ancestors = [node];\n  while (node = node[SCOPE]) {\n    if (node.$e && node.$st !== STATE_CLEAN)\n      ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    updateCheck(ancestors[i]);\n  }\n}\nfunction root(init) {\n  const scope = createScope();\n  return compute(scope, !init.length ? init : init.bind(null, dispose.bind(scope)), null);\n}\nfunction peek(fn) {\n  return compute(currentScope, fn, null);\n}\nfunction untrack(fn) {\n  return compute(null, fn, null);\n}\nfunction tick() {\n  if (!runningEffects)\n    runEffects();\n}\nfunction getScope() {\n  return currentScope;\n}\nfunction scoped(run, scope) {\n  try {\n    return compute(scope, run, null);\n  } catch (error) {\n    handleError(scope, error);\n    return;\n  }\n}\nfunction getContext(key, scope = currentScope) {\n  return scope?.$cx[key];\n}\nfunction setContext(key, value, scope = currentScope) {\n  if (scope)\n    scope.$cx = { ...scope.$cx, [key]: value };\n}\nfunction onError(handler) {\n  if (!currentScope)\n    return;\n  currentScope.$eh = currentScope.$eh ? [handler, ...currentScope.$eh] : [handler];\n}\nfunction onDispose(disposable) {\n  if (!disposable || !currentScope)\n    return disposable || NOOP;\n  const node = currentScope;\n  if (!node.$d) {\n    node.$d = disposable;\n  } else if (Array.isArray(node.$d)) {\n    node.$d.push(disposable);\n  } else {\n    node.$d = [node.$d, disposable];\n  }\n  return function removeDispose() {\n    if (node.$st === STATE_DISPOSED)\n      return;\n    disposable.call(null);\n    if (isFunction(node.$d)) {\n      node.$d = null;\n    } else if (Array.isArray(node.$d)) {\n      node.$d.splice(node.$d.indexOf(disposable), 1);\n    }\n  };\n}\nfunction dispose(self = true) {\n  if (this.$st === STATE_DISPOSED)\n    return;\n  let head = self ? this.$ps || this[SCOPE] : this, current = this.$ns, next = null;\n  while (current && current[SCOPE] === this) {\n    dispose.call(current, true);\n    disposeNode(current);\n    next = current.$ns;\n    current.$ns = null;\n    current = next;\n  }\n  if (self)\n    disposeNode(this);\n  if (current)\n    current.$ps = !self ? this : this.$ps;\n  if (head)\n    head.$ns = current;\n}\nfunction disposeNode(node) {\n  node.$st = STATE_DISPOSED;\n  if (node.$d)\n    emptyDisposal(node);\n  if (node.$s)\n    removeSourceObservers(node, 0);\n  if (node.$ps)\n    node.$ps.$ns = null;\n  node[SCOPE] = null;\n  node.$s = null;\n  node.$o = null;\n  node.$ps = null;\n  node.$cx = defaultContext;\n  node.$eh = null;\n}\nfunction emptyDisposal(scope) {\n  try {\n    if (Array.isArray(scope.$d)) {\n      for (let i = scope.$d.length - 1; i >= 0; i--) {\n        const callable = scope.$d[i];\n        callable.call(callable);\n      }\n    } else {\n      scope.$d.call(scope.$d);\n    }\n    scope.$d = null;\n  } catch (error) {\n    handleError(scope, error);\n  }\n}\nfunction compute(scope, compute2, observer) {\n  const prevScope = currentScope, prevObserver = currentObserver;\n  currentScope = scope;\n  currentObserver = observer;\n  try {\n    return compute2.call(scope);\n  } finally {\n    currentScope = prevScope;\n    currentObserver = prevObserver;\n  }\n}\nfunction handleError(scope, error) {\n  if (!scope || !scope.$eh)\n    throw error;\n  let i = 0, len = scope.$eh.length, coercedError = coerceError(error);\n  for (i = 0; i < len; i++) {\n    try {\n      scope.$eh[i](coercedError);\n      break;\n    } catch (error2) {\n      coercedError = coerceError(error2);\n    }\n  }\n  if (i === len)\n    throw coercedError;\n}\nfunction coerceError(error) {\n  return error instanceof Error ? error : Error(JSON.stringify(error));\n}\nfunction read() {\n  if (this.$st === STATE_DISPOSED)\n    return this.$v;\n  if (currentObserver && !this.$e) {\n    if (!currentObservers && currentObserver.$s && currentObserver.$s[currentObserversIndex] == this) {\n      currentObserversIndex++;\n    } else if (!currentObservers)\n      currentObservers = [this];\n    else\n      currentObservers.push(this);\n  }\n  if (this.$c)\n    updateCheck(this);\n  return this.$v;\n}\nfunction write(newValue) {\n  const value = isFunction(newValue) ? newValue(this.$v) : newValue;\n  if (this.$ch(this.$v, value)) {\n    this.$v = value;\n    if (this.$o) {\n      for (let i = 0; i < this.$o.length; i++) {\n        notify(this.$o[i], STATE_DIRTY);\n      }\n    }\n  }\n  return this.$v;\n}\nconst ScopeNode = function Scope() {\n  this[SCOPE] = null;\n  this.$ns = null;\n  this.$ps = null;\n  if (currentScope)\n    currentScope.append(this);\n};\nconst ScopeProto = ScopeNode.prototype;\nScopeProto.$cx = defaultContext;\nScopeProto.$eh = null;\nScopeProto.$c = null;\nScopeProto.$d = null;\nScopeProto.append = function(child) {\n  child[SCOPE] = this;\n  child.$ps = this;\n  if (this.$ns) {\n    if (child.$ns) {\n      let tail = child.$ns;\n      while (tail.$ns)\n        tail = tail.$ns;\n      tail.$ns = this.$ns;\n      this.$ns.$ps = tail;\n    } else {\n      child.$ns = this.$ns;\n      this.$ns.$ps = child;\n    }\n  }\n  this.$ns = child;\n  child.$cx = child.$cx === defaultContext ? this.$cx : { ...this.$cx, ...child.$cx };\n  if (this.$eh) {\n    child.$eh = !child.$eh ? this.$eh : [...child.$eh, ...this.$eh];\n  }\n};\nScopeProto.dispose = function() {\n  dispose.call(this);\n};\nfunction createScope() {\n  return new ScopeNode();\n}\nconst ComputeNode = function Computation(initialValue, compute2, options) {\n  ScopeNode.call(this);\n  this.$st = compute2 ? STATE_DIRTY : STATE_CLEAN;\n  this.$i = false;\n  this.$e = false;\n  this.$s = null;\n  this.$o = null;\n  this.$v = initialValue;\n  if (compute2)\n    this.$c = compute2;\n  if (options && options.dirty)\n    this.$ch = options.dirty;\n};\nconst ComputeProto = ComputeNode.prototype;\nObject.setPrototypeOf(ComputeProto, ScopeProto);\nComputeProto.$ch = isNotEqual;\nComputeProto.call = read;\nfunction createComputation(initialValue, compute2, options) {\n  return new ComputeNode(initialValue, compute2, options);\n}\nfunction isNotEqual(a, b) {\n  return a !== b;\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction updateCheck(node) {\n  if (node.$st === STATE_CHECK) {\n    for (let i = 0; i < node.$s.length; i++) {\n      updateCheck(node.$s[i]);\n      if (node.$st === STATE_DIRTY) {\n        break;\n      }\n    }\n  }\n  if (node.$st === STATE_DIRTY)\n    update(node);\n  else\n    node.$st = STATE_CLEAN;\n}\nfunction cleanup(node) {\n  if (node.$ns && node.$ns[SCOPE] === node)\n    dispose.call(node, false);\n  if (node.$d)\n    emptyDisposal(node);\n  node.$eh = node[SCOPE] ? node[SCOPE].$eh : null;\n}\nfunction update(node) {\n  let prevObservers = currentObservers, prevObserversIndex = currentObserversIndex;\n  currentObservers = null;\n  currentObserversIndex = 0;\n  try {\n    cleanup(node);\n    const result = compute(node, node.$c, node);\n    if (currentObservers) {\n      if (node.$s)\n        removeSourceObservers(node, currentObserversIndex);\n      if (node.$s && currentObserversIndex > 0) {\n        node.$s.length = currentObserversIndex + currentObservers.length;\n        for (let i = 0; i < currentObservers.length; i++) {\n          node.$s[currentObserversIndex + i] = currentObservers[i];\n        }\n      } else {\n        node.$s = currentObservers;\n      }\n      let source;\n      for (let i = currentObserversIndex; i < node.$s.length; i++) {\n        source = node.$s[i];\n        if (!source.$o)\n          source.$o = [node];\n        else\n          source.$o.push(node);\n      }\n    } else if (node.$s && currentObserversIndex < node.$s.length) {\n      removeSourceObservers(node, currentObserversIndex);\n      node.$s.length = currentObserversIndex;\n    }\n    if (!node.$e && node.$i) {\n      write.call(node, result);\n    } else {\n      node.$v = result;\n      node.$i = true;\n    }\n  } catch (error) {\n    handleError(node, error);\n    if (node.$st === STATE_DIRTY) {\n      cleanup(node);\n      if (node.$s)\n        removeSourceObservers(node, 0);\n    }\n    return;\n  }\n  currentObservers = prevObservers;\n  currentObserversIndex = prevObserversIndex;\n  node.$st = STATE_CLEAN;\n}\nfunction notify(node, state) {\n  if (node.$st >= state)\n    return;\n  if (node.$e && node.$st === STATE_CLEAN) {\n    effects.push(node);\n    if (!scheduledEffects)\n      flushEffects();\n  }\n  node.$st = state;\n  if (node.$o) {\n    for (let i = 0; i < node.$o.length; i++) {\n      notify(node.$o[i], STATE_CHECK);\n    }\n  }\n}\nfunction removeSourceObservers(node, index) {\n  let source, swap;\n  for (let i = index; i < node.$s.length; i++) {\n    source = node.$s[i];\n    if (source.$o) {\n      swap = source.$o.indexOf(node);\n      source.$o[swap] = source.$o[source.$o.length - 1];\n      source.$o.pop();\n    }\n  }\n}\n\nexport { compute, createComputation, createScope, dispose, getContext, getScope, isFunction, isNotEqual, onDispose, onError, peek, read, root, scoped, setContext, tick, untrack, update, write };\n","import { createComputation, read, write, isFunction, update, dispose, onDispose } from './core.js';\nimport { SCOPE } from './symbols.js';\n\nfunction signal(initialValue, options) {\n  const node = createComputation(initialValue, null, options), signal2 = read.bind(node);\n  signal2[SCOPE] = true;\n  signal2.set = write.bind(node);\n  return signal2;\n}\nfunction isReadSignal(fn) {\n  return isFunction(fn) && SCOPE in fn;\n}\nfunction computed(compute, options) {\n  const node = createComputation(\n    options?.initial,\n    compute,\n    options\n  ), signal2 = read.bind(node);\n  signal2[SCOPE] = true;\n  return signal2;\n}\nfunction effect(effect2, options) {\n  const signal2 = createComputation(\n    null,\n    function runEffect() {\n      let effectResult = effect2();\n      isFunction(effectResult) && onDispose(effectResult);\n      return null;\n    },\n    void 0\n  );\n  signal2.$e = true;\n  update(signal2);\n  return dispose.bind(signal2, true);\n}\nfunction readonly(signal2) {\n  const readonly2 = () => signal2();\n  readonly2[SCOPE] = true;\n  return readonly2;\n}\nfunction isWriteSignal(fn) {\n  return isReadSignal(fn) && \"set\" in fn;\n}\n\nexport { computed, effect, isReadSignal, isWriteSignal, readonly, signal };\n","import { AttributeContext, HTMLorSVGElement } from './types'\n\nexport function toHTMLorSVGElement(node: Node): HTMLorSVGElement | null {\n  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n    return null\n  }\n  return node\n}\n\nexport function walkDownDOM(el: Element | null, callback: (el: Element) => void) {\n  if (!el) return\n  callback(el)\n\n  el = el.firstElementChild\n\n  while (el) {\n    walkDownDOM(el, callback)\n    el = el.nextElementSibling\n  }\n}\n\nexport function functionGenerator(str: string): Function {\n  const fnContents = `return ${str}`\n  const fn = new Function('ctx', fnContents)\n  return fn\n}\n\nexport function functionEval(ctx: AttributeContext) {\n  const expression = ctx.expressionRaw\n  const fn = functionGenerator(expression)\n  try {\n    ctx.expressionEvaluated = fn(ctx)\n  } catch (e) {\n    console.error(`Error evaluating expression:\\n${expression}`)\n    throw e\n  }\n}\n","import { Dispose, MaybeDisposable, type Effect, type StopEffect } from '@maverick-js/signals'\n\nexport type HTMLorSVGElement = Element & (HTMLElement | SVGElement)\n\nexport type Context = {\n  get<T>(key: string): T | undefined\n  set<T>(key: string, value: T): void\n}\n\nexport abstract class DatastarPlugin {\n  abstract name: string\n  abstract description: string\n  requiredPluginTypes = new Set<typeof DatastarPlugin>()\n}\n\nexport type DatastarPluginConstructor = new () => DatastarPlugin\n\nexport type AttributeContext = Context & {\n  el: Readonly<HTMLorSVGElement>\n  key: Readonly<string>\n  expressionRaw: Readonly<string>\n  expressionEvaluated?: any\n  modifiers: Readonly<Map<string, Readonly<string>[]>>\n  effect: (\n    effect: Effect,\n    options?: {\n      id?: string\n    },\n  ) => StopEffect\n  cleanup: (disposable: MaybeDisposable) => Dispose\n}\n\nexport abstract class AttributePlugin extends DatastarPlugin {\n  abstract prefix: string\n  abstract onMount(ctx: AttributeContext): void\n  onUnmount?(ctx: AttributeContext): void\n  mustHaveEmptyExpression = false\n  mustHaveEmptyKey = false\n  allowedTags?: Set<string>\n  allowedModifiers?: Set<string>\n  allowedModifierArgs?: Record<string, (args: string[]) => boolean>\n}\n\nexport type Groups = Record<string, string>\n\nexport abstract class RunePlugin extends DatastarPlugin {\n  abstract regexp: RegExp\n  abstract replacer(groups: Groups): string\n}\n\nexport abstract class ActionPlugin extends DatastarPlugin {\n  abstract action(ctx: AttributeContext, ...args: any[]): Promise<void>\n}\n","import { effect, getContext, onDispose, root, setContext } from '@maverick-js/signals'\nimport { functionEval, toHTMLorSVGElement, walkDownDOM } from './dom'\nimport {\n  AttributeContext,\n  AttributePlugin,\n  DatastarPlugin,\n  DatastarPluginConstructor,\n  HTMLorSVGElement,\n  RunePlugin,\n} from './types'\n\nexport class Datastar {\n  attributePlugins: AttributePlugin[] = []\n  runePlugins: RunePlugin[] = []\n  attributeObserver: MutationObserver\n\n  constructor(...plugins: DatastarPluginConstructor[]) {\n    if (!plugins.length) throw new Error('No plugins provided')\n\n    this.attributeObserver = new MutationObserver((mutations) => {\n      for (const m of mutations) {\n        if (m.type === 'attributes') {\n          const el = toHTMLorSVGElement(m.target)\n          if (!el) return\n\n          // Old\n          this.handleAttributePlugin(el, (p, ctx) => {\n            p.onUnmount?.(ctx)\n            p.onMount(ctx)\n          })\n        } else {\n          m.removedNodes.forEach((node) => {\n            const el = toHTMLorSVGElement(node)\n            if (!el) return\n\n            this.handleAttributePlugin(el, (p, ctx) => {\n              p.onUnmount?.(ctx)\n            })\n          })\n        }\n      }\n    })\n\n    this.attributeObserver.observe(document.body, {\n      attributes: true,\n      attributeOldValue: true,\n      subtree: true,\n      childList: true,\n    })\n\n    const allPlugins: DatastarPlugin[] = []\n    for (const Plugin of plugins) {\n      const p = new Plugin()\n\n      p.requiredPluginTypes.forEach((requiredPluginType) => {\n        const requiredPlugin = allPlugins.find((plugin) => plugin instanceof requiredPluginType)\n        if (!requiredPlugin) {\n          throw new Error(`Plugin \"${p.name}\" requires plugin \"${requiredPluginType.name}\"`)\n        }\n\n        if (p instanceof AttributePlugin) {\n          if (p.allowedTags) {\n            p.allowedTags = new Set([...p.allowedTags].map((t) => t.toLowerCase()))\n          }\n          this.attributePlugins.push(p)\n        } else if (p instanceof RunePlugin) {\n          this.runePlugins.push(p)\n        } else {\n          throw new Error(`Unknown plugin type`)\n        }\n\n        allPlugins.push(p)\n      })\n    }\n  }\n\n  run() {\n    walkDownDOM(document.body, (element) => {\n      const el = toHTMLorSVGElement(element)\n      if (!el) return\n\n      let hasAttributePlugin = false\n      const reactiveRootDisposal = root((dispose) => {\n        this.handleAttributePlugin(el, (p, ctx) => {\n          p.onMount(ctx)\n          hasAttributePlugin = true\n        })\n\n        return dispose\n      })\n\n      if (!hasAttributePlugin) reactiveRootDisposal()\n    })\n  }\n\n  private handleAttributePlugin(el: HTMLorSVGElement, cb: (p: AttributePlugin, ctx: AttributeContext) => void) {\n    this.attributePlugins.forEach((p) => {\n      if (p.allowedTags) {\n        const elTagLower = el.tagName.toLowerCase()\n        if (!p.allowedTags.has(elTagLower)) return\n      }\n\n      const fullPrefix = `data-${p.prefix}`\n\n      for (const attr of el.attributes) {\n        if (!attr.name.startsWith(fullPrefix)) continue\n\n        let keyRaw = attr.name.slice(fullPrefix.length)\n        if (keyRaw.startsWith('-')) keyRaw = keyRaw.slice(1)\n\n        const [key, ...modifiersWithArgsArr] = keyRaw.split('.')\n\n        if (p.mustHaveEmptyKey && key.length > 0) {\n          throw new Error(`Attribute '${attr.name}' must have empty key`)\n        }\n\n        const modifiersArr = modifiersWithArgsArr.map((m) => {\n          const [label, ...args] = m.split('_')\n          return { label, args }\n        })\n        const expressionRaw = attr.value\n\n        if (p.mustHaveEmptyExpression && expressionRaw?.length > 0) {\n          throw new Error(`Attribute '${attr.name}' must have empty expression`)\n        }\n\n        if (p.allowedModifiers) {\n          for (const modifier of modifiersArr) {\n            if (!p.allowedModifiers.has(modifier.label)) {\n              throw new Error(`Modifier '${modifier.label}' is not allowed`)\n            }\n\n            if (p.allowedModifierArgs) {\n              const allowedArgs = p.allowedModifierArgs[modifier.label]\n              if (allowedArgs) {\n                if (!allowedArgs(modifier.args)) {\n                  throw new Error(`Modifier '${modifier.label}' arguments are not allowed`)\n                }\n              }\n            }\n          }\n        }\n\n        const modifiers = new Map<string, string[]>()\n        for (const modifier of modifiersArr) {\n          modifiers.set(modifier.label, modifier.args)\n        }\n\n        const ctx: AttributeContext = {\n          get(k: string) {\n            return getContext(k)\n          },\n          set(k, v) {\n            setContext(k, v)\n          },\n          el,\n          key,\n          expressionRaw,\n          modifiers,\n          effect,\n          cleanup: onDispose,\n        }\n\n        ctx.expressionEvaluated = functionEval(ctx)\n\n        cb(p, ctx)\n      }\n    })\n  }\n}\n","import { Groups, RunePlugin } from '../types'\n\nexport class ActionRunePlugin extends RunePlugin {\n  name = 'ActionRune'\n  description = 'A action rune'\n  regexp = new RegExp(/(?<whole>@(?<action>[a-zA-Z_$][0-9a-zA-Z_$]*)(?<call>\\((?<args>.*)\\))?)/g)\n  replacer({ action, args }: Groups) {\n    return `get('${action}')(ctx, ${args || ''})`\n  }\n}\n","const generatedByIdiomorphId = new WeakSet()\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function idiomorph(oldNode: Document | Element, newContent: string | Element, config = {}) {\n  if (oldNode instanceof Document) {\n    oldNode = oldNode.documentElement\n  }\n\n  let parsedContent: Element\n  if (typeof newContent === 'string') {\n    parsedContent = parseContent(newContent) as Element\n  } else {\n    parsedContent = newContent\n  }\n\n  const normalizedContent = normalizeContent(parsedContent)\n  const ctx = createMorphContext(oldNode, normalizedContent, config)\n\n  return morphNormalizedContent(oldNode, normalizedContent, ctx)\n}\n\nfunction morphNormalizedContent(oldNode: Element, normalizedNewContent: Element, ctx: any) {\n  if (ctx.head.block) {\n    const oldHead = oldNode.querySelector('head')\n    const newHead = normalizedNewContent.querySelector('head')\n    if (oldHead && newHead) {\n      const promises = handleHeadElement(newHead, oldHead, ctx)\n      // when head promises resolve, call morph again, ignoring the head tag\n      Promise.all(promises).then(() => {\n        morphNormalizedContent(\n          oldNode,\n          normalizedNewContent,\n          Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          }),\n        )\n      })\n      return\n    }\n  }\n\n  if (ctx.morphStyle === 'innerHTML') {\n    // innerHTML, so we are only updating the children\n    morphChildren(normalizedNewContent, oldNode, ctx)\n    return oldNode.children\n  } else if (ctx.morphStyle === 'outerHTML' || ctx.morphStyle == null) {\n    // otherwise find the best element match in the new content, morph that, and merge its siblings\n    // into either side of the best match\n    const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx)\n    if (!bestMatch) throw new Error('Could not find best match')\n\n    // stash the siblings that will need to be inserted on either side of the best match\n    const previousSibling = bestMatch?.previousSibling as Element\n    const nextSibling = bestMatch?.nextSibling as Element\n\n    // morph it\n    const morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx)\n\n    if (bestMatch) {\n      // if there was a best match, merge the siblings in too and return the\n      // whole bunch\n      return insertSiblings(previousSibling, morphedNode, nextSibling)\n    } else {\n      // otherwise nothing was added to the DOM\n      return []\n    }\n  } else {\n    throw 'Do not understand how to morph style ' + ctx.morphStyle\n  }\n}\n\n/**\n * @param oldNode root node to merge content into\n * @param newContent new content to merge\n * @param ctx the merge context\n * @returns {Element} the element that ended up in the DOM\n */\nfunction morphOldNodeTo(oldNode: Element, newContent: Element, ctx: any) {\n  if (ctx.ignoreActive && oldNode === document.activeElement) {\n    // don't morph focused element\n  } else if (newContent == null) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n\n    oldNode.remove()\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return\n  } else if (!isSoftMatch(oldNode, newContent)) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n    if (ctx.callbacks.beforeNodeAdded(newContent) === false) return\n\n    if (!oldNode.parentElement) throw new Error('oldNode has no parentElement')\n    oldNode.parentElement.replaceChild(newContent, oldNode)\n    ctx.callbacks.afterNodeAdded(newContent)\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return newContent\n  } else {\n    if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return\n\n    if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n      // ignore the head element\n    } else if (\n      newContent instanceof HTMLHeadElement &&\n      oldNode instanceof HTMLHeadElement &&\n      ctx.head.style !== 'morph'\n    ) {\n      handleHeadElement(newContent, oldNode, ctx)\n    } else {\n      syncNodeFrom(newContent, oldNode)\n      morphChildren(newContent, oldNode, ctx)\n    }\n    ctx.callbacks.afterNodeMorphed(oldNode, newContent)\n    return oldNode\n  }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n * @param {Element} newParent the parent element of the new content\n * @param {Element } oldParent the old content that we are merging the new content into\n * @param ctx the merge context\n */\nfunction morphChildren(newParent: Element, oldParent: Element, ctx: any) {\n  let nextNewChild = newParent.firstChild as Element | null\n  let insertionPoint = oldParent.firstChild as Element | null\n  let newChild\n\n  // run through all the new content\n  while (nextNewChild) {\n    newChild = nextNewChild\n    nextNewChild = newChild.nextSibling as Element | null\n\n    // if we are at the end of the exiting parent's children, just append\n    if (insertionPoint == null) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n      oldParent.appendChild(newChild)\n      ctx.callbacks.afterNodeAdded(newChild)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // if the current node has an id set match then morph\n    if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n      morphOldNodeTo(insertionPoint, newChild, ctx)\n      insertionPoint = insertionPoint.nextSibling as Element | null\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // otherwise search forward in the existing old children for an id set match\n    let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx)\n\n    // if we found a potential match, remove the nodes until that point and morph\n    if (idSetMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx)\n      morphOldNodeTo(idSetMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // no id set match found, so scan forward for a soft match for the current node\n    let softMatch = findSoftMatch(newParent, newChild, insertionPoint, ctx)\n\n    // if we found a soft match for the current node, morph\n    if (softMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx)\n      morphOldNodeTo(softMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // abandon all hope of morphing, just insert the new child before the insertion point\n    // and move on\n    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n    oldParent.insertBefore(newChild, insertionPoint)\n    ctx.callbacks.afterNodeAdded(newChild)\n    removeIdsFromConsideration(ctx, newChild)\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint !== null) {\n    let tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling as Element | null\n    removeNode(tempNode, ctx)\n  }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\n/**\n * syncs a given node with another node, copying over all attributes and\n * inner element state from the 'from' node to the 'to' node\n *\n * @param {Element} from the element to copy attributes & state from\n * @param {Element} to the element to copy attributes & state to\n */\nfunction syncNodeFrom(from: Element, to: Element) {\n  let type = from.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    for (const fromAttribute of from.attributes) {\n      const toAttribute = to.getAttribute(fromAttribute.name)\n      if (toAttribute !== fromAttribute.value) {\n        to.setAttribute(fromAttribute.name, fromAttribute.value)\n      }\n    }\n    for (const toAttribute of to.attributes) {\n      if (!from.hasAttribute(toAttribute.name)) {\n        to.removeAttribute(toAttribute.name)\n      }\n    }\n  }\n\n  // sync text nodes\n  if (type === Node.COMMENT_NODE || type === Node.TEXT_NODE) {\n    if (to.nodeValue !== from.nodeValue) {\n      to.nodeValue = from.nodeValue\n    }\n  }\n\n  // NB: many bothans died to bring us information:\n  //\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  // https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n\n  // sync input value\n  if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== 'file') {\n    to.value = from.value || ''\n    syncAttribute(from, to, 'value')\n\n    // sync boolean attributes\n    syncAttribute(from, to, 'checked')\n    syncAttribute(from, to, 'disabled')\n  } else if (from instanceof HTMLOptionElement) {\n    syncAttribute(from, to, 'selected')\n  } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n    const fromValue = from.value\n    const toValue = to.value\n    if (fromValue !== toValue) {\n      to.value = fromValue\n    }\n    if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n      to.firstChild.nodeValue = fromValue\n    }\n  }\n}\n\nfunction syncAttribute(from: Element, to: Element, attributeName: string) {\n  const fAttr = from.getAttribute(attributeName)\n  const tAttr = to.getAttribute(attributeName)\n\n  if (fAttr !== tAttr) {\n    if (fAttr) {\n      to.setAttribute(attributeName, fAttr)\n    } else {\n      to.removeAttribute(attributeName)\n    }\n  }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(newHeadTag: HTMLHeadElement, currentHead: HTMLHeadElement, ctx: any) {\n  const added = []\n  const removed = []\n  const preserved = []\n  const nodesToAppend = []\n\n  const headMergeStyle = ctx.head.style\n\n  // put all new head elements into a Map, by their outerHTML\n  const srcToNewHeadNodes = new Map()\n  for (const newHeadChild of newHeadTag.children) {\n    srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild)\n  }\n\n  // for each elt in the current head\n  for (const currentHeadElt of currentHead.children) {\n    // If the current head element is in the map\n    let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML)\n    let isReAppended = ctx.head.shouldReAppend(currentHeadElt)\n    let isPreserved = ctx.head.shouldPreserve(currentHeadElt)\n    if (inNewContent || isPreserved) {\n      if (isReAppended) {\n        // remove the current version and let the new version replace it and re-execute\n        removed.push(currentHeadElt)\n      } else {\n        // this element already exists and should not be re-appended, so remove it from\n        // the new content map, preserving it in the DOM\n        srcToNewHeadNodes.delete(currentHeadElt.outerHTML)\n        preserved.push(currentHeadElt)\n      }\n    } else {\n      if (headMergeStyle === 'append') {\n        // we are appending and this existing element is not new content\n        // so if and only if it is marked for re-append do we do anything\n        if (isReAppended) {\n          removed.push(currentHeadElt)\n          nodesToAppend.push(currentHeadElt)\n        }\n      } else {\n        // if this is a merge, we remove this content since it is not in the new head\n        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n          removed.push(currentHeadElt)\n        }\n      }\n    }\n  }\n\n  // Push the remaining new head elements in the Map into the\n  // nodes to append to the head tag\n  nodesToAppend.push(...srcToNewHeadNodes.values())\n  console.log('to append: ', nodesToAppend)\n\n  const promises = []\n  for (const newNode of nodesToAppend) {\n    console.log('adding: ', newNode)\n    const newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild as Element | null\n    if (!newElt) throw new Error('could not create new element from: ' + newNode.outerHTML)\n    console.log(newElt)\n    if (!!ctx.callbacks.beforeNodeAdded(newElt)) {\n      if (newElt.hasAttribute('href') || newElt.hasAttribute('src')) {\n        let resolver: (value: unknown) => void\n        const promise = new Promise((resolve) => {\n          resolver = resolve\n        })\n        newElt.addEventListener('load', function () {\n          resolver(undefined)\n        })\n        promises.push(promise)\n      }\n      currentHead.appendChild(newElt)\n      ctx.callbacks.afterNodeAdded(newElt)\n      added.push(newElt)\n    }\n  }\n\n  // remove all removed elements, after we have appended the new elements to avoid\n  // additional network requests for things like style sheets\n  for (const removedElement of removed) {\n    if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n      currentHead.removeChild(removedElement)\n      ctx.callbacks.afterNodeRemoved(removedElement)\n    }\n  }\n\n  ctx.head.afterHeadMorphed(currentHead, {\n    added: added,\n    kept: preserved,\n    removed: removed,\n  })\n  return promises\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\nfunction noOp() {}\n\nfunction createMorphContext(oldNode: Element, newContent: Element, config: any) {\n  return {\n    target: oldNode,\n    newContent: newContent,\n    config: config,\n    morphStyle: config.morphStyle,\n    ignoreActive: config.ignoreActive,\n    idMap: createIdMap(oldNode, newContent),\n    deadIds: new Set(),\n    callbacks: Object.assign(\n      {\n        beforeNodeAdded: noOp,\n        afterNodeAdded: noOp,\n        beforeNodeMorphed: noOp,\n        afterNodeMorphed: noOp,\n        beforeNodeRemoved: noOp,\n        afterNodeRemoved: noOp,\n      },\n      config.callbacks,\n    ),\n    head: Object.assign(\n      {\n        style: 'merge',\n        shouldPreserve: (elt: Element) => elt.getAttribute('im-preserve') === 'true',\n        shouldReAppend: (elt: Element) => elt.getAttribute('im-re-append') === 'true',\n        shouldRemove: noOp,\n        afterHeadMorphed: noOp,\n      },\n      config.head,\n    ),\n  }\n}\n\nfunction isIdSetMatch(node1: Element, node2: Element, ctx: any) {\n  if (!node1 || !node2) return false\n\n  if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n    if (node1?.id?.length && node1.id === node2.id) return true\n\n    return getIdIntersectionCount(ctx, node1, node2) > 0\n  }\n  return false\n}\n\nfunction isSoftMatch(node1: Element, node2: Element) {\n  if (!node1 || !node2) return false\n\n  return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n}\n\nfunction removeNodesBetween(startInclusive: Element, endExclusive: Element, ctx: any) {\n  while (startInclusive !== endExclusive) {\n    const tempNode = startInclusive\n    startInclusive = startInclusive?.nextSibling as Element\n    if (!tempNode) throw new Error('tempNode is null')\n    removeNode(tempNode, ctx)\n  }\n  removeIdsFromConsideration(ctx, endExclusive)\n  return endExclusive.nextSibling as Element | null\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(newContent: Element, oldParent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  // max id matches we are willing to discard in our search\n  const newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent)\n\n  let potentialMatch: Element | null = null\n\n  // only search forward if there is a possibility of an id match\n  if (newChildPotentialIdCount > 0) {\n    potentialMatch = insertionPoint\n    // if there is a possibility of an id match, scan forward\n    // keep track of the potential id match count we are discarding (the\n    // newChildPotentialIdCount must be greater than this to make it likely\n    // worth it)\n    let otherMatchCount = 0\n    while (potentialMatch != null) {\n      // If we have an id match, return the current potential match\n      if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n        return potentialMatch\n      }\n\n      // computer the other potential matches of this new content\n      otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent)\n      if (otherMatchCount > newChildPotentialIdCount) {\n        // if we have more potential id matches in _other_ content, we\n        // do not have a good candidate for an id match, so return null\n        return null\n      }\n\n      // advanced to the next old content child\n      potentialMatch = potentialMatch.nextSibling as Element | null\n    }\n  }\n  return potentialMatch\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(newContent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  let potentialSoftMatch = insertionPoint as Element | null\n  let nextSibling = newChild.nextSibling as Element | null\n\n  let siblingSoftMatchCount = 0\n\n  while (potentialSoftMatch && nextSibling) {\n    if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n      // the current potential soft match has a potential id set match with the remaining new\n      // content so bail out of looking\n      return null\n    }\n\n    // if we have a soft match with the current node, return it\n    if (isSoftMatch(newChild, potentialSoftMatch)) {\n      return potentialSoftMatch\n    }\n\n    if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n      // the next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling as Element | null\n\n      // If there are two future soft matches, bail to allow the siblings to soft match\n      // so that we don't consume future soft matches for the sake of the current node\n      if (siblingSoftMatchCount >= 2) {\n        return null\n      }\n    }\n\n    // advanced to the next old content child\n    potentialSoftMatch = potentialSoftMatch.nextSibling as Element | null\n  }\n\n  return potentialSoftMatch\n}\n\nconst parser = new DOMParser()\nfunction parseContent(newContent: string) {\n  // remove svgs to avoid false-positive matches on head, etc.\n  const contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '')\n\n  // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n  if (\n    contentWithSvgsRemoved.match(/<\\/html>/) ||\n    contentWithSvgsRemoved.match(/<\\/head>/) ||\n    contentWithSvgsRemoved.match(/<\\/body>/)\n  ) {\n    const content = parser.parseFromString(newContent, 'text/html')\n    // if it is a full HTML document, return the document itself as the parent container\n    if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n      generatedByIdiomorphId.add(content)\n      return content\n    } else {\n      // otherwise return the html element as the parent container\n      let Element = content.firstChild\n      if (Element) {\n        generatedByIdiomorphId.add(Element)\n        return Element as Element\n      } else {\n        return null\n      }\n    }\n  } else {\n    // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n    // deal with touchy tags like tr, tbody, etc.\n    const responseDoc = parser.parseFromString(`<body><template>${newContent}</template></body>`, 'text/html')\n    const content = responseDoc.body.querySelector('template')?.content\n    if (!content) throw new Error('content is null')\n    generatedByIdiomorphId.add(content)\n    return content\n  }\n}\n\nfunction normalizeContent(newContent: Element) {\n  if (newContent == null) {\n    // noinspection UnnecessaryLocalVariableJS\n    const dummyParent = document.createElement('div')\n    return dummyParent\n  } else if (generatedByIdiomorphId.has(newContent)) {\n    // the template tag created by idiomorph parsing can serve as a dummy parent\n    return newContent\n  } else if (newContent instanceof Node) {\n    // a single node is added as a child to a dummy parent\n    const dummyParent = document.createElement('div')\n    dummyParent.append(newContent)\n    return dummyParent\n  } else {\n    // all nodes in the array or Element collection are consolidated under\n    // a single dummy parent element\n    const dummyParent = document.createElement('div')\n    for (const elt of [...newContent]) {\n      dummyParent.append(elt)\n    }\n    return dummyParent\n  }\n}\n\nfunction insertSiblings(previousSibling?: Element, morphedNode?: Element, nextSibling?: Element) {\n  const stack = []\n  const added = []\n  while (previousSibling) {\n    stack.push(previousSibling)\n    previousSibling = previousSibling.previousSibling as Element\n  }\n  while (stack.length > 0) {\n    const node = stack.pop()!\n    added.push(node) // push added preceding siblings on in order and insert\n    morphedNode?.parentElement?.insertBefore(node, morphedNode)\n  }\n  added.push(morphedNode)\n  while (nextSibling) {\n    stack.push(nextSibling)\n    added.push(nextSibling) // here we are going in order, so push on as we scan, rather than add\n    nextSibling = nextSibling.nextSibling as Element\n  }\n  while (stack.length) {\n    morphedNode?.parentElement?.insertBefore(stack.pop()!, morphedNode.nextSibling)\n  }\n  return added\n}\n\nfunction findBestNodeMatch(newContent: Element, oldNode: Element, ctx: any) {\n  let currentElement = newContent.firstChild as Element | null\n  let bestElement = currentElement\n  let score = 0\n  while (currentElement) {\n    let newScore = scoreElement(currentElement, oldNode, ctx)\n    if (newScore > score) {\n      bestElement = currentElement\n      score = newScore\n    }\n    currentElement = currentElement.nextSibling as Element | null\n  }\n  return bestElement\n}\n\nfunction scoreElement(node1: Element, node2: Element, ctx: any) {\n  if (isSoftMatch(node1, node2)) {\n    return 0.5 + getIdIntersectionCount(ctx, node1, node2)\n  }\n  return 0\n}\n\nfunction removeNode(tempNode: Element, ctx: any) {\n  removeIdsFromConsideration(ctx, tempNode)\n  if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return\n\n  tempNode.remove()\n  ctx.callbacks.afterNodeRemoved(tempNode)\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: any, id: string) {\n  return !ctx.deadIds.has(id)\n}\n\nfunction idIsWithinNode(ctx: any, id: string, targetNode: Element) {\n  return ctx.idMap.get(targetNode)?.has(id) || false\n}\n\nfunction removeIdsFromConsideration(ctx: any, node: Element) {\n  const idSet = ctx.idMap.get(node)\n  if (!idSet) return\n  for (const id of idSet) {\n    ctx.deadIds.add(id)\n  }\n}\n\nfunction getIdIntersectionCount(ctx: any, node1: Element, node2: Element) {\n  const sourceSet = ctx.idMap.get(node1)\n  if (!sourceSet) return 0\n\n  let matchCount = 0\n  for (const id of sourceSet) {\n    // a potential match is an id in the source and potentialIdsSet, but\n    // that has not already been merged into the DOM\n    if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n      ++matchCount\n    }\n  }\n  return matchCount\n}\n\n/**\n * A bottom up algorithm that finds all elements with ids inside of the node\n * argument and populates id sets for those nodes and all their parents, generating\n * a set of ids contained within all nodes for the entire hierarchy in the DOM\n *\n * @param node {Element}\n * @param {Map<Node, Set<String>>} idMap\n */\nfunction populateIdMapForNode(node: Element, idMap: Map<Element, Set<string>>) {\n  const nodeParent = node.parentElement\n  // find all elements with an id property\n  const idElements = node.querySelectorAll('[id]')\n  for (const elt of idElements) {\n    let current = elt as Element | null\n    // walk up the parent hierarchy of that element, adding the id\n    // of element to the parent's id set\n    while (current !== nodeParent && !!current) {\n      let idSet = idMap.get(current)\n      // if the id set doesn't exist, create it and insert it in the  map\n      if (idSet == null) {\n        idSet = new Set()\n        idMap.set(current, idSet)\n      }\n      idSet.add(elt.id)\n      current = current.parentElement\n    }\n  }\n}\n\n/**\n * This function computes a map of nodes to all ids contained within that node (inclusive of the\n * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n * to contribute to a parent nodes matching.\n *\n * @param {Element} oldContent  the old content that will be morphed\n * @param {Element} newContent  the new content to morph to\n * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n */\nfunction createIdMap(oldContent: Element, newContent: Element) {\n  const idMap = new Map()\n  populateIdMapForNode(oldContent, idMap)\n  populateIdMapForNode(newContent, idMap)\n  return idMap\n}\n","import { computed, effect, signal, type ReadSignal, type WriteSignal } from '@maverick-js/signals'\nimport { AttributeContext, AttributePlugin, Groups, RunePlugin } from '../types'\n\nexport class ReactivityRunePlugin extends RunePlugin {\n  name = 'ReactivityRune'\n  description = 'A reactivity rune'\n  regexp = new RegExp(/(?<whole>\\$(?<signal>[a-zA-Z_$][0-9a-zA-Z_$]*))/g)\n  replacer(groups: Groups) {\n    const { signal } = groups\n    return `get(${signal}).value`\n  }\n}\n\nexport class Signal<T> {\n  private val: WriteSignal<T>\n  constructor(value: T) {\n    this.val = signal(value)\n  }\n\n  get value() {\n    return this.val()\n  }\n\n  set value(v: T) {\n    this.val.set(v)\n  }\n}\n\nexport class SignalAttributePlugin extends AttributePlugin {\n  name = 'Signal'\n  description = 'A signal attribute'\n  prefix = 'signal'\n\n  onMount({ key, set, expressionEvaluated }: AttributeContext) {\n    set(key, new Signal(expressionEvaluated))\n  }\n}\n\nexport class Computed<T> {\n  private val: ReadSignal<T>\n  constructor(value: () => T) {\n    this.val = computed(value)\n  }\n\n  get value() {\n    return this.val()\n  }\n}\n\nexport class ComputedAttributePlugin extends AttributePlugin {\n  name = 'Computed'\n  description = 'A computed attribute'\n  prefix = 'computed'\n\n  onMount({ key, set, expressionEvaluated }: AttributeContext) {\n    set(key, new Computed(expressionEvaluated))\n  }\n}\n\nexport class EffectAttributePlugin extends AttributePlugin {\n  name = 'Effect'\n  description = 'An effect attribute'\n  prefix = 'effect'\n\n  onMount({ key, set, expressionEvaluated }: AttributeContext) {\n    if (typeof expressionEvaluated !== 'function') {\n      throw new Error('Effect attribute must be a function')\n    }\n\n    set(key, effect(expressionEvaluated))\n  }\n}\n\nexport const reactivityPlugins = new Set([\n  ReactivityRunePlugin,\n  SignalAttributePlugin,\n  ComputedAttributePlugin,\n  EffectAttributePlugin,\n])\n","export const noArgs = (args: string[]) => args.length === 0\n","import { toHTMLorSVGElement } from '../dom'\nimport { idiomorph } from '../external/idiomorph'\nimport { ActionPlugin, AttributeContext, AttributePlugin, HTMLorSVGElement } from '../types'\n\nimport { Signal, reactivityPlugins } from './reactivity'\nimport { noArgs } from './shared'\n\nexport const SELECTOR = 'selector'\nexport const SWAP = 'swap'\nexport const REQ_HEADERS_CTX_KEY = 'reqHeaders'\n\nexport class FetchRequestHeadersPlugin extends AttributePlugin {\n  name = 'FetchRequestHeaders'\n  prefix = 'header'\n  description = 'Sets the headers of the fetch request'\n  mustHaveEmptyKey = true\n\n  onMount({ key, get, set, expressionEvaluated }: AttributeContext) {\n    let headers: Headers | undefined = get(REQ_HEADERS_CTX_KEY)\n\n    if (!headers) {\n      headers = new Headers()\n    }\n\n    headers.set(key, expressionEvaluated)\n    set(REQ_HEADERS_CTX_KEY, headers)\n  }\n}\n\nexport const GET = 'get'\nexport const POST = 'post'\nexport const PUT = 'put'\nexport const PATCH = 'patch'\nexport const DELETE = 'delete'\n\nconst DATASTAR_CLASS_PREFIX = 'datastar'\nconst INDICATOR_CLASS = `${DATASTAR_CLASS_PREFIX}-indicator`\nconst LOADING_CLASS = `${DATASTAR_CLASS_PREFIX}-request`\n\ntype Method = typeof GET | typeof POST | typeof PUT | typeof PATCH | typeof DELETE\n\nabstract class FetchAction extends ActionPlugin {\n  static hasInjectedStyles = false\n  name: string\n  description: string\n\n  constructor(public readonly method: Method) {\n    super()\n    this.name = `Fetch${method}`\n    this.description = `fetches fragments from the server using ${method}`\n    this.requiredPluginTypes = new Set([FetchRequestHeadersPlugin, ...reactivityPlugins])\n\n    if (!FetchAction.hasInjectedStyles) {\n      const style = document.createElement('style')\n      style.innerHTML = `\n.${INDICATOR_CLASS}{\n  opacity:0;\n  transition: opacity 500ms ease-in;\n}\n.${LOADING_CLASS} .${INDICATOR_CLASS}{\n    opacity:1\n}\n.${LOADING_CLASS}.${INDICATOR_CLASS}{\n    opacity:1\n}\n    `\n      document.head.appendChild(style)\n      FetchAction.hasInjectedStyles = true\n    }\n  }\n\n  async action(ctx: AttributeContext) {\n    await fetcher(this.method, ctx)\n  }\n}\n\nexport class FetchGetActionPlugin extends FetchAction {\n  constructor() {\n    super(GET)\n  }\n}\n\nexport class FetchPostActionPlugin extends FetchAction {\n  constructor() {\n    super(POST)\n  }\n}\n\nexport class FetchPutActionPlugin extends FetchAction {\n  constructor() {\n    super(PUT)\n  }\n}\n\nexport class FetchPatchActionPlugin extends FetchAction {\n  constructor() {\n    super(PATCH)\n  }\n}\n\nexport class FetchDeleteActionPlugin extends FetchAction {\n  constructor() {\n    super(DELETE)\n  }\n}\n\nexport class FetchAttributePlugin extends AttributePlugin {\n  name = 'Fetch'\n  prefix = 'fetch'\n  description = 'URL to fetch from'\n  allowedModifiers = new Set([GET, POST, PUT, PATCH, DELETE])\n  allowedModifierArgs = {\n    [GET]: noArgs,\n    [POST]: noArgs,\n    [PUT]: noArgs,\n    [PATCH]: noArgs,\n    [DELETE]: noArgs,\n  }\n  mustHaveEmptyKey = true\n\n  onMount({ expressionEvaluated, modifiers, set }: AttributeContext): void {\n    if (typeof expressionEvaluated !== 'string') throw new Error('expressionEvaluated must be a string')\n\n    if (modifiers.has(POST)) {\n      set(POST, expressionEvaluated)\n    } else if (modifiers.has(PUT)) {\n      set(PUT, expressionEvaluated)\n    } else if (modifiers.has(PATCH)) {\n      set(PATCH, expressionEvaluated)\n    } else if (modifiers.has(DELETE)) {\n      set(DELETE, expressionEvaluated)\n    } else {\n      set(GET, expressionEvaluated)\n    }\n  }\n\n  onUnmount({ set, modifiers }: AttributeContext): void {\n    if (modifiers.has(POST)) {\n      set(POST, undefined)\n    } else if (modifiers.has(PUT)) {\n      set(PUT, undefined)\n    } else if (modifiers.has(PATCH)) {\n      set(PATCH, undefined)\n    } else if (modifiers.has(DELETE)) {\n      set(DELETE, undefined)\n    } else {\n      set(GET, undefined)\n    }\n  }\n}\n\nexport class ServerSentEventsAttributePlugin extends AttributePlugin {\n  name = 'ServerSentEvents'\n  prefix = 'sse'\n  description = 'Sets the value of the element'\n  mustHaveEmptyKey = true\n  eventSources = new Map<HTMLorSVGElement, EventSource>()\n\n  onMount({ el, key, expressionEvaluated, effect, cleanup }: AttributeContext) {\n    const isString = typeof expressionEvaluated === 'string'\n\n    const addEventListeners = (eventSource: EventSource) => {\n      eventSource.addEventListener('message', (evt) => {\n        mergeHTMLFragments(el, evt.data)\n      })\n      eventSource.addEventListener('error', (evt) => {\n        console.error('SSE error', evt)\n      })\n    }\n\n    if (isString) {\n      const eventSource = new EventSource(key)\n      addEventListeners(eventSource)\n      this.eventSources.set(el, eventSource)\n    } else {\n      const isSignal = expressionEvaluated instanceof Signal\n      if (!isSignal) throw new Error(`Signal ${expressionEvaluated} not found`)\n\n      const eventSource = new EventSource(expressionEvaluated.value)\n      effect(() => {\n        addEventListeners(eventSource)\n        cleanup(() => eventSource.close())\n      })\n    }\n  }\n\n  onUnmount({ el }: AttributeContext): void {\n    const eventSource = this.eventSources.get(el)\n    if (eventSource) {\n      eventSource.close()\n    }\n  }\n}\n\nexport const ACCEPT = 'Accept'\nexport const CONTENT_TYPE = 'Content-Type'\nexport const TEXT_HTML = 'text/html'\nexport const APPLICATION_JSON = 'application/json'\n\nasync function fetcher(method: Method, { el, get, expressionEvaluated }: AttributeContext) {\n  const urlSignal = get(method)\n  if (!urlSignal) throw new Error(`No url for ${method}`)\n\n  el.classList.add(LOADING_CLASS)\n\n  const headers = new Headers()\n  headers.append(ACCEPT, TEXT_HTML)\n  headers.append(CONTENT_TYPE, APPLICATION_JSON)\n\n  const ctxHeaders = get(REQ_HEADERS_CTX_KEY) as Headers\n  if (ctxHeaders) {\n    for (const [name, value] of ctxHeaders.entries()) {\n      headers.append(name, value)\n    }\n  }\n\n  const url = new URL(expressionEvaluated, window.location.origin)\n  const dataStack = {}\n  const dataStackJSON = JSON.stringify(dataStack)\n  const req: RequestInit = { method, headers }\n  if (method === GET) {\n    const queryParams = new URLSearchParams(url.search)\n    queryParams.append('dataStack', dataStackJSON)\n    url.search = queryParams.toString()\n  } else {\n    req.body = dataStackJSON\n  }\n  const res = await fetch(url, req)\n  if (!res.ok) throw new Error('Network response was not ok.')\n  const html = await res.text()\n  mergeHTMLFragments(el, html)\n  el.classList.remove(LOADING_CLASS)\n}\n\nconst p = new DOMParser()\nfunction mergeHTMLFragments(el: Element, html: string) {\n  const dom = [...p.parseFromString(html, TEXT_HTML).body.children]\n  for (let i = 0; i < dom.length; i++) {\n    const frag = dom[i]\n    if (!(frag instanceof Element)) {\n      throw new Error('Not an element')\n    }\n    const fragElement = toHTMLorSVGElement(frag)\n\n    const id = frag.getAttribute('id')\n    const firstFrag = i === 0\n    const hasID = !!id?.length\n    const useElAsTarget = firstFrag && !hasID\n\n    let targets: Iterable<Element>\n    if (useElAsTarget) {\n      targets = [el]\n    } else {\n      if (!hasID) throw new Error('No id')\n\n      const targetSelector = fragElement?.dataset?.[SELECTOR] || `#${id}`\n      targets = document.querySelectorAll(targetSelector) || []\n    }\n    if (!!!targets) throw new Error('No target element')\n\n    for (const target of targets) {\n      const merge = fragElement?.dataset?.[SWAP] || 'morph'\n      switch (merge) {\n        case 'morph':\n          idiomorph(target, frag)\n          break\n        case 'inner':\n          target.innerHTML = frag.innerHTML //  The default, replace the inner html of the target element\n          break\n        case 'outer':\n          target.outerHTML = frag.outerHTML //  Replace the entire target element with the response\n          break\n        case 'prepend':\n          target.prepend(frag.outerHTML) //  Insert the response before the first child of the target element\n          break\n        case 'append':\n          target.append(frag.outerHTML) //  Insert the response after the last child of the target element\n          break\n        case 'before':\n          target.before(frag) //  Insert the response before the target element\n          break\n        case 'after':\n          target.after(frag) //  Insert the response after the target element\n          break\n        case 'delete':\n          target.remove() //  Deletes the target element regardless of the response\n          break\n        default:\n          throw new Error('Invalid merge mode')\n      }\n    }\n  }\n}\n","import { AttributeContext, AttributePlugin, Groups, HTMLorSVGElement, RunePlugin } from '../types'\nimport { Signal, SignalAttributePlugin } from './reactivity'\nimport { noArgs } from './shared'\n\nexport class BindAttributePlugin extends AttributePlugin {\n  name = 'Bind'\n  prefix = 'bind'\n  description = 'Sets the value of the element'\n\n  onMount({ el, key, expressionEvaluated }: AttributeContext) {\n    el.setAttribute(key, `${expressionEvaluated}`)\n  }\n}\n\nexport class RefRunePlugin extends RunePlugin {\n  name = 'RefRune'\n  description = 'turns #ref into data.refs.ref.value'\n  regexp = new RegExp(/(?<whole>\\#(?<ref>[a-zA-Z_$][0-9a-zA-Z_$]*))/g)\n  replacer({ ref }: Groups) {\n    return `data.refs.${ref}.value`\n  }\n}\n\nexport class RefAttributePlugin extends AttributePlugin {\n  name = 'Ref'\n  prefix = 'ref'\n  description = 'Sets the value of the element'\n  mustHaveEmptyExpression = true\n\n  onMount({ el, key, set }: AttributeContext) {\n    set(key, el)\n  }\n}\n\nexport function getRef(ctx: AttributeContext, key: string) {\n  return ctx.get(key) as HTMLorSVGElement\n}\n\nexport class ModelAttributePlugin extends AttributePlugin {\n  name = 'Model'\n  prefix = 'model'\n  description = 'Sets the value of the element'\n  allowedTags = new Set(['input', 'textarea', 'select'])\n  requiredPluginTypes = new Set([SignalAttributePlugin])\n  updateEvents = ['change', 'input', 'keydown']\n  mustHaveEmptyExpression = true\n  mustHaveEmptyKey = true\n\n  onMount({ el, expressionEvaluated, effect, cleanup }: AttributeContext) {\n    if (!('value' in el)) throw new Error('Element must have a value property')\n    const signal = expressionEvaluated as Signal<any>\n    if (!signal) throw new Error(`Signal ${expressionEvaluated} not found`)\n    el.value = `${signal.value}`\n\n    const setter = () => {\n      const current = signal.value\n      if (typeof current === 'number') {\n        signal.value = Number(el.value)\n      } else if (typeof current === 'string') {\n        signal.value = el.value\n      } else if (typeof current === 'boolean') {\n        signal.value = Boolean(el.value)\n      } else {\n        throw new Error('Unsupported type')\n      }\n    }\n\n    effect(() => {\n      for (const event of this.updateEvents) {\n        el.addEventListener(event, setter)\n      }\n\n      cleanup(() => {\n        for (const event of this.updateEvents) {\n          el.removeEventListener(event, setter)\n        }\n      })\n    })\n  }\n}\n\nexport class EventListenerAttributePlugin extends AttributePlugin {\n  name = 'EventListener'\n  prefix = 'on'\n  description = 'Sets the value of the element'\n  allowedModifiers = new Set(['prevent', 'stop', 'capture'])\n  allowedModifierArgs = {\n    prevent: noArgs,\n    stop: noArgs,\n    capture: noArgs,\n  }\n\n  onMount({ el, key, modifiers, expressionEvaluated, effect, cleanup }: AttributeContext) {\n    const fn = expressionEvaluated as EventListener\n    if (!fn) throw new Error(`Function ${expressionEvaluated} not found`)\n\n    const options: AddEventListenerOptions = {}\n    if (modifiers.has('capture')) options.capture = true\n    if (modifiers.has('prevent')) options.passive = false\n    if (modifiers.has('stop')) options.once = true\n\n    effect(() => {\n      el.addEventListener(key, fn, options)\n      cleanup(() => el.removeEventListener(key, fn, options))\n    })\n  }\n}\n\nexport class TextNodeAttributePlugin extends AttributePlugin {\n  name = 'TextNode'\n  prefix = 'text'\n  description = 'Sets the textContent of the element'\n  mustHaveEmptyKey = true\n  mustHaveEmptyExpression = true\n\n  onMount({ el, expressionEvaluated }: AttributeContext) {\n    if (!(el instanceof HTMLElement)) throw new Error('Element is not HTMLElement')\n    el.textContent = `${expressionEvaluated}`\n  }\n}\n\nexport class FocusElementAttributePlugin extends AttributePlugin {\n  name = 'FocusElement'\n  prefix = 'focus'\n  description = 'Sets the textContent of the element'\n  mustHaveEmptyKey = true\n  mustHaveEmptyExpression = true\n\n  onMount({ el }: AttributeContext) {\n    el.focus()\n  }\n}\n","import { toHTMLorSVGElement } from '../dom'\nimport { AttributeContext, AttributePlugin } from '../types'\nimport { reactivityPlugins } from './reactivity'\nimport { noArgs } from './shared'\n\nexport const DISPLAY = 'display'\nexport const NONE = 'none'\nexport const PREPEND = 'prepend'\nexport const APPEND = 'append'\nexport const INTERSECTS = 'intersects'\nexport const IMPORTANT = 'important'\n\nexport class ShowPlugin extends AttributePlugin {\n  name = 'Show'\n  description = 'Sets the display of the element'\n  prefix = 'show'\n  allowedModifiers = new Set([IMPORTANT])\n  allowedModifierArgs = { [IMPORTANT]: noArgs }\n\n  onMount({ el, expressionEvaluated, modifiers }: AttributeContext) {\n    const shouldShow = !!expressionEvaluated\n\n    const isImportant = modifiers.has(IMPORTANT)\n    const priority = isImportant ? IMPORTANT : undefined\n\n    if (shouldShow) {\n      if (el.style.length === 1 && el.style.display === NONE) {\n        el.style.removeProperty(DISPLAY)\n      } else {\n        el.style.setProperty(DISPLAY, '', priority)\n      }\n    } else {\n      el.style.setProperty(DISPLAY, NONE, priority)\n    }\n  }\n}\n\nexport const ONCE = 'once'\nexport const FULL = 'full'\nexport const HALF = 'half'\n\nexport class IntersectionAttributePlugin extends AttributePlugin {\n  name = 'Intersection'\n  prefix = INTERSECTS\n  description = 'Sets the value of the element'\n  requiredPluginTypes = reactivityPlugins\n  allowedModifiers = new Set([ONCE, FULL, HALF])\n  allowedModifierArgs = {\n    [ONCE]: noArgs,\n    [FULL]: noArgs,\n    [HALF]: noArgs,\n  }\n\n  onMount({ modifiers, el, set, effect, cleanup }: AttributeContext) {\n    const options = { threshold: 0 }\n    if (modifiers.has(FULL)) options.threshold = 1\n    else if (modifiers.has(HALF)) options.threshold = 0.5\n\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          set(INTERSECTS, true)\n          if (modifiers.has(ONCE)) {\n            observer.disconnect()\n          }\n        }\n      })\n    }, options)\n\n    effect(() => {\n      observer.observe(el)\n\n      cleanup(() => observer.disconnect())\n    })\n  }\n}\n\nexport class TeleportAttributePlugin extends AttributePlugin {\n  name = 'Teleport'\n  prefix = 'teleport'\n  description = 'Teleports the element to another element'\n  allowedModifiers = new Set([PREPEND, APPEND])\n  allowedModifierArgs = {\n    [PREPEND]: noArgs,\n    [APPEND]: noArgs,\n  }\n  allowedTags = new Set(['template'])\n  static parentErr = new Error('Target element must have a parent if using prepend or append')\n\n  onMount({ el, modifiers, effect, expressionEvaluated }: AttributeContext) {\n    if (!(el instanceof HTMLTemplateElement)) {\n      throw new Error('Element must be a template')\n    }\n\n    effect(() => {\n      if (typeof expressionEvaluated !== 'string') {\n        throw new Error('Only string selectors are supported')\n      }\n\n      const target = document.querySelector(expressionEvaluated)\n      if (!target) throw new Error(`Target element not found: ${expressionEvaluated}`)\n\n      if (!el.content) {\n        throw new Error('Template element must have content')\n      }\n\n      const n = el.content.cloneNode(true)\n      const nEl = toHTMLorSVGElement(n as Element)\n      if (nEl?.firstElementChild) throw new Error('Empty template')\n\n      if (modifiers.has(PREPEND)) {\n        if (!target.parentNode) throw TeleportAttributePlugin.parentErr\n        target.parentNode.insertBefore(n, target)\n      } else if (modifiers.has(APPEND)) {\n        if (!target.parentNode) throw TeleportAttributePlugin.parentErr\n        target.parentNode.insertBefore(n, target.nextSibling)\n      } else {\n        target.appendChild(n)\n      }\n    })\n  }\n}\n","// function mergeActions<T extends unknown[]>(...actions: T): UnionToIntersection<T[number]> {\n//   const all = {}\n//   for (const action of actions) {\n//     Object.assign(all, action)\n//   }\n//   return all as UnionToIntersection<T[number]>\n// }\n\nimport { Datastar } from './core'\nimport { ActionRunePlugin } from './plugins/actions'\nimport {\n  FetchAttributePlugin,\n  FetchDeleteActionPlugin,\n  FetchGetActionPlugin,\n  FetchPatchActionPlugin,\n  FetchPostActionPlugin,\n  FetchPutActionPlugin,\n} from './plugins/backend'\nimport {\n  BindAttributePlugin,\n  EventListenerAttributePlugin,\n  ModelAttributePlugin,\n  RefAttributePlugin,\n  RefRunePlugin,\n  TextNodeAttributePlugin,\n} from './plugins/binding'\nimport {\n  ComputedAttributePlugin,\n  EffectAttributePlugin,\n  ReactivityRunePlugin,\n  SignalAttributePlugin,\n} from './plugins/reactivity'\nimport { IntersectionAttributePlugin, ShowPlugin, TeleportAttributePlugin } from './plugins/visibility'\n\nconst ds = new Datastar(\n  ActionRunePlugin,\n  ReactivityRunePlugin,\n  RefRunePlugin,\n  SignalAttributePlugin,\n  ComputedAttributePlugin,\n  EffectAttributePlugin,\n  BindAttributePlugin,\n  RefAttributePlugin,\n  ModelAttributePlugin,\n  EventListenerAttributePlugin,\n  TextNodeAttributePlugin,\n  ShowPlugin,\n  IntersectionAttributePlugin,\n  TeleportAttributePlugin,\n  FetchAttributePlugin,\n  FetchGetActionPlugin,\n  FetchPostActionPlugin,\n  FetchPatchActionPlugin,\n  FetchPutActionPlugin,\n  FetchDeleteActionPlugin,\n)\nds.run()\n"],"names":["SCOPE","scheduledEffects","currentScope","currentObserver","currentObservers","currentObserversIndex","effects","defaultContext","NOOP","STATE_CLEAN","STATE_CHECK","STATE_DIRTY","STATE_DISPOSED","flushEffects","runEffects","i","runTop","node","ancestors","updateCheck","root","init","scope","createScope","compute","dispose","getContext","key","setContext","value","onDispose","disposable","isFunction","self","head","current","next","disposeNode","emptyDisposal","removeSourceObservers","callable","error","handleError","compute2","observer","prevScope","prevObserver","len","coercedError","coerceError","error2","read","write","newValue","notify","ScopeNode","ScopeProto","child","tail","ComputeNode","initialValue","options","ComputeProto","isNotEqual","createComputation","a","b","update","cleanup","prevObservers","prevObserversIndex","result","source","state","index","swap","signal","signal2","computed","effect","effect2","effectResult","toHTMLorSVGElement","walkDownDOM","el","callback","functionGenerator","str","fnContents","functionEval","ctx","expression","fn","e","DatastarPlugin","AttributePlugin","RunePlugin","ActionPlugin","Datastar","plugins","mutations","m","p","allPlugins","Plugin","requiredPluginType","plugin","t","element","hasAttributePlugin","reactiveRootDisposal","cb","elTagLower","fullPrefix","attr","keyRaw","modifiersWithArgsArr","modifiersArr","label","args","expressionRaw","modifier","allowedArgs","modifiers","k","v","ActionRunePlugin","action","generatedByIdiomorphId","idiomorph","oldNode","newContent","config","parsedContent","parseContent","normalizedContent","normalizeContent","createMorphContext","morphNormalizedContent","normalizedNewContent","oldHead","newHead","promises","handleHeadElement","morphChildren","bestMatch","findBestNodeMatch","previousSibling","nextSibling","morphedNode","morphOldNodeTo","insertSiblings","isSoftMatch","syncNodeFrom","newParent","oldParent","nextNewChild","insertionPoint","newChild","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","from","to","type","fromAttribute","toAttribute","syncAttribute","fromValue","toValue","attributeName","fAttr","tAttr","newHeadTag","currentHead","added","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","newHeadChild","currentHeadElt","inNewContent","isReAppended","isPreserved","newNode","newElt","resolver","promise","resolve","removedElement","noOp","createIdMap","elt","node1","node2","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","parser","contentWithSvgsRemoved","content","Element","dummyParent","stack","currentElement","bestElement","score","newScore","scoreElement","isIdInConsideration","id","idIsWithinNode","targetNode","idSet","sourceSet","matchCount","populateIdMapForNode","idMap","nodeParent","idElements","oldContent","ReactivityRunePlugin","groups","Signal","SignalAttributePlugin","set","expressionEvaluated","Computed","ComputedAttributePlugin","EffectAttributePlugin","reactivityPlugins","noArgs","SELECTOR","SWAP","REQ_HEADERS_CTX_KEY","FetchRequestHeadersPlugin","get","headers","GET","POST","PUT","PATCH","DELETE","DATASTAR_CLASS_PREFIX","INDICATOR_CLASS","LOADING_CLASS","FetchAction","method","style","fetcher","FetchGetActionPlugin","FetchPostActionPlugin","FetchPutActionPlugin","FetchPatchActionPlugin","FetchDeleteActionPlugin","FetchAttributePlugin","ACCEPT","CONTENT_TYPE","TEXT_HTML","APPLICATION_JSON","ctxHeaders","name","url","dataStackJSON","req","queryParams","res","html","mergeHTMLFragments","dom","frag","fragElement","firstFrag","hasID","useElAsTarget","targets","targetSelector","target","BindAttributePlugin","RefRunePlugin","ref","RefAttributePlugin","ModelAttributePlugin","setter","event","EventListenerAttributePlugin","TextNodeAttributePlugin","DISPLAY","NONE","PREPEND","APPEND","INTERSECTS","IMPORTANT","ShowPlugin","shouldShow","priority","ONCE","FULL","HALF","IntersectionAttributePlugin","entries","entry","TeleportAttributePlugin","n","ds"],"mappings":"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","x_google_ignoreList":[0,1,2]}