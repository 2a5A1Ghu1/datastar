{"version":3,"file":"datastar.js","sources":["../src/lib/dom.ts","../src/lib/eval.ts","../src/lib/mockFetch.ts","../src/lib/external/reactively.ts","../src/lib/core.ts","../src/lib/plugins/actions.ts","../src/lib/plugins/bind.ts","../src/lib/plugins/focus.ts","../src/lib/external/idiomorph.ts","../src/lib/plugins/fragments.ts","../src/lib/plugins/model.ts","../src/lib/plugins/on.ts","../src/lib/plugins/ref.ts","../src/lib/plugins/show.ts","../src/lib/plugins/signal.ts","../src/lib/plugins/teleport.ts","../src/lib/plugins/text.ts","../src/lib/plugins/intersects.ts","../src/lib/plugins/index.ts"],"sourcesContent":["export function walkDownDOM(el: Element | null, callback: (el: Element) => void) {\n  if (!el) return\n  callback(el)\n\n  el = el.firstElementChild\n\n  while (el) {\n    walkDownDOM(el, callback)\n    el = el.nextElementSibling\n  }\n}\n\n/**\n * Walks up the DOM tree, starting from the given element, and calls the callback for each element.\n * @param el The element to start from.\n * @param callback The callback to call for each element.\n */\nexport function walkUpDOM(el: Element | null, callback: (el: Element) => void) {\n  if (!el) return\n  callback(el)\n\n  el = el.parentElement\n  walkUpDOM(el, callback)\n}\n","import { ActionsMap, NamespacedReactiveRecordCallback, NamespacedReactiveRecords } from './types'\n\nexport function functionGenerator<T>(str: string): NamespacedReactiveRecordCallback<T> {\n  const fnContents = `return ${str}`\n  const fn = new Function('el', 'dataStack', 'actions', fnContents)\n  return fn as NamespacedReactiveRecordCallback<T>\n}\n\nexport function functionEval(el: Element, dataStack: NamespacedReactiveRecords, actions: ActionsMap, str: string) {\n  const fn = functionGenerator(str)\n  try {\n    return fn(el, dataStack, actions)\n  } catch (e) {\n    console.error(`Error evaluating expression: ${str}`)\n  }\n}\n\nexport function camelize(str: string) {\n  return str\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => {\n      return index === 0 ? word.toLowerCase() : word.toUpperCase()\n    })\n    .replace(/\\s+/g, '')\n}\n","export interface MockedResponse {\n  html: string\n  status?: number\n  statusText?: string\n  headers?: Headers\n}\n\nexport interface MockFetchRoutes {\n  [url: string]: {\n    [method: string]: (req: Request) => Promise<MockedResponse>\n  }\n}\n\nexport function injectMockFetch(routes: MockFetchRoutes) {\n  console.warn(`Overriding fetch with mock version, this should only be used in examples.`)\n\n  const mockFetch = async (url: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n    const req = new Request(url, init)\n\n    if (!(url instanceof URL)) throw new Error(`url must be a URL`)\n\n    const urlMethods = routes[url.pathname]\n    if (!urlMethods) throw new Error(`No mock route found for ${req.url}`)\n\n    const methodFn = urlMethods[req.method]\n    if (!methodFn) throw new Error(`No mock route found for ${req.method} ${req.url}`)\n\n    let { html, status, statusText, headers } = await methodFn(req)\n    if (!headers) headers = new Headers()\n    if (!headers.has('Content-Type')) headers.append('Content-Type', 'text/html')\n    status = status || 200\n    statusText = statusText || 'OK'\n\n    const res = new Response(html, { status, statusText, headers })\n    return res\n  }\n\n  window.fetch = mockFetch\n}\n","/**\n * Nodes for constructing a reactive graph of reactive values and reactive computations.\n * The graph is acyclic.\n * The user inputs new values into the graph by calling set() on one more more reactive nodes.\n * The user retrieves computed results from the graph by calling get() on one or more reactive nodes.\n * The library is responsible for running any necessary reactive computations so that get() is\n * up to date with all prior set() calls anywhere in the graph.\n *\n * We call input nodes 'roots' and the output nodes 'leaves' of the graph here in discussion,\n * but the distinction is based on the use of the graph, all nodes have the same internal structure.\n * Changes flow from roots to leaves. It would be effective but inefficient to immediately propagate\n * all changes from a root through the graph to descendant leaves. Instead we defer change\n * most change progogation computation until a leaf is accessed. This allows us to coalesce computations\n * and skip altogether recalculating unused sections of the graph.\n *\n * Each reactive node tracks its sources and its observers (observers are other\n * elements that have this node as a source). Source and observer links are updated automatically\n * as observer reactive computations re-evaluate and call get() on their sources.\n *\n * Each node stores a cache state to support the change propogation algorithm: 'clean', 'check', or 'dirty'\n * In general, execution proceeds in three passes:\n *  1. set() propogates changes down the graph to the leaves\n *     direct children are marked as dirty and their deeper descendants marked as check\n *     (no reactive computations are evaluated)\n *  2. get() requests that parent nodes updateIfNecessary(), which proceeds recursively up the tree\n *     to decide whether the node is clean (parents unchanged) or dirty (parents changed)\n *  3. updateIfNecessary() evaluates the reactive computation if the node is dirty\n *     (the computations are executed in root to leaf order)\n */\n\n/** current capture context for identifying @reactive sources (other reactive elements) and cleanups\n * - active while evaluating a reactive function body  */\nlet CurrentReaction: Reactive<any> | undefined = undefined\nlet CurrentGets: Reactive<any>[] | null = null\nlet CurrentGetsIndex = 0\n\n/** A list of non-clean 'effect' nodes that will be updated when stabilize() is called */\nlet EffectQueue: Reactive<any>[] = []\n\nlet stabilizeFn: ((node: Reactive<any>) => void) | undefined = undefined // fn to call if there are dirty effect nodes\nlet stabilizationQueued = false // stabilizeFn() is queued to run after this event loop\n\n/** reactive nodes are marked dirty when their source values change TBD*/\nexport const CacheClean = 0 // reactive value is valid, no need to recompute\nexport const CacheCheck = 1 // reactive value might be stale, check parent nodes to decide whether to recompute\nexport const CacheDirty = 2 // reactive value is invalid, parents have changed, valueneeds to be recomputed\nexport type CacheState = typeof CacheClean | typeof CacheCheck | typeof CacheDirty\ntype CacheNonClean = typeof CacheCheck | typeof CacheDirty\n\nexport function logDirty(_enable?: boolean): void {\n  // TBD for a debug build\n}\n\nexport interface ReactivelyParams {\n  equals?: (a: any, b: any) => boolean\n  effect?: boolean\n}\n\n/** A reactive element contains a mutable value that can be observed by other reactive elements.\n *\n * The property can be modified externally by calling set().\n *\n * Reactive elements may also contain a 0-ary function body that produces a new value using\n * values from other reactive elements.\n *\n * Dependencies on other elements are captured dynamically as the 'reactive' function body executes.\n *\n * The reactive function is re-evaluated when any of its dependencies change, and the result is\n * cached.\n */\nexport function reactive<T>(fnOrValue: T | (() => T), params?: ReactivelyParams): Reactive<T> {\n  const node = new Reactive(fnOrValue, params?.effect)\n  if (params?.equals) {\n    node.equals = params.equals\n  }\n  return node\n}\n\nfunction defaultEquality(a: any, b: any) {\n  return a === b\n}\n\n/** A reactive element contains a mutable value that can be observed by other reactive elements.\n *\n * The property can be modified externally by calling set().\n *\n * Reactive elements may also contain a 0-ary function body that produces a new value using\n * values from other reactive elements.\n *\n * Dependencies on other elements are captured dynamically as the 'reactive' function body executes.\n *\n * The reactive function is re-evaluated when any of its dependencies change, and the result is\n * cached.\n */\nexport class Reactive<T> {\n  private _value: T\n  private fn?: () => T\n  private observers: Reactive<any>[] | null = null // nodes that have us as sources (down links)\n  private sources: Reactive<any>[] | null = null // sources in reference order, not deduplicated (up links)\n\n  private state: CacheState\n  cleanups: ((oldValue: T) => void)[] = []\n  equals = defaultEquality\n\n  constructor(\n    fnOrValue: (() => T) | T,\n    readonly isEffect = false,\n  ) {\n    if (typeof fnOrValue === 'function') {\n      this.fn = fnOrValue as () => T\n      this._value = undefined as any\n      this.isEffect = isEffect || false\n      this.state = CacheDirty\n      if (isEffect) {\n        EffectQueue.push(this)\n        stabilizeFn?.(this)\n      }\n    } else {\n      this.fn = undefined\n      this._value = fnOrValue\n      this.state = CacheClean\n      this.isEffect = false\n    }\n  }\n\n  get value(): T {\n    return this.get()\n  }\n\n  set value(v: T) {\n    this.set(v)\n  }\n\n  get(): T {\n    if (CurrentReaction) {\n      if (!CurrentGets && CurrentReaction.sources && CurrentReaction.sources[CurrentGetsIndex] == this) {\n        CurrentGetsIndex++\n      } else {\n        if (!CurrentGets) CurrentGets = [this]\n        else CurrentGets.push(this)\n      }\n    }\n    if (this.fn) this.updateIfNecessary()\n    return this._value\n  }\n\n  set(fnOrValue: T | (() => T)): void {\n    if (typeof fnOrValue === 'function') {\n      const fn = fnOrValue as () => T\n      if (fn !== this.fn) {\n        this.stale(CacheDirty)\n      }\n      this.fn = fn\n    } else {\n      if (this.fn) {\n        this.removeParentObservers(0)\n        this.sources = null\n        this.fn = undefined\n      }\n      const value = fnOrValue as T\n      if (!this.equals(this._value, value)) {\n        if (this.observers) {\n          for (let i = 0; i < this.observers.length; i++) {\n            const observer = this.observers[i]\n            observer.stale(CacheDirty)\n          }\n        }\n        this._value = value\n      }\n    }\n  }\n\n  private stale(state: CacheNonClean): void {\n    if (this.state < state) {\n      // If we were previously clean, then we know that we may need to update to get the new value\n      if (this.state === CacheClean && this.isEffect) {\n        EffectQueue.push(this)\n        stabilizeFn?.(this)\n      }\n\n      this.state = state\n      if (this.observers) {\n        for (let i = 0; i < this.observers.length; i++) {\n          this.observers[i].stale(CacheCheck)\n        }\n      }\n    }\n  }\n\n  /** run the computation fn, updating the cached value */\n  private update(): void {\n    const oldValue = this._value\n\n    /* Evalute the reactive function body, dynamically capturing any other reactives used */\n    const prevReaction = CurrentReaction\n    const prevGets = CurrentGets\n    const prevIndex = CurrentGetsIndex\n\n    CurrentReaction = this\n    CurrentGets = null as any // prevent TS from thinking CurrentGets is null below\n    CurrentGetsIndex = 0\n\n    try {\n      if (this.cleanups.length) {\n        this.cleanups.forEach((c) => c(this._value))\n        this.cleanups = []\n      }\n      this._value = this.fn!()\n\n      // if the sources have changed, update source & observer links\n      if (CurrentGets) {\n        // remove all old sources' .observers links to us\n        this.removeParentObservers(CurrentGetsIndex)\n        // update source up links\n        if (this.sources && CurrentGetsIndex > 0) {\n          this.sources.length = CurrentGetsIndex + CurrentGets.length\n          for (let i = 0; i < CurrentGets.length; i++) {\n            this.sources[CurrentGetsIndex + i] = CurrentGets[i]\n          }\n        } else {\n          this.sources = CurrentGets\n        }\n\n        for (let i = CurrentGetsIndex; i < this.sources.length; i++) {\n          // Add ourselves to the end of the parent .observers array\n          const source = this.sources[i]\n          if (!source.observers) {\n            source.observers = [this]\n          } else {\n            source.observers.push(this)\n          }\n        }\n      } else if (this.sources && CurrentGetsIndex < this.sources.length) {\n        // remove all old sources' .observers links to us\n        this.removeParentObservers(CurrentGetsIndex)\n        this.sources.length = CurrentGetsIndex\n      }\n    } finally {\n      CurrentGets = prevGets\n      CurrentReaction = prevReaction\n      CurrentGetsIndex = prevIndex\n    }\n\n    // handles diamond depenendencies if we're the parent of a diamond.\n    if (!this.equals(oldValue, this._value) && this.observers) {\n      // We've changed value, so mark our children as dirty so they'll reevaluate\n      for (let i = 0; i < this.observers.length; i++) {\n        const observer = this.observers[i]\n        observer.state = CacheDirty\n      }\n    }\n\n    // We've rerun with the latest values from all of our sources.\n    // This means that we no longer need to update until a signal changes\n    this.state = CacheClean\n  }\n\n  /** update() if dirty, or a parent turns out to be dirty. */\n  private updateIfNecessary(): void {\n    // If we are potentially dirty, see if we have a parent who has actually changed value\n    if (this.state === CacheCheck) {\n      for (const source of this.sources!) {\n        source.updateIfNecessary() // updateIfNecessary() can change this.state\n        if ((this.state as CacheState) === CacheDirty) {\n          // Stop the loop here so we won't trigger updates on other parents unnecessarily\n          // If our computation changes to no longer use some sources, we don't\n          // want to update() a source we used last time, but now don't use.\n          break\n        }\n      }\n    }\n\n    // If we were already dirty or marked dirty by the step above, update.\n    if (this.state === CacheDirty) {\n      this.update()\n    }\n\n    // By now, we're clean\n    this.state = CacheClean\n  }\n\n  private removeParentObservers(index: number): void {\n    if (!this.sources) return\n    for (let i = index; i < this.sources.length; i++) {\n      const source: Reactive<any> = this.sources[i] // We don't actually delete sources here because we're replacing the entire array soon\n      const swap = source.observers!.findIndex((v) => v === this)\n      source.observers![swap] = source.observers![source.observers!.length - 1]\n      source.observers!.pop()\n    }\n  }\n}\n\nexport function onCleanup<T = any>(fn: (oldValue: T) => void): void {\n  if (CurrentReaction) {\n    CurrentReaction.cleanups.push(fn)\n  } else {\n    console.error('onCleanup must be called from within a @reactive function')\n  }\n}\n\n/** run all non-clean effect nodes */\nexport function stabilize(): void {\n  for (let i = 0; i < EffectQueue.length; i++) {\n    EffectQueue[i].get()\n  }\n  EffectQueue.length = 0\n}\n\n/** run a function for each dirty effect node.  */\nexport function autoStabilize(fn = deferredStabilize): void {\n  stabilizeFn = fn\n}\n\n/** queue stabilize() to run at the next idle time */\nfunction deferredStabilize(): void {\n  if (!stabilizationQueued) {\n    stabilizationQueued = true\n\n    queueMicrotask(() => {\n      stabilizationQueued = false\n      stabilize()\n    })\n  }\n}\n","import { camelize } from '.'\nimport { walkDownDOM, walkUpDOM } from './dom'\nimport { Reactive, autoStabilize, onCleanup, reactive } from './external/reactively'\nimport { ACTION } from './plugins/actions'\nimport { ActionFn, ActionsMap, Modifier, NamespacedReactiveRecords, WithExpressionArgs } from './types'\nautoStabilize()\n\nfunction signal<T>(initialValue: T): Reactive<T> {\n  return reactive(initialValue)\n}\n\nfunction computed<T>(fn: () => T): Reactive<T> {\n  return reactive(fn)\n}\n\nfunction effect(fn: () => void) {\n  return reactive(fn, { effect: true })\n}\n\nconst pluginObserver = new MutationObserver((mutations) => {\n  for (const m of mutations) {\n    m.removedNodes.forEach((node) => {\n      const el = node as Element\n      if (!el) return\n      pluginElementRegistry.delete(el)\n    })\n\n    // m.addedNodes.forEach((node) => {\n    //   const el = node as Element\n    //   if (!el) return\n    //   pluginApplyFunctions.forEach((fn) => fn(el))\n    // })\n  }\n})\n\npluginObserver.observe(document, {\n  attributes: true,\n  childList: true,\n  subtree: true,\n})\n\nexport interface Preprocesser {\n  name: string\n  description: string\n  regexp: RegExp\n  replacer: (groups: Record<string, string>) => string\n}\nexport function useProcessor({ regexp, replacer }: Preprocesser, str: string): string {\n  // console.log(`preprocess with ${name}. ${description}`)\n  const matches = [...str.matchAll(regexp)]\n  if (!matches.length) return str\n  for (const match of matches) {\n    if (!match.groups) continue\n    const { groups } = match\n    const { whole } = groups\n    str = str.replace(whole, replacer(groups))\n  }\n  return str\n}\n\n// function cyrb53(str: string, seed = 0) {\n//   let h1 = 0xdeadbeef ^ seed,\n//     h2 = 0x41c6ce57 ^ seed\n//   for (let i = 0, ch; i < str.length; i++) {\n//     ch = str.charCodeAt(i)\n//     h1 = Math.imul(h1 ^ ch, 2654435761)\n//     h2 = Math.imul(h2 ^ ch, 1597334677)\n//   }\n//   h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507)\n//   h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909)\n//   h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507)\n//   h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909)\n\n//   return 4294967296 * (2097151 & h2) + (h1 >>> 0)\n// }\n\nconst prefixHashes = new Map<string, string>()\nconst pluginApplyFunctions = new Map<string, Function>()\nconst pluginElementRegistry = new Map<Element, Set<string>>()\nconst pluginPreprocessStack = new Array<Preprocesser>()\nconst data = new Map<Element, NamespacedReactiveRecords>()\n\nexport function applyPlugins(el: Element) {\n  walkDownDOM(el, (element) => {\n    pluginElementRegistry.delete(element)\n  })\n  pluginApplyFunctions.forEach((fn, name) => {\n    console.log(`apply ${name} to ${el.id || el.tagName} `)\n    fn(el)\n  })\n}\n\nconst actions: ActionsMap = {}\n\nexport function addDataPlugin(\n  prefix: string,\n  args: {\n    allowedTags?: Iterable<string>\n    allowedModifiers?: Iterable<string | RegExp>\n    isPreprocessGlobal?: boolean\n    preprocessExpressions?: Iterable<Preprocesser>\n    withExpression?: (args: WithExpressionArgs) => NamespacedReactiveRecords | void\n    requiredPlugins?: Iterable<string>\n  },\n) {\n  if (prefix.toLowerCase() !== prefix) throw Error(`Data plugin 'data-${prefix}' must be lowercase`)\n  if (prefixHashes.has(prefix)) {\n    throw new Error(`Data plugin 'data-${prefix}' already registered`)\n  }\n\n  const hash = prefix\n  // const hash = cyrb53(prefix)\n  prefixHashes.set(prefix, hash)\n\n  if (!args) {\n    args = {}\n  }\n\n  for (const plugin of args.requiredPlugins || []) {\n    if (plugin === prefix) {\n      throw new Error(`Data plugin 'data-${prefix}' cannot require itself`)\n    }\n  }\n\n  const pluginsRegistered = new Set(prefixHashes.keys())\n  for (const requiredPlugin of args.requiredPlugins || []) {\n    if (!pluginsRegistered.has(requiredPlugin)) {\n      throw new Error(`Data plugin 'data-${prefix}' requires 'data-${requiredPlugin}'`)\n    }\n  }\n\n  if (typeof args?.isPreprocessGlobal === 'undefined') {\n    args.isPreprocessGlobal = true\n  }\n\n  if (args?.preprocessExpressions && args.isPreprocessGlobal) {\n    pluginPreprocessStack.push(...args.preprocessExpressions)\n  }\n\n  const allAllowedModifiers: RegExp[] = []\n  if (args?.allowedModifiers) {\n    for (const modifier of args.allowedModifiers) {\n      const m = modifier instanceof RegExp ? modifier : new RegExp(modifier)\n      allAllowedModifiers.push(m)\n    }\n  }\n\n  const allowedTags = new Set([...(args?.allowedTags || [])].map((t) => t.toLowerCase()))\n\n  function registerPluginOnElement(parentEl: Element) {\n    walkDownDOM(parentEl, (element) => {\n      const el = toHTMLorSVGElement(element)\n      if (!el) return\n\n      let plugins = pluginElementRegistry.get(el)\n      if (!plugins) {\n        plugins = new Set()\n        pluginElementRegistry.set(el, plugins)\n      }\n\n      if (plugins.has(hash)) return\n      plugins.add(hash)\n\n      if (allowedTags.size) {\n        const tagLower = el.tagName.toLowerCase()\n        if (!allowedTags.has(tagLower)) return\n      }\n\n      for (var d in el.dataset) {\n        if (!d.startsWith(prefix)) continue\n\n        // console.log(`add plugin ${d} to ${el.id || el.tagName}`)\n        let [name, ...modifiersWithArgsArr] = d.split('.')\n\n        const pl = prefix.length\n        const pl1 = pl + 1\n        name = name.slice(pl, pl1).toLocaleLowerCase() + name.slice(pl1)\n\n        const modifiers = modifiersWithArgsArr.map((m) => {\n          const [label, ...args] = m.split(':')\n\n          const isAllowed = allAllowedModifiers.some((allowedModifier) => allowedModifier.test(label))\n          if (!isAllowed) {\n            throw new Error(`Modifier ${label} is not allowed for ${name}`)\n          }\n\n          return { label, args }\n        })\n\n        const dataStack = loadDataStack(el)\n        let expression = el.dataset[d] || ''\n\n        for (const preprocessor of pluginPreprocessStack) {\n          expression = useProcessor(preprocessor, expression)\n        }\n\n        if (args?.preprocessExpressions && !args?.isPreprocessGlobal) {\n          for (const preprocessor of args.preprocessExpressions) {\n            expression = useProcessor(preprocessor, expression)\n          }\n        }\n\n        const elementData = data.get(el) || {}\n        if (args?.withExpression) {\n          const postExpression = args.withExpression({\n            name,\n            expression,\n            el,\n            dataStack,\n            reactivity: {\n              signal,\n              computed,\n              effect,\n              onCleanup,\n            },\n            withMod: (label: string) => withModifier(modifiers, label),\n            hasMod: (label: string) => hasModifier(modifiers, label),\n            applyPlugins: (el: Element) => pluginApplyFunctions.forEach((fn) => fn(el)),\n            actions,\n          })\n          if (postExpression) {\n            Object.assign(elementData, postExpression)\n          }\n        }\n        data.set(el, elementData)\n      }\n    })\n  }\n\n  registerPluginOnElement(document.body)\n  pluginApplyFunctions.set(hash, registerPluginOnElement)\n\n  console.info(`Registered data plugin: data-${prefix}`)\n}\n\nfunction loadDataStack(el: Element): NamespacedReactiveRecords {\n  const stack: NamespacedReactiveRecords[] = []\n\n  walkUpDOM(el, (el) => {\n    const elData = data.get(el)\n    if (elData) stack.push(elData)\n  })\n\n  stack.reverse()\n\n  const dataStack: NamespacedReactiveRecords = {}\n  for (const namespacedRecords of stack) {\n    for (const namespaceKey in namespacedRecords) {\n      if (!dataStack[namespaceKey]) {\n        dataStack[namespaceKey] = {}\n      }\n      Object.assign(dataStack[namespaceKey], namespacedRecords[namespaceKey])\n    }\n  }\n\n  return dataStack\n}\n\nexport function toHTMLorSVGElement(el: Element) {\n  if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n    return null\n  }\n  return el\n}\n\nexport function hasModifier(modifiers: Modifier[], label: string) {\n  return modifiers.some((m) => m.label === label)\n}\n\nexport function withModifier(modifiers: Modifier[], label: string) {\n  return modifiers.find((m) => m.label === label)\n}\n\nexport function addActionPlugin(args: {\n  name: string\n  description: string\n  fn: ActionFn\n  requiredPlugins?: Iterable<string>\n}) {\n  const { name, fn, requiredPlugins } = args\n  const pluginHashes = [ACTION, ...(requiredPlugins || [])]\n\n  if (name != camelize(name)) {\n    throw new Error(`must be camelCase`)\n  }\n\n  for (const ext of pluginHashes) {\n    if (!prefixHashes.has(ext)) {\n      throw new Error(`requires '@${name}' registration`)\n    }\n\n    if (name in actions) {\n      throw new Error(`'@${name}' already registered`)\n    }\n\n    actions[name] = fn\n  }\n}\n\nlet nextID = 0\nexport function uniqueId() {\n  return nextID++\n}\n","import { addDataPlugin } from '../core'\n\nexport const ACTION = 'action'\n\nexport function addActionDataPlugin() {\n  addDataPlugin(ACTION, {\n    preprocessExpressions: [\n      {\n        name: 'action',\n        description: 'turns @action(args) into actions.action(args)',\n        regexp: new RegExp(/(?<whole>@(?<action>[a-zA-Z_$][0-9a-zA-Z_$]*)(?<call>\\((?<args>.*)\\))?)/g),\n        replacer: ({ action, args }) => `actions.${action}({el,dataStack, actions}, ${args || ''})`,\n      },\n    ],\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataPlugin } from '../core'\n\nexport const BIND = 'bind'\nexport function addBindDataPlugin() {\n  addDataPlugin(BIND, {\n    requiredPlugins: [SIGNAL],\n    withExpression: ({ el, name, expression, dataStack, actions, reactivity: { effect } }) => {\n      const signalFn = functionGenerator(expression)\n\n      const elementData: NamespacedReactiveRecords = {\n        bind: {\n          [name]: effect(() => {\n            if (!dataStack?.signals) return\n            const res = signalFn(el, dataStack, actions)\n            el.setAttribute(name, `${res}`)\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { SIGNAL } from '.'\nimport { addDataPlugin, toHTMLorSVGElement } from '../core'\n\nexport const FOCUS = 'focus'\nexport function addFocusDataPlugin() {\n  addDataPlugin(FOCUS, {\n    requiredPlugins: [SIGNAL],\n    withExpression: ({ el }) => {\n      const element = toHTMLorSVGElement(el)\n      if (!element?.focus) throw new Error('Element must have a focus method')\n      element.focus()\n      return {}\n    },\n  })\n}\n","const generatedByIdiomorphId = new WeakSet()\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function idiomorph(oldNode: Document | Element, newContent: string | Element, config = {}) {\n  if (oldNode instanceof Document) {\n    oldNode = oldNode.documentElement\n  }\n\n  let parsedContent: Element\n  if (typeof newContent === 'string') {\n    parsedContent = parseContent(newContent) as Element\n  } else {\n    parsedContent = newContent\n  }\n\n  const normalizedContent = normalizeContent(parsedContent)\n  const ctx = createMorphContext(oldNode, normalizedContent, config)\n\n  return morphNormalizedContent(oldNode, normalizedContent, ctx)\n}\n\nfunction morphNormalizedContent(oldNode: Element, normalizedNewContent: Element, ctx: any) {\n  if (ctx.head.block) {\n    const oldHead = oldNode.querySelector('head')\n    const newHead = normalizedNewContent.querySelector('head')\n    if (oldHead && newHead) {\n      const promises = handleHeadElement(newHead, oldHead, ctx)\n      // when head promises resolve, call morph again, ignoring the head tag\n      Promise.all(promises).then(() => {\n        morphNormalizedContent(\n          oldNode,\n          normalizedNewContent,\n          Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          }),\n        )\n      })\n      return\n    }\n  }\n\n  if (ctx.morphStyle === 'innerHTML') {\n    // innerHTML, so we are only updating the children\n    morphChildren(normalizedNewContent, oldNode, ctx)\n    return oldNode.children\n  } else if (ctx.morphStyle === 'outerHTML' || ctx.morphStyle == null) {\n    // otherwise find the best element match in the new content, morph that, and merge its siblings\n    // into either side of the best match\n    const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx)\n    if (!bestMatch) throw new Error('Could not find best match')\n\n    // stash the siblings that will need to be inserted on either side of the best match\n    const previousSibling = bestMatch?.previousSibling as Element\n    const nextSibling = bestMatch?.nextSibling as Element\n\n    // morph it\n    const morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx)\n\n    if (bestMatch) {\n      // if there was a best match, merge the siblings in too and return the\n      // whole bunch\n      return insertSiblings(previousSibling, morphedNode, nextSibling)\n    } else {\n      // otherwise nothing was added to the DOM\n      return []\n    }\n  } else {\n    throw 'Do not understand how to morph style ' + ctx.morphStyle\n  }\n}\n\n/**\n * @param oldNode root node to merge content into\n * @param newContent new content to merge\n * @param ctx the merge context\n * @returns {Element} the element that ended up in the DOM\n */\nfunction morphOldNodeTo(oldNode: Element, newContent: Element, ctx: any) {\n  if (ctx.ignoreActive && oldNode === document.activeElement) {\n    // don't morph focused element\n  } else if (newContent == null) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n\n    oldNode.remove()\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return\n  } else if (!isSoftMatch(oldNode, newContent)) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n    if (ctx.callbacks.beforeNodeAdded(newContent) === false) return\n\n    if (!oldNode.parentElement) throw new Error('oldNode has no parentElement')\n    oldNode.parentElement.replaceChild(newContent, oldNode)\n    ctx.callbacks.afterNodeAdded(newContent)\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return newContent\n  } else {\n    if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return\n\n    if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n      // ignore the head element\n    } else if (\n      newContent instanceof HTMLHeadElement &&\n      oldNode instanceof HTMLHeadElement &&\n      ctx.head.style !== 'morph'\n    ) {\n      handleHeadElement(newContent, oldNode, ctx)\n    } else {\n      syncNodeFrom(newContent, oldNode)\n      morphChildren(newContent, oldNode, ctx)\n    }\n    ctx.callbacks.afterNodeMorphed(oldNode, newContent)\n    return oldNode\n  }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n * @param {Element} newParent the parent element of the new content\n * @param {Element } oldParent the old content that we are merging the new content into\n * @param ctx the merge context\n */\nfunction morphChildren(newParent: Element, oldParent: Element, ctx: any) {\n  let nextNewChild = newParent.firstChild as Element | null\n  let insertionPoint = oldParent.firstChild as Element | null\n  let newChild\n\n  // run through all the new content\n  while (nextNewChild) {\n    newChild = nextNewChild\n    nextNewChild = newChild.nextSibling as Element | null\n\n    // if we are at the end of the exiting parent's children, just append\n    if (insertionPoint == null) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n      oldParent.appendChild(newChild)\n      ctx.callbacks.afterNodeAdded(newChild)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // if the current node has an id set match then morph\n    if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n      morphOldNodeTo(insertionPoint, newChild, ctx)\n      insertionPoint = insertionPoint.nextSibling as Element | null\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // otherwise search forward in the existing old children for an id set match\n    let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx)\n\n    // if we found a potential match, remove the nodes until that point and morph\n    if (idSetMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx)\n      morphOldNodeTo(idSetMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // no id set match found, so scan forward for a soft match for the current node\n    let softMatch = findSoftMatch(newParent, newChild, insertionPoint, ctx)\n\n    // if we found a soft match for the current node, morph\n    if (softMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx)\n      morphOldNodeTo(softMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // abandon all hope of morphing, just insert the new child before the insertion point\n    // and move on\n    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n    oldParent.insertBefore(newChild, insertionPoint)\n    ctx.callbacks.afterNodeAdded(newChild)\n    removeIdsFromConsideration(ctx, newChild)\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint !== null) {\n    let tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling as Element | null\n    removeNode(tempNode, ctx)\n  }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\n/**\n * syncs a given node with another node, copying over all attributes and\n * inner element state from the 'from' node to the 'to' node\n *\n * @param {Element} from the element to copy attributes & state from\n * @param {Element} to the element to copy attributes & state to\n */\nfunction syncNodeFrom(from: Element, to: Element) {\n  let type = from.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    for (const fromAttribute of from.attributes) {\n      const toAttribute = to.getAttribute(fromAttribute.name)\n      if (toAttribute !== fromAttribute.value) {\n        to.setAttribute(fromAttribute.name, fromAttribute.value)\n      }\n    }\n    for (const toAttribute of to.attributes) {\n      if (!from.hasAttribute(toAttribute.name)) {\n        to.removeAttribute(toAttribute.name)\n      }\n    }\n  }\n\n  // sync text nodes\n  if (type === Node.COMMENT_NODE || type === Node.TEXT_NODE) {\n    if (to.nodeValue !== from.nodeValue) {\n      to.nodeValue = from.nodeValue\n    }\n  }\n\n  // NB: many bothans died to bring us information:\n  //\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  // https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n\n  // sync input value\n  if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== 'file') {\n    to.value = from.value || ''\n    syncAttribute(from, to, 'value')\n\n    // sync boolean attributes\n    syncAttribute(from, to, 'checked')\n    syncAttribute(from, to, 'disabled')\n  } else if (from instanceof HTMLOptionElement) {\n    syncAttribute(from, to, 'selected')\n  } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n    const fromValue = from.value\n    const toValue = to.value\n    if (fromValue !== toValue) {\n      to.value = fromValue\n    }\n    if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n      to.firstChild.nodeValue = fromValue\n    }\n  }\n}\n\nfunction syncAttribute(from: Element, to: Element, attributeName: string) {\n  const fAttr = from.getAttribute(attributeName)\n  const tAttr = to.getAttribute(attributeName)\n\n  if (fAttr !== tAttr) {\n    if (fAttr) {\n      to.setAttribute(attributeName, fAttr)\n    } else {\n      to.removeAttribute(attributeName)\n    }\n  }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(newHeadTag: HTMLHeadElement, currentHead: HTMLHeadElement, ctx: any) {\n  const added = []\n  const removed = []\n  const preserved = []\n  const nodesToAppend = []\n\n  const headMergeStyle = ctx.head.style\n\n  // put all new head elements into a Map, by their outerHTML\n  const srcToNewHeadNodes = new Map()\n  for (const newHeadChild of newHeadTag.children) {\n    srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild)\n  }\n\n  // for each elt in the current head\n  for (const currentHeadElt of currentHead.children) {\n    // If the current head element is in the map\n    let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML)\n    let isReAppended = ctx.head.shouldReAppend(currentHeadElt)\n    let isPreserved = ctx.head.shouldPreserve(currentHeadElt)\n    if (inNewContent || isPreserved) {\n      if (isReAppended) {\n        // remove the current version and let the new version replace it and re-execute\n        removed.push(currentHeadElt)\n      } else {\n        // this element already exists and should not be re-appended, so remove it from\n        // the new content map, preserving it in the DOM\n        srcToNewHeadNodes.delete(currentHeadElt.outerHTML)\n        preserved.push(currentHeadElt)\n      }\n    } else {\n      if (headMergeStyle === 'append') {\n        // we are appending and this existing element is not new content\n        // so if and only if it is marked for re-append do we do anything\n        if (isReAppended) {\n          removed.push(currentHeadElt)\n          nodesToAppend.push(currentHeadElt)\n        }\n      } else {\n        // if this is a merge, we remove this content since it is not in the new head\n        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n          removed.push(currentHeadElt)\n        }\n      }\n    }\n  }\n\n  // Push the remaining new head elements in the Map into the\n  // nodes to append to the head tag\n  nodesToAppend.push(...srcToNewHeadNodes.values())\n  console.log('to append: ', nodesToAppend)\n\n  const promises = []\n  for (const newNode of nodesToAppend) {\n    console.log('adding: ', newNode)\n    const newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild as Element | null\n    if (!newElt) throw new Error('could not create new element from: ' + newNode.outerHTML)\n    console.log(newElt)\n    if (!!ctx.callbacks.beforeNodeAdded(newElt)) {\n      if (newElt.hasAttribute('href') || newElt.hasAttribute('src')) {\n        let resolver: (value: unknown) => void\n        const promise = new Promise((resolve) => {\n          resolver = resolve\n        })\n        newElt.addEventListener('load', function () {\n          resolver(undefined)\n        })\n        promises.push(promise)\n      }\n      currentHead.appendChild(newElt)\n      ctx.callbacks.afterNodeAdded(newElt)\n      added.push(newElt)\n    }\n  }\n\n  // remove all removed elements, after we have appended the new elements to avoid\n  // additional network requests for things like style sheets\n  for (const removedElement of removed) {\n    if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n      currentHead.removeChild(removedElement)\n      ctx.callbacks.afterNodeRemoved(removedElement)\n    }\n  }\n\n  ctx.head.afterHeadMorphed(currentHead, {\n    added: added,\n    kept: preserved,\n    removed: removed,\n  })\n  return promises\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\nfunction noOp() {}\n\nfunction createMorphContext(oldNode: Element, newContent: Element, config: any) {\n  return {\n    target: oldNode,\n    newContent: newContent,\n    config: config,\n    morphStyle: config.morphStyle,\n    ignoreActive: config.ignoreActive,\n    idMap: createIdMap(oldNode, newContent),\n    deadIds: new Set(),\n    callbacks: Object.assign(\n      {\n        beforeNodeAdded: noOp,\n        afterNodeAdded: noOp,\n        beforeNodeMorphed: noOp,\n        afterNodeMorphed: noOp,\n        beforeNodeRemoved: noOp,\n        afterNodeRemoved: noOp,\n      },\n      config.callbacks,\n    ),\n    head: Object.assign(\n      {\n        style: 'merge',\n        shouldPreserve: (elt: Element) => elt.getAttribute('im-preserve') === 'true',\n        shouldReAppend: (elt: Element) => elt.getAttribute('im-re-append') === 'true',\n        shouldRemove: noOp,\n        afterHeadMorphed: noOp,\n      },\n      config.head,\n    ),\n  }\n}\n\nfunction isIdSetMatch(node1: Element, node2: Element, ctx: any) {\n  if (!node1 || !node2) return false\n\n  if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n    if (node1?.id?.length && node1.id === node2.id) return true\n\n    return getIdIntersectionCount(ctx, node1, node2) > 0\n  }\n  return false\n}\n\nfunction isSoftMatch(node1: Element, node2: Element) {\n  if (!node1 || !node2) return false\n\n  return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n}\n\nfunction removeNodesBetween(startInclusive: Element, endExclusive: Element, ctx: any) {\n  while (startInclusive !== endExclusive) {\n    const tempNode = startInclusive\n    startInclusive = startInclusive?.nextSibling as Element\n    if (!tempNode) throw new Error('tempNode is null')\n    removeNode(tempNode, ctx)\n  }\n  removeIdsFromConsideration(ctx, endExclusive)\n  return endExclusive.nextSibling as Element | null\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(newContent: Element, oldParent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  // max id matches we are willing to discard in our search\n  const newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent)\n\n  let potentialMatch: Element | null = null\n\n  // only search forward if there is a possibility of an id match\n  if (newChildPotentialIdCount > 0) {\n    potentialMatch = insertionPoint\n    // if there is a possibility of an id match, scan forward\n    // keep track of the potential id match count we are discarding (the\n    // newChildPotentialIdCount must be greater than this to make it likely\n    // worth it)\n    let otherMatchCount = 0\n    while (potentialMatch != null) {\n      // If we have an id match, return the current potential match\n      if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n        return potentialMatch\n      }\n\n      // computer the other potential matches of this new content\n      otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent)\n      if (otherMatchCount > newChildPotentialIdCount) {\n        // if we have more potential id matches in _other_ content, we\n        // do not have a good candidate for an id match, so return null\n        return null\n      }\n\n      // advanced to the next old content child\n      potentialMatch = potentialMatch.nextSibling as Element | null\n    }\n  }\n  return potentialMatch\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(newContent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  let potentialSoftMatch = insertionPoint as Element | null\n  let nextSibling = newChild.nextSibling as Element | null\n\n  let siblingSoftMatchCount = 0\n\n  while (potentialSoftMatch && nextSibling) {\n    if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n      // the current potential soft match has a potential id set match with the remaining new\n      // content so bail out of looking\n      return null\n    }\n\n    // if we have a soft match with the current node, return it\n    if (isSoftMatch(newChild, potentialSoftMatch)) {\n      return potentialSoftMatch\n    }\n\n    if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n      // the next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling as Element | null\n\n      // If there are two future soft matches, bail to allow the siblings to soft match\n      // so that we don't consume future soft matches for the sake of the current node\n      if (siblingSoftMatchCount >= 2) {\n        return null\n      }\n    }\n\n    // advanced to the next old content child\n    potentialSoftMatch = potentialSoftMatch.nextSibling as Element | null\n  }\n\n  return potentialSoftMatch\n}\n\nconst parser = new DOMParser()\nfunction parseContent(newContent: string) {\n  // remove svgs to avoid false-positive matches on head, etc.\n  const contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '')\n\n  // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n  if (\n    contentWithSvgsRemoved.match(/<\\/html>/) ||\n    contentWithSvgsRemoved.match(/<\\/head>/) ||\n    contentWithSvgsRemoved.match(/<\\/body>/)\n  ) {\n    const content = parser.parseFromString(newContent, 'text/html')\n    // if it is a full HTML document, return the document itself as the parent container\n    if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n      generatedByIdiomorphId.add(content)\n      return content\n    } else {\n      // otherwise return the html element as the parent container\n      let Element = content.firstChild\n      if (Element) {\n        generatedByIdiomorphId.add(Element)\n        return Element as Element\n      } else {\n        return null\n      }\n    }\n  } else {\n    // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n    // deal with touchy tags like tr, tbody, etc.\n    const responseDoc = parser.parseFromString(`<body><template>${newContent}</template></body>`, 'text/html')\n    const content = responseDoc.body.querySelector('template')?.content\n    if (!content) throw new Error('content is null')\n    generatedByIdiomorphId.add(content)\n    return content\n  }\n}\n\nfunction normalizeContent(newContent: Element) {\n  if (newContent == null) {\n    // noinspection UnnecessaryLocalVariableJS\n    const dummyParent = document.createElement('div')\n    return dummyParent\n  } else if (generatedByIdiomorphId.has(newContent)) {\n    // the template tag created by idiomorph parsing can serve as a dummy parent\n    return newContent\n  } else if (newContent instanceof Node) {\n    // a single node is added as a child to a dummy parent\n    const dummyParent = document.createElement('div')\n    dummyParent.append(newContent)\n    return dummyParent\n  } else {\n    // all nodes in the array or Element collection are consolidated under\n    // a single dummy parent element\n    const dummyParent = document.createElement('div')\n    for (const elt of [...newContent]) {\n      dummyParent.append(elt)\n    }\n    return dummyParent\n  }\n}\n\nfunction insertSiblings(previousSibling?: Element, morphedNode?: Element, nextSibling?: Element) {\n  const stack = []\n  const added = []\n  while (previousSibling) {\n    stack.push(previousSibling)\n    previousSibling = previousSibling.previousSibling as Element\n  }\n  while (stack.length > 0) {\n    const node = stack.pop()!\n    added.push(node) // push added preceding siblings on in order and insert\n    morphedNode?.parentElement?.insertBefore(node, morphedNode)\n  }\n  added.push(morphedNode)\n  while (nextSibling) {\n    stack.push(nextSibling)\n    added.push(nextSibling) // here we are going in order, so push on as we scan, rather than add\n    nextSibling = nextSibling.nextSibling as Element\n  }\n  while (stack.length) {\n    morphedNode?.parentElement?.insertBefore(stack.pop()!, morphedNode.nextSibling)\n  }\n  return added\n}\n\nfunction findBestNodeMatch(newContent: Element, oldNode: Element, ctx: any) {\n  let currentElement = newContent.firstChild as Element | null\n  let bestElement = currentElement\n  let score = 0\n  while (currentElement) {\n    let newScore = scoreElement(currentElement, oldNode, ctx)\n    if (newScore > score) {\n      bestElement = currentElement\n      score = newScore\n    }\n    currentElement = currentElement.nextSibling as Element | null\n  }\n  return bestElement\n}\n\nfunction scoreElement(node1: Element, node2: Element, ctx: any) {\n  if (isSoftMatch(node1, node2)) {\n    return 0.5 + getIdIntersectionCount(ctx, node1, node2)\n  }\n  return 0\n}\n\nfunction removeNode(tempNode: Element, ctx: any) {\n  removeIdsFromConsideration(ctx, tempNode)\n  if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return\n\n  tempNode.remove()\n  ctx.callbacks.afterNodeRemoved(tempNode)\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: any, id: string) {\n  return !ctx.deadIds.has(id)\n}\n\nfunction idIsWithinNode(ctx: any, id: string, targetNode: Element) {\n  return ctx.idMap.get(targetNode)?.has(id) || false\n}\n\nfunction removeIdsFromConsideration(ctx: any, node: Element) {\n  const idSet = ctx.idMap.get(node)\n  if (!idSet) return\n  for (const id of idSet) {\n    ctx.deadIds.add(id)\n  }\n}\n\nfunction getIdIntersectionCount(ctx: any, node1: Element, node2: Element) {\n  const sourceSet = ctx.idMap.get(node1)\n  if (!sourceSet) return 0\n\n  let matchCount = 0\n  for (const id of sourceSet) {\n    // a potential match is an id in the source and potentialIdsSet, but\n    // that has not already been merged into the DOM\n    if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n      ++matchCount\n    }\n  }\n  return matchCount\n}\n\n/**\n * A bottom up algorithm that finds all elements with ids inside of the node\n * argument and populates id sets for those nodes and all their parents, generating\n * a set of ids contained within all nodes for the entire hierarchy in the DOM\n *\n * @param node {Element}\n * @param {Map<Node, Set<String>>} idMap\n */\nfunction populateIdMapForNode(node: Element, idMap: Map<Element, Set<string>>) {\n  const nodeParent = node.parentElement\n  // find all elements with an id property\n  const idElements = node.querySelectorAll('[id]')\n  for (const elt of idElements) {\n    let current = elt as Element | null\n    // walk up the parent hierarchy of that element, adding the id\n    // of element to the parent's id set\n    while (current !== nodeParent && !!current) {\n      let idSet = idMap.get(current)\n      // if the id set doesn't exist, create it and insert it in the  map\n      if (idSet == null) {\n        idSet = new Set()\n        idMap.set(current, idSet)\n      }\n      idSet.add(elt.id)\n      current = current.parentElement\n    }\n  }\n}\n\n/**\n * This function computes a map of nodes to all ids contained within that node (inclusive of the\n * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n * to contribute to a parent nodes matching.\n *\n * @param {Element} oldContent  the old content that will be morphed\n * @param {Element} newContent  the new content to morph to\n * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n */\nfunction createIdMap(oldContent: Element, newContent: Element) {\n  const idMap = new Map()\n  populateIdMapForNode(oldContent, idMap)\n  populateIdMapForNode(newContent, idMap)\n  return idMap\n}\n","import { ActionArgs } from '..'\nimport { addActionPlugin, applyPlugins, toHTMLorSVGElement } from '../core'\nimport { idiomorph } from '../external/idiomorph'\nimport { Reactive } from '../external/reactively'\nconst p = new DOMParser()\nconst DATASTAR_CLASS_PREFIX = 'datastar'\nconst INDICATOR_CLASS = `${DATASTAR_CLASS_PREFIX}-indicator`\nconst LOADING_CLASS = `${DATASTAR_CLASS_PREFIX}-request`\nconst ACCEPT = 'Accept',\n  TEXT_HTML = 'text/html',\n  CONTENT_TYPE = 'Content-Type',\n  APPLICATION_JSON = 'application/json',\n  SELECTOR = 'selector',\n  SWAP = 'swap'\n\nexport const GET = 'get'\nexport const addGetPlugin = () => addFetchMethod(GET)\nexport const POST = 'post'\nexport const addPostPlugin = () => addFetchMethod(POST)\nexport const PUT = 'put'\nexport const addPutPlugin = () => addFetchMethod(PUT)\nexport const PATCH = 'patch'\nexport const addPatchPlugin = () => addFetchMethod(PATCH)\nexport const DELETE = 'delete'\nexport const addDeletePlugin = () => addFetchMethod(DELETE)\n\nexport const addAllFragmentPlugins = () => {\n  addGetPlugin()\n  addPostPlugin()\n  addPutPlugin()\n  addPatchPlugin()\n  addDeletePlugin()\n}\n\nlet hasInjectedStyles = false\nfunction addFetchMethod(method: string) {\n  if (!hasInjectedStyles) {\n    const style = document.createElement('style')\n    style.innerHTML = `\n.${INDICATOR_CLASS}{\n  opacity:0;\n  transition: opacity 500ms ease-in;\n}\n.${LOADING_CLASS} .${INDICATOR_CLASS}{\n    opacity:1\n}\n.${LOADING_CLASS}.${INDICATOR_CLASS}{\n    opacity:1\n}\n    `\n    document.head.appendChild(style)\n    hasInjectedStyles = true\n  }\n\n  addActionPlugin({\n    name: method,\n    description: `turns @${method}(args) into fetch(${method}, args)`,\n    fn: async (args: ActionArgs) => fetcher(method, args),\n  })\n}\n\nasync function fetcher(method: string, args: ActionArgs) {\n  const { el: elRaw, dataStack } = args\n\n  const urlSignal: Reactive<string> = dataStack.signals?.[method]\n  if (!urlSignal) throw new Error(`No signal for ${method}`)\n\n  const el = toHTMLorSVGElement(elRaw)\n  if (!el) throw new Error('Element must be an HTMLElement or SVGElement')\n\n  el.classList.add(LOADING_CLASS)\n\n  const url = new URL(urlSignal.value, window.location.origin)\n\n  const headers = new Headers()\n\n  headers.append(ACCEPT, TEXT_HTML)\n  headers.append(CONTENT_TYPE, APPLICATION_JSON)\n\n  if (dataStack?.headers) {\n    for (let name in dataStack.headers) {\n      const signal = dataStack.headers[name]\n      headers.append(name, signal.value)\n    }\n  }\n\n  const dataStackJSON = JSON.stringify(dataStack, (_, value) => {\n    if (value instanceof Reactive) {\n      if (value.isEffect) return undefined\n      return value.get()\n    }\n    return value\n  })\n  const req: RequestInit = { method, headers }\n  if (method === GET) {\n    const queryParams = new URLSearchParams(url.search)\n    queryParams.append('dataStack', dataStackJSON)\n    url.search = queryParams.toString()\n  } else {\n    req.body = dataStackJSON\n  }\n\n  const res = await fetch(url, req)\n  if (!res.ok) throw new Error('Network response was not ok.')\n  const html = await res.text()\n\n  const dom = [...p.parseFromString(html, TEXT_HTML).body.children]\n  for (let i = 0; i < dom.length; i++) {\n    const frag = dom[i]\n    if (!(frag instanceof Element)) {\n      throw new Error('Not an element')\n    }\n    const fragElement = toHTMLorSVGElement(frag)\n\n    const id = frag.getAttribute('id')\n    const firstFrag = i === 0\n    const hasID = !!id?.length\n    const useElAsTarget = firstFrag && !hasID\n\n    let targets: Iterable<Element>\n    if (useElAsTarget) {\n      targets = [elRaw]\n    } else {\n      if (!hasID) throw new Error('No id')\n\n      const targetSelector = fragElement?.dataset?.[SELECTOR] || `#${id}`\n      targets = document.querySelectorAll(targetSelector) || []\n    }\n    if (!!!targets) throw new Error('No target element')\n\n    for (const target of targets) {\n      const merge = fragElement?.dataset?.[SWAP] || 'morph'\n      switch (merge) {\n        case 'morph':\n          idiomorph(target, frag)\n          break\n        case 'inner':\n          target.innerHTML = frag.innerHTML //  The default, replace the inner html of the target element\n          break\n        case 'outer':\n          target.outerHTML = frag.outerHTML //  Replace the entire target element with the response\n          break\n        case 'prepend':\n          target.prepend(frag.outerHTML) //  Insert the response before the first child of the target element\n          break\n        case 'append':\n          target.append(frag.outerHTML) //  Insert the response after the last child of the target element\n          break\n        case 'before':\n          target.before(frag) //  Insert the response before the target element\n          break\n        case 'after':\n          target.after(frag) //  Insert the response after the target element\n          break\n        case 'delete':\n          target.remove() //  Deletes the target element regardless of the response\n          break\n        default:\n          throw new Error('Invalid merge mode')\n      }\n      applyPlugins(target)\n    }\n  }\n\n  el.classList.remove(LOADING_CLASS)\n}\n","import { SIGNAL } from '.'\nimport { addDataPlugin, uniqueId } from '../core'\n\nexport const MODEL = 'model'\nconst updateEvents = ['change', 'input', 'keydown']\nexport function addModelDataPlugin() {\n  addDataPlugin(MODEL, {\n    allowedTags: ['input', 'textarea', 'select'],\n    requiredPlugins: [SIGNAL],\n\n    withExpression: ({ name, el, expression, dataStack, reactivity: { effect, onCleanup } }) => {\n      const signal = dataStack.signals[expression]\n      if (!signal) {\n        throw new Error(`Signal ${expression} not found`)\n      }\n\n      if (!('value' in el)) throw new Error('Element must have a value property')\n      el.value = signal.value\n\n      const setter = () => {\n        const current = signal.value\n        if (typeof current === 'number') {\n          signal.value = Number(el.value)\n        } else if (typeof current === 'string') {\n          signal.value = el.value\n        } else if (typeof current === 'boolean') {\n          signal.value = Boolean(el.value)\n        } else {\n          throw new Error('Unsupported type')\n        }\n      }\n\n      return {\n        model: {\n          [`${name}-${uniqueId()}`]: effect(() => {\n            el.value = signal.value\n\n            for (const event of updateEvents) {\n              el.addEventListener(event, setter)\n            }\n\n            onCleanup(() => {\n              for (const event of updateEvents) {\n                el.removeEventListener(event, setter)\n              }\n            })\n          }),\n        },\n      }\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataPlugin } from '../core'\n\nexport const ON = 'on'\n\nconst ONCE = 'once',\n  THROTTLE = 'throttle',\n  DEBOUNCE = 'debounce',\n  LEADING = 'leading'\n\nexport function addOnDataPlugin() {\n  addDataPlugin(ON, {\n    requiredPlugins: [SIGNAL],\n    allowedModifiers: [ONCE, THROTTLE, DEBOUNCE, LEADING],\n    withExpression: ({\n      el,\n      name,\n      hasMod,\n      withMod,\n      expression,\n      dataStack,\n      reactivity: { computed, effect, onCleanup },\n      actions,\n    }) => {\n      const signalFn = functionGenerator(expression)\n\n      const hasOnce = hasMod(ONCE)\n      const throttleMod = withMod(THROTTLE)\n      const debounceMod = withMod(DEBOUNCE)\n      const hasLeading = hasMod(LEADING)\n\n      if (name === 'load') {\n        document.addEventListener('DOMContentLoaded', () => signalFn(el, dataStack, actions), true)\n        return\n      }\n\n      const fn = () => signalFn(el, dataStack, actions)\n      let wrappedFnCallback: Function = fn\n      let callback: () => void\n\n      if (hasOnce) {\n        wrappedFnCallback = () => {\n          fn()\n          if (callback) {\n            el.removeEventListener(name, callback)\n          }\n        }\n      } else if (!!throttleMod) {\n        const [throttleTimeRaw] = throttleMod.args\n        const throttleTime = throttleTimeRaw ? Number(throttleTimeRaw) : 1000\n\n        let prev = 0\n        const throttledFn = computed(() => {\n          const now = Date.now()\n          const delta = now - prev\n          if (delta >= throttleTime) {\n            prev = now\n            return fn()\n          }\n        })\n\n        wrappedFnCallback = () => throttledFn.value\n      } else if (!!debounceMod) {\n        const [debounceTimeRaw] = debounceMod.args\n        const debounceTime = debounceTimeRaw ? Number(debounceTimeRaw) : 1000\n\n        let timerID: ReturnType<typeof setTimeout> | undefined\n        const debouncedFn = computed(() => {\n          if (hasLeading && !timerID) {\n            fn()\n          }\n          clearTimeout(timerID)\n          timerID = setTimeout(() => {\n            if (hasLeading) timerID = undefined\n            else fn()\n          }, debounceTime)\n        })\n\n        wrappedFnCallback = () => debouncedFn.value\n      }\n\n      callback = () => wrappedFnCallback()\n\n      el.addEventListener(name, callback)\n\n      const elementData: NamespacedReactiveRecords = {\n        on: {\n          [name]: effect(() => {\n            onCleanup(() => {\n              if (hasOnce) return\n\n              el.removeEventListener(name, callback)\n            })\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL } from '..'\nimport { addDataPlugin } from '../core'\n\nexport const REF = 'ref'\nexport function addRefDataPlugin() {\n  addDataPlugin(REF, {\n    requiredPlugins: [SIGNAL],\n    preprocessExpressions: [\n      {\n        name: 'ref',\n        description: 'turns #ref into data.refs.ref.value',\n        regexp: new RegExp(/(?<whole>\\#(?<ref>[a-zA-Z_$][0-9a-zA-Z_$]*))/g),\n        replacer: ({ ref }) => `data.refs.${ref}.value`,\n      },\n    ],\n    withExpression: ({ el, name, reactivity: { signal } }) => {\n      const elementData: NamespacedReactiveRecords = {\n        refs: {\n          [name]: signal(el),\n        },\n      }\n      return elementData\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataPlugin } from '../core'\n\nconst IMPORTANT = 'important',\n  DISPLAY = 'display',\n  NONE = 'none'\n\nexport const SHOW = 'show'\nexport function addShowDataPlugin() {\n  addDataPlugin(SHOW, {\n    requiredPlugins: [SIGNAL],\n    allowedModifiers: [IMPORTANT],\n    withExpression: ({ el, name, dataStack, expression, hasMod, reactivity: { effect }, actions }) => {\n      const signalFn = functionGenerator(expression)\n\n      if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n        throw new Error('Element must have a style property')\n      }\n\n      const isImportant = hasMod(IMPORTANT)\n      const priority = isImportant ? IMPORTANT : undefined\n\n      const elementData: NamespacedReactiveRecords = {\n        show: {\n          [name]: effect(() => {\n            const shouldShow = !!signalFn(el, dataStack, actions)\n            if (shouldShow) {\n              if (el.style.length === 1 && el.style.display === NONE) {\n                el.style.removeProperty(DISPLAY)\n              } else {\n                el.style.setProperty(DISPLAY, '', priority)\n              }\n            } else {\n              el.style.setProperty(DISPLAY, NONE, priority)\n            }\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { functionEval } from '..'\nimport { addDataPlugin } from '../core'\nimport { ACTION } from './actions'\n\nexport const SIGNAL = 'signal'\n\nconst PERSIST_KEY = 'persist'\nexport function addSignalDataPlugin() {\n  addDataPlugin(SIGNAL, {\n    requiredPlugins: [ACTION],\n    preprocessExpressions: [\n      {\n        name: 'signal',\n        description: 'turns $signal into dataStack.signals.signal.value',\n        regexp: new RegExp(/(?<whole>\\$(?<signal>[a-zA-Z_$][0-9a-zA-Z_$]*))/g),\n        replacer: ({ signal }) => `dataStack.${SIGNAL}s.${signal}.value`,\n      },\n    ],\n    allowedModifiers: [PERSIST_KEY],\n    withExpression: ({ name, el, expression, reactivity, hasMod, actions }) => {\n      const signal = reactivity.signal(functionEval(el, {}, actions, expression))\n\n      if (hasMod(PERSIST_KEY)) {\n        const value = localStorage.getItem(name)\n        if (value) {\n          const parsedValue = JSON.parse(value)\n          signal.value = parsedValue\n        }\n\n        reactivity.effect(() => {\n          const value = JSON.stringify(signal.value)\n          localStorage.setItem(name, value)\n        })\n      }\n\n      return {\n        signals: {\n          [name]: signal,\n        },\n      }\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataPlugin, toHTMLorSVGElement } from '../core'\n\nconst PREPEND = 'prepend',\n  APPEND = 'append',\n  MUST_PARENT_ERR = 'Target element must have a parent if using prepend or append'\n\nexport const TELEPORT = 'teleport'\nexport function addTeleportDataPlugin() {\n  addDataPlugin(TELEPORT, {\n    requiredPlugins: [SIGNAL],\n    allowedModifiers: [PREPEND, APPEND],\n    withExpression: ({ name, el, expression, dataStack, reactivity: { effect }, hasMod, actions }) => {\n      if (!(el instanceof HTMLTemplateElement)) {\n        throw new Error('Element must be a template')\n      }\n\n      const signalFn = functionGenerator(expression)\n\n      const elementData: NamespacedReactiveRecords = {\n        text: {\n          [name]: effect(() => {\n            const res = signalFn(el, dataStack, actions)\n            if (typeof res !== 'string') throw new Error('Selector must be a string')\n            const target = document.querySelector(res)\n            if (!target) throw new Error(`Target element not found: ${res}`)\n\n            if (!el.content) throw new Error('Template element must have content')\n            const n = el.content.cloneNode(true)\n            const nEl = toHTMLorSVGElement(n as Element)\n            if (nEl?.firstElementChild) throw new Error('Empty template')\n\n            if (hasMod(PREPEND)) {\n              if (!target.parentNode) throw new Error(MUST_PARENT_ERR)\n              target.parentNode.insertBefore(n, target)\n            } else if (hasMod(APPEND)) {\n              if (!target.parentNode) throw new Error(MUST_PARENT_ERR)\n              target.parentNode.insertBefore(n, target.nextSibling)\n            } else {\n              target.appendChild(n)\n            }\n            target.appendChild(n)\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { NamespacedReactiveRecords, functionGenerator } from '..'\nimport { addDataPlugin } from '../core'\n\nexport const TEXT = 'text'\nexport function addTextDataPlugin() {\n  addDataPlugin(TEXT, {\n    withExpression: ({ name, el, expression, dataStack, actions, reactivity: { effect } }) => {\n      const signalFn = functionGenerator(expression)\n\n      const elementData: NamespacedReactiveRecords = {\n        text: {\n          [name]: effect(() => {\n            if (!dataStack?.signals) return\n            const res = signalFn(el, dataStack, actions)\n            el.textContent = `${res}`\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataPlugin } from '../core'\n\nconst once = 'once',\n  full = 'full',\n  half = 'half'\n\nexport const INTERSECTS = 'intersects'\nexport function addIntersectsplugin() {\n  addDataPlugin(INTERSECTS, {\n    requiredPlugins: [SIGNAL],\n    allowedModifiers: [once, full, half],\n    withExpression: ({ name, el, expression, dataStack, actions, hasMod, reactivity: { effect, onCleanup } }) => {\n      const signalFn = functionGenerator(expression)\n      const fn = () => signalFn(el, dataStack, actions)\n\n      const options = { threshold: 0 }\n      if (hasMod(full)) options.threshold = 1\n      else if (hasMod(half)) options.threshold = 0.5\n\n      const observer = new IntersectionObserver((entries) => {\n        entries.forEach((entry) => {\n          if (entry.isIntersecting) {\n            fn()\n\n            if (hasMod(once)) {\n              observer.disconnect()\n            }\n          }\n        })\n      }, options)\n\n      const elementData: NamespacedReactiveRecords = {\n        on: {\n          [name]: effect(() => {\n            observer.observe(el)\n\n            onCleanup(() => {\n              observer.disconnect()\n            })\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { addActionDataPlugin } from './actions.js'\nimport { addBindDataPlugin } from './bind.js'\nimport { addFocusDataPlugin } from './focus.js'\nimport { addAllFragmentPlugins } from './fragments.js'\nimport { addModelDataPlugin } from './model.js'\nimport { addOnDataPlugin } from './on.js'\nimport { addRefDataPlugin } from './ref.js'\nimport { addShowDataPlugin } from './show.js'\nimport { addSignalDataPlugin } from './signal.js'\nimport { addTeleportDataPlugin } from './teleport.js'\nimport { addTextDataPlugin } from './text.js'\n\nexport * from './bind.js'\nexport * from './focus.js'\nexport * from './fragments.js'\nexport * from './intersects.js'\nexport * from './on.js'\nexport * from './ref.js'\nexport * from './show.js'\nexport * from './signal.js'\nexport * from './teleport.js'\nexport * from './text.js'\n\nexport function addAllIncludedPlugins() {\n  addActionDataPlugin()\n  addSignalDataPlugin()\n  addBindDataPlugin()\n  addModelDataPlugin()\n  addFocusDataPlugin()\n  addAllFragmentPlugins()\n  addOnDataPlugin()\n  addRefDataPlugin()\n  addShowDataPlugin()\n  addTeleportDataPlugin()\n  addTextDataPlugin()\n}\n"],"names":["walkDownDOM","el","callback","walkUpDOM","functionGenerator","str","fnContents","functionEval","dataStack","actions","fn","camelize","word","index","injectMockFetch","routes","mockFetch","url","init","req","urlMethods","methodFn","html","status","statusText","headers","CurrentReaction","CurrentGets","CurrentGetsIndex","EffectQueue","stabilizeFn","stabilizationQueued","CacheClean","CacheCheck","CacheDirty","reactive","fnOrValue","params","node","Reactive","defaultEquality","a","b","isEffect","v","value","i","state","oldValue","prevReaction","prevGets","prevIndex","c","source","observer","swap","onCleanup","stabilize","autoStabilize","deferredStabilize","signal","initialValue","computed","effect","pluginObserver","mutations","m","pluginElementRegistry","useProcessor","regexp","replacer","matches","match","groups","whole","prefixHashes","pluginApplyFunctions","pluginPreprocessStack","data","applyPlugins","element","name","addDataPlugin","prefix","args","hash","plugin","pluginsRegistered","requiredPlugin","allAllowedModifiers","modifier","allowedTags","t","registerPluginOnElement","parentEl","toHTMLorSVGElement","plugins","tagLower","d","modifiersWithArgsArr","pl","pl1","modifiers","label","allowedModifier","loadDataStack","expression","preprocessor","elementData","postExpression","withModifier","hasModifier","stack","elData","namespacedRecords","namespaceKey","addActionPlugin","requiredPlugins","pluginHashes","ACTION","ext","nextID","uniqueId","addActionDataPlugin","action","BIND","addBindDataPlugin","SIGNAL","signalFn","res","FOCUS","addFocusDataPlugin","generatedByIdiomorphId","idiomorph","oldNode","newContent","config","parsedContent","parseContent","normalizedContent","normalizeContent","ctx","createMorphContext","morphNormalizedContent","normalizedNewContent","oldHead","newHead","promises","handleHeadElement","morphChildren","bestMatch","findBestNodeMatch","previousSibling","nextSibling","morphedNode","morphOldNodeTo","insertSiblings","isSoftMatch","syncNodeFrom","newParent","oldParent","nextNewChild","insertionPoint","newChild","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","from","to","type","fromAttribute","toAttribute","syncAttribute","fromValue","toValue","attributeName","fAttr","tAttr","newHeadTag","currentHead","added","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","newHeadChild","currentHeadElt","inNewContent","isReAppended","isPreserved","newNode","newElt","resolver","promise","resolve","removedElement","noOp","createIdMap","elt","node1","node2","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","parser","contentWithSvgsRemoved","content","Element","dummyParent","currentElement","bestElement","score","newScore","scoreElement","isIdInConsideration","id","idIsWithinNode","targetNode","idSet","sourceSet","matchCount","populateIdMapForNode","idMap","nodeParent","idElements","current","oldContent","p","DATASTAR_CLASS_PREFIX","INDICATOR_CLASS","LOADING_CLASS","ACCEPT","TEXT_HTML","CONTENT_TYPE","APPLICATION_JSON","SELECTOR","SWAP","GET","addGetPlugin","addFetchMethod","POST","addPostPlugin","PUT","addPutPlugin","PATCH","addPatchPlugin","DELETE","addDeletePlugin","addAllFragmentPlugins","hasInjectedStyles","method","style","fetcher","elRaw","urlSignal","dataStackJSON","_","queryParams","dom","frag","fragElement","firstFrag","hasID","useElAsTarget","targets","targetSelector","target","MODEL","updateEvents","addModelDataPlugin","setter","event","ON","ONCE","THROTTLE","DEBOUNCE","LEADING","addOnDataPlugin","hasMod","withMod","hasOnce","throttleMod","debounceMod","hasLeading","wrappedFnCallback","throttleTimeRaw","throttleTime","prev","throttledFn","now","debounceTimeRaw","debounceTime","timerID","debouncedFn","REF","addRefDataPlugin","ref","IMPORTANT","DISPLAY","NONE","SHOW","addShowDataPlugin","priority","PERSIST_KEY","addSignalDataPlugin","reactivity","parsedValue","PREPEND","APPEND","MUST_PARENT_ERR","TELEPORT","addTeleportDataPlugin","n","TEXT","addTextDataPlugin","once","full","half","INTERSECTS","addIntersectsplugin","options","entries","entry","addAllIncludedPlugins"],"mappings":"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"}