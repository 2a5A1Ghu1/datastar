{"version":3,"file":"datastar.umd.cjs","sources":["../src/lib/dom.ts","../src/lib/external/preact-core.ts","../src/lib/external/deepsignal.ts","../src/lib/external/ts-merge-patch.ts","../src/lib/plugins/core.ts","../src/lib/core.ts","../src/lib/plugins/attributes.ts","../src/lib/external/idiomorph.ts","../src/lib/plugins/backend.ts","../src/lib/plugins/helpers.ts","../src/lib/plugins/visibility.ts","../src/lib/index.ts"],"sourcesContent":["import { HTMLorSVGElement } from './types'\n\nexport function toHTMLorSVGElement(node: Node): HTMLorSVGElement | null {\n  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n    return null\n  }\n  return node\n}\n","function cycleDetected(): never {\n  throw new Error('Cycle detected')\n}\nfunction mutationDetected(): never {\n  throw new Error('Computed cannot have side-effects')\n}\n\nconst identifier = Symbol.for('preact-signals')\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0\nconst NOTIFIED = 1 << 1\nconst OUTDATED = 1 << 2\nconst DISPOSED = 1 << 3\nconst HAS_ERROR = 1 << 4\nconst TRACKING = 1 << 5\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n  // A source whose value the target depends on.\n  _source: Signal\n  _prevSource?: Node\n  _nextSource?: Node\n\n  // A target that depends on the source and should be notified when the source changes.\n  _target: Computed | Effect\n  _prevTarget?: Node\n  _nextTarget?: Node\n\n  // The version number of the source that target has last seen. We use version numbers\n  // instead of storing the source value, because source values can take arbitrary amount\n  // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n  // Use the special value -1 to mark potentially unused but recyclable nodes.\n  _version: number\n\n  // Used to remember & roll back the source's previous `._node` value when entering &\n  // exiting a new evaluation context.\n  _rollbackNode?: Node\n}\n\nfunction startBatch() {\n  batchDepth++\n}\n\nfunction endBatch() {\n  if (batchDepth > 1) {\n    batchDepth--\n    return\n  }\n\n  let error: unknown\n  let hasError = false\n\n  while (batchedEffect !== undefined) {\n    let effect: Effect | undefined = batchedEffect\n    batchedEffect = undefined\n\n    batchIteration++\n\n    while (effect !== undefined) {\n      const next: Effect | undefined = effect._nextBatchedEffect\n      effect._nextBatchedEffect = undefined\n      effect._flags &= ~NOTIFIED\n\n      if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n        try {\n          effect._callback()\n        } catch (err) {\n          if (!hasError) {\n            error = err\n            hasError = true\n          }\n        }\n      }\n      effect = next\n    }\n  }\n  batchIteration = 0\n  batchDepth--\n\n  if (hasError) {\n    throw error\n  }\n}\n\nfunction batch<T>(callback: () => T): T {\n  if (batchDepth > 0) {\n    return callback()\n  }\n  /*@__INLINE__**/ startBatch()\n  try {\n    return callback()\n  } finally {\n    endBatch()\n  }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined\n\nlet untrackedDepth = 0\n\nfunction untracked<T>(callback: () => T): T {\n  if (untrackedDepth > 0) {\n    return callback()\n  }\n  const prevContext = evalContext\n  evalContext = undefined\n  untrackedDepth++\n  try {\n    return callback()\n  } finally {\n    untrackedDepth--\n    evalContext = prevContext\n  }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined\nlet batchDepth = 0\nlet batchIteration = 0\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0\n\nfunction addDependency(signal: Signal): Node | undefined {\n  if (evalContext === undefined) {\n    return undefined\n  }\n\n  let node = signal._node\n  if (node === undefined || node._target !== evalContext) {\n    /**\n     * `signal` is a new dependency. Create a new dependency node, and set it\n     * as the tail of the current context's dependency list. e.g:\n     *\n     * { A <-> B       }\n     *         ↑     ↑\n     *        tail  node (new)\n     *               ↓\n     * { A <-> B <-> C }\n     *               ↑\n     *              tail (evalContext._sources)\n     */\n    node = {\n      _version: 0,\n      _source: signal,\n      _prevSource: evalContext._sources,\n      _nextSource: undefined,\n      _target: evalContext,\n      _prevTarget: undefined,\n      _nextTarget: undefined,\n      _rollbackNode: node,\n    }\n\n    if (evalContext._sources !== undefined) {\n      evalContext._sources._nextSource = node\n    }\n    evalContext._sources = node\n    signal._node = node\n\n    // Subscribe to change notifications from this dependency if we're in an effect\n    // OR evaluating a computed signal that in turn has subscribers.\n    if (evalContext._flags & TRACKING) {\n      signal._subscribe(node)\n    }\n    return node\n  } else if (node._version === -1) {\n    // `signal` is an existing dependency from a previous evaluation. Reuse it.\n    node._version = 0\n\n    /**\n     * If `node` is not already the current tail of the dependency list (i.e.\n     * there is a next node in the list), then make the `node` the new tail. e.g:\n     *\n     * { A <-> B <-> C <-> D }\n     *         ↑           ↑\n     *        node   ┌─── tail (evalContext._sources)\n     *         └─────│─────┐\n     *               ↓     ↓\n     * { A <-> C <-> D <-> B }\n     *                     ↑\n     *                    tail (evalContext._sources)\n     */\n    if (node._nextSource !== undefined) {\n      node._nextSource._prevSource = node._prevSource\n\n      if (node._prevSource !== undefined) {\n        node._prevSource._nextSource = node._nextSource\n      }\n\n      node._prevSource = evalContext._sources\n      node._nextSource = undefined\n\n      evalContext._sources!._nextSource = node\n      evalContext._sources = node\n    }\n\n    // We can assume that the currently evaluated effect / computed signal is already\n    // subscribed to change notifications from `signal` if needed.\n    return node\n  }\n  return undefined\n}\n\n// @ts-ignore internal Signal is viewed as a function\ndeclare class Signal<T = any> {\n  /** @internal */\n  _value: unknown\n\n  /**\n   * @internal\n   * Version numbers should always be >= 0, because the special value -1 is used\n   * by Nodes to signify potentially unused but recyclable nodes.\n   */\n  _version: number\n\n  /** @internal */\n  _node?: Node\n\n  /** @internal */\n  _targets?: Node\n\n  constructor(value?: T)\n\n  /** @internal */\n  _refresh(): boolean\n\n  /** @internal */\n  _subscribe(node: Node): void\n\n  /** @internal */\n  _unsubscribe(node: Node): void\n\n  subscribe(fn: (value: T) => void): () => void\n\n  valueOf(): T\n\n  toString(): string\n\n  toJSON(): T\n\n  peek(): T\n\n  brand: typeof identifier\n\n  get value(): T\n  set value(value: T)\n}\n\n/** @internal */\n// @ts-ignore internal Signal is viewed as function\nfunction Signal(this: Signal, value?: unknown) {\n  this._value = value\n  this._version = 0\n  this._node = undefined\n  this._targets = undefined\n}\n\nSignal.prototype.brand = identifier\n\nSignal.prototype._refresh = function () {\n  return true\n}\n\nSignal.prototype._subscribe = function (node) {\n  if (this._targets !== node && node._prevTarget === undefined) {\n    node._nextTarget = this._targets\n    if (this._targets !== undefined) {\n      this._targets._prevTarget = node\n    }\n    this._targets = node\n  }\n}\n\nSignal.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the signal has any subscribers to begin with.\n  if (this._targets !== undefined) {\n    const prev = node._prevTarget\n    const next = node._nextTarget\n    if (prev !== undefined) {\n      prev._nextTarget = next\n      node._prevTarget = undefined\n    }\n    if (next !== undefined) {\n      next._prevTarget = prev\n      node._nextTarget = undefined\n    }\n    if (node === this._targets) {\n      this._targets = next\n    }\n  }\n}\n\nSignal.prototype.subscribe = function (fn) {\n  const signal = this\n  return effect(function (this: Effect) {\n    const value = signal.value\n    const flag = this._flags & TRACKING\n    this._flags &= ~TRACKING\n    try {\n      fn(value)\n    } finally {\n      this._flags |= flag\n    }\n  })\n}\n\nSignal.prototype.valueOf = function () {\n  return this.value\n}\n\nSignal.prototype.toString = function () {\n  return this.value + ''\n}\n\nSignal.prototype.toJSON = function () {\n  return this.value\n}\n\nSignal.prototype.peek = function () {\n  return this._value\n}\n\nObject.defineProperty(Signal.prototype, 'value', {\n  get() {\n    const node = addDependency(this)\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    return this._value\n  },\n  set(this: Signal, value) {\n    if (evalContext instanceof Computed) {\n      mutationDetected()\n    }\n\n    if (value !== this._value) {\n      if (batchIteration > 100) {\n        cycleDetected()\n      }\n\n      this._value = value\n      this._version++\n      globalVersion++\n\n      /**@__INLINE__*/ startBatch()\n      try {\n        for (let node = this._targets; node !== undefined; node = node._nextTarget) {\n          node._target._notify()\n        }\n      } finally {\n        endBatch()\n      }\n    }\n  },\n})\n\nfunction signal<T>(value: T): Signal<T> {\n  return new Signal(value)\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n  // Check the dependencies for changed values. The dependency list is already\n  // in order of use. Therefore if multiple dependencies have changed values, only\n  // the first used dependency is re-evaluated at this point.\n  for (let node = target._sources; node !== undefined; node = node._nextSource) {\n    // If there's a new version of the dependency before or after refreshing,\n    // or the dependency has something blocking it from refreshing at all (e.g. a\n    // dependency cycle), then we need to recompute.\n    if (\n      node._source._version !== node._version ||\n      !node._source._refresh() ||\n      node._source._version !== node._version\n    ) {\n      return true\n    }\n  }\n  // If none of the dependencies have changed values since last recompute then\n  // there's no need to recompute.\n  return false\n}\n\nfunction prepareSources(target: Computed | Effect) {\n  /**\n   * 1. Mark all current sources as re-usable nodes (version: -1)\n   * 2. Set a rollback node if the current node is being used in a different context\n   * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n   *\n   *    { undefined <- A <-> B <-> C -> undefined }\n   *                   ↑           ↑\n   *                   │           └──────┐\n   * target._sources = A; (node is head)  │\n   *                   ↓                  │\n   * target._sources = C; (node is tail) ─┘\n   */\n  for (let node = target._sources; node !== undefined; node = node._nextSource) {\n    const rollbackNode = node._source._node\n    if (rollbackNode !== undefined) {\n      node._rollbackNode = rollbackNode\n    }\n    node._source._node = node\n    node._version = -1\n\n    if (node._nextSource === undefined) {\n      target._sources = node\n      break\n    }\n  }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n  let node = target._sources\n  let head = undefined\n\n  /**\n   * At this point 'target._sources' points to the tail of the doubly-linked list.\n   * It contains all existing sources + new sources in order of use.\n   * Iterate backwards until we find the head node while dropping old dependencies.\n   */\n  while (node !== undefined) {\n    const prev = node._prevSource\n\n    /**\n     * The node was not re-used, unsubscribe from its change notifications and remove itself\n     * from the doubly-linked list. e.g:\n     *\n     * { A <-> B <-> C }\n     *         ↓\n     *    { A <-> C }\n     */\n    if (node._version === -1) {\n      node._source._unsubscribe(node)\n\n      if (prev !== undefined) {\n        prev._nextSource = node._nextSource\n      }\n      if (node._nextSource !== undefined) {\n        node._nextSource._prevSource = prev\n      }\n    } else {\n      /**\n       * The new head is the last node seen which wasn't removed/unsubscribed\n       * from the doubly-linked list. e.g:\n       *\n       * { A <-> B <-> C }\n       *   ↑     ↑     ↑\n       *   │     │     └ head = node\n       *   │     └ head = node\n       *   └ head = node\n       */\n      head = node\n    }\n\n    node._source._node = node._rollbackNode\n    if (node._rollbackNode !== undefined) {\n      node._rollbackNode = undefined\n    }\n\n    node = prev\n  }\n\n  target._sources = head\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n  _compute: () => T\n  _sources?: Node\n  _globalVersion: number\n  _flags: number\n\n  constructor(compute: () => T)\n\n  _notify(): void\n  get value(): T\n}\n\nfunction Computed(this: Computed, compute: () => unknown) {\n  Signal.call(this, undefined)\n\n  this._compute = compute\n  this._sources = undefined\n  this._globalVersion = globalVersion - 1\n  this._flags = OUTDATED\n}\n\nComputed.prototype = new Signal() as Computed\n\nComputed.prototype._refresh = function () {\n  this._flags &= ~NOTIFIED\n\n  if (this._flags & RUNNING) {\n    return false\n  }\n\n  // If this computed signal has subscribed to updates from its dependencies\n  // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n  // flag not set), then the computed value can't have changed.\n  if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n    return true\n  }\n  this._flags &= ~OUTDATED\n\n  if (this._globalVersion === globalVersion) {\n    return true\n  }\n  this._globalVersion = globalVersion\n\n  // Mark this computed signal running before checking the dependencies for value\n  // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n  this._flags |= RUNNING\n  if (this._version > 0 && !needsToRecompute(this)) {\n    this._flags &= ~RUNNING\n    return true\n  }\n\n  const prevContext = evalContext\n  try {\n    prepareSources(this)\n    evalContext = this\n    const value = this._compute()\n    if (this._flags & HAS_ERROR || this._value !== value || this._version === 0) {\n      this._value = value\n      this._flags &= ~HAS_ERROR\n      this._version++\n    }\n  } catch (err) {\n    this._value = err\n    this._flags |= HAS_ERROR\n    this._version++\n  }\n  evalContext = prevContext\n  cleanupSources(this)\n  this._flags &= ~RUNNING\n  return true\n}\n\nComputed.prototype._subscribe = function (node) {\n  if (this._targets === undefined) {\n    this._flags |= OUTDATED | TRACKING\n\n    // A computed signal subscribes lazily to its dependencies when the it\n    // gets its first subscriber.\n    for (let node = this._sources; node !== undefined; node = node._nextSource) {\n      node._source._subscribe(node)\n    }\n  }\n  Signal.prototype._subscribe.call(this, node)\n}\n\nComputed.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the computed signal has any subscribers.\n  if (this._targets !== undefined) {\n    Signal.prototype._unsubscribe.call(this, node)\n\n    // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n    // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n    if (this._targets === undefined) {\n      this._flags &= ~TRACKING\n\n      for (let node = this._sources; node !== undefined; node = node._nextSource) {\n        node._source._unsubscribe(node)\n      }\n    }\n  }\n}\n\nComputed.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= OUTDATED | NOTIFIED\n\n    for (let node = this._targets; node !== undefined; node = node._nextTarget) {\n      node._target._notify()\n    }\n  }\n}\n\nComputed.prototype.peek = function () {\n  if (!this._refresh()) {\n    cycleDetected()\n  }\n  if (this._flags & HAS_ERROR) {\n    throw this._value\n  }\n  return this._value\n}\n\nObject.defineProperty(Computed.prototype, 'value', {\n  get() {\n    if (this._flags & RUNNING) {\n      cycleDetected()\n    }\n    const node = addDependency(this)\n    this._refresh()\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    if (this._flags & HAS_ERROR) {\n      throw this._value\n    }\n    return this._value\n  },\n})\n\ninterface ReadonlySignal<T = any> extends Signal<T> {\n  readonly value: T\n}\n\nfunction computed<T>(compute: () => T): ReadonlySignal<T> {\n  return new Computed(compute)\n}\n\nfunction cleanupEffect(effect: Effect) {\n  const cleanup = effect._cleanup\n  effect._cleanup = undefined\n\n  if (typeof cleanup === 'function') {\n    /*@__INLINE__**/ startBatch()\n\n    // Run cleanup functions always outside of any context.\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      cleanup()\n    } catch (err) {\n      effect._flags &= ~RUNNING\n      effect._flags |= DISPOSED\n      disposeEffect(effect)\n      throw err\n    } finally {\n      evalContext = prevContext\n      endBatch()\n    }\n  }\n}\n\nfunction disposeEffect(effect: Effect) {\n  for (let node = effect._sources; node !== undefined; node = node._nextSource) {\n    node._source._unsubscribe(node)\n  }\n  effect._compute = undefined\n  effect._sources = undefined\n\n  cleanupEffect(effect)\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n  if (evalContext !== this) {\n    throw new Error('Out-of-order effect')\n  }\n  cleanupSources(this)\n  evalContext = prevContext\n\n  this._flags &= ~RUNNING\n  if (this._flags & DISPOSED) {\n    disposeEffect(this)\n  }\n  endBatch()\n}\n\ntype EffectCleanup = () => unknown\ndeclare class Effect {\n  _compute?: () => unknown | EffectCleanup\n  _cleanup?: () => unknown\n  _sources?: Node\n  _nextBatchedEffect?: Effect\n  _flags: number\n\n  constructor(compute: () => unknown | EffectCleanup)\n\n  _callback(): void\n  _start(): () => void\n  _notify(): void\n  _dispose(): void\n}\n\nfunction Effect(this: Effect, compute: () => unknown | EffectCleanup) {\n  this._compute = compute\n  this._cleanup = undefined\n  this._sources = undefined\n  this._nextBatchedEffect = undefined\n  this._flags = TRACKING\n}\n\nEffect.prototype._callback = function () {\n  const finish = this._start()\n  try {\n    if (this._flags & DISPOSED) return\n    if (this._compute === undefined) return\n\n    const cleanup = this._compute()\n    if (typeof cleanup === 'function') {\n      this._cleanup = cleanup as EffectCleanup\n    }\n  } finally {\n    finish()\n  }\n}\n\nEffect.prototype._start = function () {\n  if (this._flags & RUNNING) {\n    cycleDetected()\n  }\n  this._flags |= RUNNING\n  this._flags &= ~DISPOSED\n  cleanupEffect(this)\n  prepareSources(this)\n\n  /*@__INLINE__**/ startBatch()\n  const prevContext = evalContext\n  evalContext = this\n  return endEffect.bind(this, prevContext)\n}\n\nEffect.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= NOTIFIED\n    this._nextBatchedEffect = batchedEffect\n    batchedEffect = this\n  }\n}\n\nEffect.prototype._dispose = function () {\n  this._flags |= DISPOSED\n\n  if (!(this._flags & RUNNING)) {\n    disposeEffect(this)\n  }\n}\n\nfunction effect(compute: () => unknown | EffectCleanup): () => void {\n  const effect = new Effect(compute)\n  try {\n    effect._callback()\n  } catch (err) {\n    effect._dispose()\n    throw err\n  }\n  // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n  // because bound functions seem to be just as fast and take up a lot less memory.\n  return effect._dispose.bind(effect)\n}\n\nexport { Signal, batch, computed, effect, signal, untracked, type ReadonlySignal }\n","import { Signal, batch, signal } from './preact-core'\n\nexport type AtomicState =\n  | Array<unknown>\n  | ((...args: unknown[]) => unknown)\n  | string\n  | boolean\n  | number\n  | bigint\n  | symbol\n  | undefined\n  | null\n\nexport type DeepState = {\n  [key: string]: (() => unknown) | AtomicState | DeepState\n}\n\nexport type ReadOnlyDeep<T> = {\n  readonly [P in keyof T]: ReadOnlyDeep<T[P]>\n}\n\nexport interface DeepSignalAccessors<T extends DeepState> {\n  value: ReadOnlyDeep<T>\n  peek: () => ReadOnlyDeep<T>\n}\n\nexport type DeepSignalType<T extends DeepState> = DeepSignalAccessors<T> & {\n  [K in keyof T]: T[K] extends AtomicState ? Signal<T[K]> : T[K] extends DeepState ? DeepSignalType<T[K]> : Signal<T[K]>\n}\n\nexport class DeepSignal<T extends DeepState> implements DeepSignalAccessors<T> {\n  get value(): ReadOnlyDeep<T> {\n    return getValue(this as DeepSignalType<T>)\n  }\n\n  set value(payload: ReadOnlyDeep<T>) {\n    batch(() => setValue(this as DeepSignalType<T>, payload))\n  }\n\n  peek(): ReadOnlyDeep<T> {\n    return getValue(this as DeepSignalType<T>, { peek: true })\n  }\n}\n\nexport const deepSignal = <T extends DeepState>(initialValue: T): DeepSignalType<T> =>\n  Object.assign(\n    new DeepSignal(),\n    Object.entries(initialValue).reduce(\n      (acc, [key, value]) => {\n        if (['value', 'peek'].some((iKey) => iKey === key)) {\n          throw new Error(`${key} is a reserved property name`)\n        } else if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n          acc[key] = signal(value)\n        } else {\n          acc[key] = deepSignal(value)\n        }\n        return acc\n      },\n      {} as { [key: string]: unknown },\n    ),\n  ) as DeepSignalType<T>\n\nconst setValue = <U extends DeepState, T extends DeepSignalType<U>>(deepSignal: T, payload: U): void =>\n  Object.keys(payload).forEach((key: keyof U) => (deepSignal[key].value = payload[key]))\n\nconst getValue = <U extends DeepState, T extends DeepSignalType<U>>(\n  deepSignal: T,\n  { peek = false }: { peek?: boolean } = {},\n): ReadOnlyDeep<U> =>\n  Object.entries(deepSignal).reduce(\n    (acc, [key, value]) => {\n      if (value instanceof Signal) {\n        acc[key] = peek ? value.peek() : value.value\n      } else if (value instanceof DeepSignal) {\n        acc[key] = getValue(value as DeepSignalType<DeepState>, { peek })\n      }\n      return acc\n    },\n    {} as { [key: string]: unknown },\n  ) as ReadOnlyDeep<U>\n","type mpObj<T> = { [k in keyof T | string | number | symbol]: any }\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): Partial<L> & Partial<R>\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): R\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): {}\nexport function apply<L, R>(target: mpObj<L>, patchItem: null): null\nexport function apply<L, R>(target: mpObj<L>, patchItem: string): string\nexport function apply<L, R>(target: mpObj<L>, patchItem: number): number\nexport function apply<L, R>(target: mpObj<L>, patchItem: undefined): undefined\nexport function apply<L, R>(target: mpObj<L>, patchItem: R[]): R[]\n\nexport function apply(target: any, patchItem: any): any {\n  /**\n   * If the patch is anything other than an object,\n   * the result will always be to replace\n   * the entire target with the entire patch.\n   */\n  if (typeof patchItem !== 'object' || Array.isArray(patchItem) || !patchItem) {\n    return JSON.parse(JSON.stringify(patchItem)) //return new instance of variable\n  }\n\n  if (typeof patchItem === 'object' && patchItem.toJSON !== undefined && typeof patchItem.toJSON === 'function') {\n    return patchItem.toJSON()\n  }\n  /** Also, it is not possible to\n   * patch part of a target that is not an object,\n   * such as to replace just some of the values in an array.\n   */\n  let targetResult = target\n  if (typeof target !== 'object') {\n    //Target is empty/not an object, so basically becomes patch, minus any null valued sections (becomes {} + patch)\n    targetResult = { ...patchItem }\n  }\n\n  Object.keys(patchItem).forEach((k) => {\n    if (!targetResult.hasOwnProperty(k)) targetResult[k] = patchItem[k] //This ensure the key exists and TS can't throw a wobbly over an undefined key\n    if (patchItem[k] === null) {\n      delete targetResult[k]\n    } else {\n      targetResult[k] = apply(targetResult[k], patchItem[k])\n    }\n  })\n  return targetResult\n}\n","import { AttributeContext, AttributePlugin, Preprocesser, RegexpGroups } from '../types'\n\nconst validJSIdentifier = `[a-zA-Z_$][0-9a-zA-Z_$]*`\nfunction wholePrefixSuffix(rune: string, prefix: string, suffix: string) {\n  return new RegExp(`(?<whole>\\\\${rune}(?<${prefix}>${validJSIdentifier})${suffix})`, `g`)\n}\n\nconst SignalProcessor: Preprocesser = {\n  name: 'SignalProcessor',\n  description: `Replacing $signal with ctx.store.signal.value`,\n  regexp: wholePrefixSuffix('$', 'signal', ''),\n  replacer: (groups: RegexpGroups) => {\n    const { signal } = groups\n    return `ctx.store.${signal}.value`\n  },\n}\n\nconst ActionProcessor: Preprocesser = {\n  name: 'ActionProcessor',\n  description: `Replacing $$action(args) with ctx.actions.action(ctx, args)`,\n  regexp: wholePrefixSuffix('$\\\\$', 'action', '(?<call>\\\\((?<args>.*)\\\\))?'),\n  replacer: ({ action, args }: RegexpGroups) => {\n    const withCtx = [`ctx`]\n    if (args) {\n      withCtx.push(...args.split(',').map((x) => x.trim()))\n    }\n    const argsJoined = withCtx.join(',')\n    return `ctx.actions.${action}(${argsJoined})`\n  },\n}\n\nconst RefProcessor: Preprocesser = {\n  name: 'RefProcessor',\n  description: `Replacing #foo with ctx.refs.foo`,\n  regexp: wholePrefixSuffix('~', 'ref', ''),\n  replacer({ ref }: RegexpGroups) {\n    return `data.refs.${ref}`\n  },\n}\n\nexport const CorePreprocessors: Preprocesser[] = [ActionProcessor, SignalProcessor, RefProcessor]\n\nconst MergeStoreAttributePlugin: AttributePlugin = {\n  prefix: 'mergeStore',\n  description: 'Setup the global store',\n  onLoad: (ctx: AttributeContext) => {\n    const bodyStore = ctx.expressionFn(ctx)\n    ctx.mergeStore(bodyStore)\n  },\n}\n\nconst RefPlugin: AttributePlugin = {\n  prefix: 'ref',\n  description: 'Sets the value of the element',\n  mustHaveEmptyKey: true,\n  mustNotEmptyExpression: true,\n  bypassExpressionFunctionCreation: () => true,\n  preprocessors: new Set([]),\n\n  onLoad: (ctx: AttributeContext) => {\n    const { el, expression } = ctx\n    ctx.refs[expression] = el\n    return () => delete ctx.refs[expression]\n  },\n}\n\nexport const CorePlugins: AttributePlugin[] = [MergeStoreAttributePlugin, RefPlugin]\n","import { toHTMLorSVGElement } from './dom'\nimport { DeepSignal, DeepState, deepSignal } from './external/deepsignal'\nimport { Signal, computed, effect, signal } from './external/preact-core'\nimport { apply } from './external/ts-merge-patch'\nimport { CorePlugins, CorePreprocessors } from './plugins/core'\nimport {\n  Actions,\n  AttributeContext,\n  AttributePlugin,\n  ExpressionFunction,\n  HTMLorSVGElement,\n  OnRemovalFn,\n  Preprocesser,\n  Reactivity,\n} from './types'\n\nexport class Datastar {\n  plugins: AttributePlugin[] = []\n  store: DeepSignal<any> = deepSignal({})\n  actions: Actions = {}\n  refs: Record<string, HTMLElement> = {}\n  reactivity: Reactivity = {\n    signal,\n    computed,\n    effect,\n  }\n  parentID = ''\n  missingIDNext = 0\n  removals = new Map<Element, Set<OnRemovalFn>>()\n\n  constructor(actions: Actions = {}, ...plugins: AttributePlugin[]) {\n    this.actions = Object.assign(this.actions, actions)\n    plugins = [...CorePlugins, ...plugins]\n    if (!plugins.length) throw new Error('No plugins provided')\n\n    const allPluginPrefixes = new Set<string>()\n    for (const p of plugins) {\n      if (p.requiredPluginPrefixes) {\n        for (const requiredPluginType of p.requiredPluginPrefixes) {\n          if (!allPluginPrefixes.has(requiredPluginType)) {\n            throw new Error(`Plugin ${p.prefix} requires plugin ${requiredPluginType}`)\n          }\n        }\n      }\n\n      this.plugins.push(p)\n      allPluginPrefixes.add(p.prefix)\n    }\n  }\n\n  run() {\n    this.plugins.forEach((p) => {\n      if (p.onGlobalInit) {\n        p.onGlobalInit({\n          actions: this.actions,\n          refs: this.refs,\n          reactivity: this.reactivity,\n          mergeStore: this.mergeStore.bind(this),\n          store: this.store,\n        })\n      }\n    })\n    this.applyPlugins(document.body)\n  }\n\n  private cleanupElementRemovals(element: Element) {\n    const removalSet = this.removals.get(element)\n    if (removalSet) {\n      for (const removal of removalSet) {\n        removal()\n      }\n      this.removals.delete(element)\n    }\n  }\n\n  private mergeStore(store: DeepState) {\n    const revisedStore = apply(this.store.value, store) as DeepState\n    this.store = deepSignal(revisedStore)\n  }\n\n  public signalByName<T>(name: string) {\n    return (this.store as any)[name] as Signal<T>\n  }\n\n  private applyPlugins(rootElement: Element) {\n    const appliedProcessors = new Set<Preprocesser>()\n\n    this.plugins.forEach((p, pi) => {\n      this.walkDownDOM(rootElement, (el) => {\n        if (pi === 0) this.cleanupElementRemovals(el)\n\n        for (const dsKey in el.dataset) {\n          let expression = el.dataset[dsKey] || ''\n\n          if (!dsKey.startsWith(p.prefix)) continue\n\n          if (el.id.length === 0) {\n            el.id = `ds-${this.parentID}-${this.missingIDNext++}`\n          }\n\n          appliedProcessors.clear()\n\n          if (p.allowedTagRegexps) {\n            const lowerCaseTag = el.tagName.toLowerCase()\n            const allowed = [...p.allowedTagRegexps].some((r) => lowerCaseTag.match(r))\n            if (!allowed) {\n              throw new Error(\n                `Tag '${el.tagName}' is not allowed for plugin '${dsKey}', allowed tags are: ${[\n                  [...p.allowedTagRegexps].map((t) => `'${t}'`),\n                ].join(', ')}`,\n              )\n            }\n            // console.log(`Tag '${el.tagName}' is allowed for plugin '${dsKey}'`)\n          }\n\n          let keyRaw = dsKey.slice(p.prefix.length)\n          let [key, ...modifiersWithArgsArr] = keyRaw.split('.')\n          if (p.mustHaveEmptyKey && key.length > 0) {\n            throw new Error(`Attribute '${dsKey}' must have empty key`)\n          }\n          if (p.mustNotEmptyKey && key.length === 0) {\n            throw new Error(`Attribute '${dsKey}' must have non-empty key`)\n          }\n          if (key.length) {\n            key = key[0].toLowerCase() + key.slice(1)\n          }\n\n          const modifiersArr = modifiersWithArgsArr.map((m) => {\n            const [label, ...args] = m.split('_')\n            return { label, args }\n          })\n          if (p.allowedModifiers) {\n            for (const modifier of modifiersArr) {\n              if (!p.allowedModifiers.has(modifier.label)) {\n                throw new Error(`Modifier '${modifier.label}' is not allowed`)\n              }\n            }\n          }\n          const modifiers = new Map<string, string[]>()\n          for (const modifier of modifiersArr) {\n            modifiers.set(modifier.label, modifier.args)\n          }\n\n          if (p.mustHaveEmptyExpression && expression.length) {\n            throw new Error(`Attribute '${dsKey}' must have empty expression`)\n          }\n          if (p.mustNotEmptyExpression && !expression.length) {\n            throw new Error(`Attribute '${dsKey}' must have non-empty expression`)\n          }\n\n          const processors = [...CorePreprocessors, ...(p.preprocessors || [])]\n          for (const processor of processors) {\n            if (appliedProcessors.has(processor)) continue\n            appliedProcessors.add(processor)\n            const matches = [...expression.matchAll(processor.regexp)]\n            if (matches.length) {\n              for (const match of matches) {\n                if (!match.groups) continue\n                const { groups } = match\n                const { whole } = groups\n                expression = expression.replace(whole, processor.replacer(groups))\n              }\n            }\n          }\n\n          const { store, reactivity, actions, refs } = this\n          const ctx: AttributeContext = {\n            store,\n            mergeStore: this.mergeStore.bind(this),\n            applyPlugins: this.applyPlugins.bind(this),\n            cleanupElementRemovals: this.cleanupElementRemovals.bind(this),\n            actions,\n            refs,\n            reactivity,\n            el,\n            key,\n            expression,\n            expressionFn: () => {\n              throw new Error('Expression function not created')\n            },\n            modifiers,\n          }\n\n          if (!p.bypassExpressionFunctionCreation?.(ctx) && !p.mustHaveEmptyExpression && expression.length) {\n            const lines = expression.split(';')\n            lines[lines.length - 1] = `return ${lines[lines.length - 1]}`\n            const fnContent = lines.join(';')\n            try {\n              const fn = new Function('ctx', fnContent) as ExpressionFunction\n              ctx.expressionFn = fn\n            } catch (e) {\n              console.error(e)\n              console.error(`Error evaluating expression '${fnContent}' on ${el.id ? `#${el.id}` : el.tagName}`)\n              return\n            }\n          }\n\n          const removal = p.onLoad(ctx)\n          if (removal) {\n            if (!this.removals.has(el)) {\n              this.removals.set(el, new Set())\n            }\n            this.removals.get(el)!.add(removal)\n          }\n        }\n      })\n    })\n  }\n\n  private walkDownDOM(element: Element | null, callback: (el: HTMLorSVGElement) => void, siblingOffset = 0) {\n    if (!element) return\n    const el = toHTMLorSVGElement(element)\n    if (!el) return\n\n    callback(el)\n\n    siblingOffset = 0\n    element = element.firstElementChild\n    while (element) {\n      this.walkDownDOM(element, callback, siblingOffset++)\n      element = element.nextElementSibling\n    }\n  }\n}\n","import { Signal } from '../external/preact-core'\nimport { AttributeContext, AttributePlugin } from '../types'\n\nconst kebabize = (str: string) => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase())\n\nexport const BindAttributePlugin: AttributePlugin = {\n  prefix: 'bind',\n  description: 'Sets the value of the element',\n  mustNotEmptyKey: true,\n  mustNotEmptyExpression: true,\n\n  onLoad: (ctx: AttributeContext) => {\n    return ctx.reactivity.effect(() => {\n      const key = kebabize(ctx.key)\n      const value = ctx.expressionFn(ctx)\n      const v = `${value}`\n      if (!v || v === 'false' || v === 'null' || v === 'undefined') {\n        ctx.el.removeAttribute(key)\n      } else {\n        ctx.el.setAttribute(key, v)\n      }\n    })\n  },\n}\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst updateModelEvents = ['change', 'input', 'keydown']\nexport const TwoWayBindingModelPlugin: AttributePlugin = {\n  prefix: 'model',\n  description: 'Sets the value of the element',\n  mustHaveEmptyKey: true,\n  allowedTagRegexps: new Set(['input', 'textarea', 'select', 'checkbox', 'radio']),\n  bypassExpressionFunctionCreation: () => true,\n  onLoad: (ctx: AttributeContext) => {\n    const { store, el, expression: signalName } = ctx\n    const signal = store[signalName] as Signal<any>\n\n    const isInput = el.tagName.toLowerCase().includes('input')\n    const isSelect = el.tagName.toLowerCase().includes('select')\n    const isTextarea = el.tagName.toLowerCase().includes('textarea')\n    const type = el.getAttribute('type')\n    const isCheckbox = isInput && type === 'checkbox'\n    const isFile = isInput && type === 'file'\n\n    if (!isInput && !isSelect && !isTextarea) {\n      throw new Error('Element must be input, select or textarea')\n    }\n\n    const setInputFromSignal = () => {\n      const v = signal.value\n      if (!signal) throw new Error(`Signal ${signalName} not found`)\n      if (isCheckbox) {\n        const input = el as HTMLInputElement\n        input.checked = v\n      } else if (isFile) {\n        // console.warn('File input reading is not supported yet')\n      } else {\n        el.setAttribute('value', `${signal.value}`)\n      }\n    }\n    const cleanupSetInputFromSignal = ctx.reactivity.effect(setInputFromSignal)\n\n    const setSignalFromInput = () => {\n      const value = (el as any).value\n      if (typeof value === 'undefined') return\n\n      if (isFile) {\n        const [f] = (el as any)?.files || []\n        if (!f) {\n          signal.value = ''\n          return\n        }\n        const reader = new FileReader()\n        reader.onload = () => {\n          if (typeof reader.result !== 'string') throw new Error('Unsupported type')\n\n          const match = reader.result.match(dataURIRegex)\n          if (!match?.groups) throw new Error('Invalid data URI')\n          const { mime, contents } = match.groups\n          signal.value = contents\n\n          const mimeName = `${signalName}Mime`\n          if (mimeName in store) {\n            const mimeSignal = store[`${mimeName}`] as Signal<string>\n            mimeSignal.value = mime\n          }\n        }\n        reader.readAsDataURL(f)\n\n        const nameName = `${signalName}Name`\n        if (nameName in store) {\n          const nameSignal = store[`${nameName}`] as Signal<string>\n          nameSignal.value = f.name\n        }\n\n        return\n      } else {\n        const current = signal.value\n        if (typeof current === 'number') {\n          signal.value = Number(value)\n        } else if (typeof current === 'string') {\n          signal.value = value\n        } else if (typeof current === 'boolean') {\n          if (isCheckbox) {\n            const { checked } = el as HTMLInputElement\n            signal.value = checked\n          } else {\n            signal.value = Boolean(value)\n          }\n        } else if (typeof current === 'undefined') {\n        } else {\n          console.log(typeof current)\n          throw new Error('Unsupported type')\n        }\n      }\n    }\n\n    updateModelEvents.forEach((event) => {\n      el.addEventListener(event, setSignalFromInput)\n    })\n\n    return () => {\n      cleanupSetInputFromSignal()\n      updateModelEvents.forEach((event) => {\n        el.removeEventListener(event, setSignalFromInput)\n      })\n    }\n  },\n}\n\nexport const TextPlugin: AttributePlugin = {\n  prefix: 'text',\n  description: 'Sets the textContent of the element',\n  mustHaveEmptyKey: true,\n\n  onLoad: (ctx: AttributeContext) => {\n    const { el, expressionFn } = ctx\n    if (!(el instanceof HTMLElement)) throw new Error('Element is not HTMLElement')\n    return ctx.reactivity.effect(() => {\n      el.textContent = `${expressionFn(ctx)}`\n    })\n  },\n}\n\n// export const PromptPlugin: AttributePlugin = {\n//   prefix: 'prompt',\n//   description: 'Sets the textContent of the element',\n//   preprocessors: new Set([\n//     {\n//       name: 'PromptPreprocessor',\n//       description: `Replacing prompt() with ctx.store.prompt`,\n//       regexp: /(?<whole>(?<signal>[^;]*);(?<label>.*))/gm,\n//       replacer: ({ signal, label }: RegexpGroups) =>\n//         `\n//           const v = prompt(\\`${label}\\`, ctx.store.${signal}.value);\n//           if (v && v !== ctx.store.${signal}.value) {\n//             ctx.store.${signal}.value = v\n//           };\n//           v\n//         `,\n//     },\n//   ]),\n//   onLoad: (ctx: AttributeContext) => {\n//     ctx.expressionFn(ctx)\n//   },\n// }\n\nexport const EventPlugin: AttributePlugin = {\n  prefix: 'on',\n  description: 'Sets the event listener of the element',\n  mustNotEmptyKey: true,\n  mustNotEmptyExpression: true,\n  allowedModifiers: new Set(['once', 'passive', 'capture', 'debounce', 'throttle']),\n\n  onLoad: (ctx: AttributeContext) => {\n    const { el, key, expressionFn } = ctx\n    let callback = () => {\n      expressionFn(ctx)\n    }\n\n    const debounceArgs = ctx.modifiers.get('debounce')\n    if (debounceArgs) {\n      const wait = argsToMs(debounceArgs)\n      const leading = argsHas(debounceArgs, 'leading', false)\n      const trailing = argsHas(debounceArgs, 'noTrail', true)\n      callback = debounce(callback, wait, leading, trailing)\n    }\n\n    const throttleArgs = ctx.modifiers.get('throttle')\n    if (throttleArgs) {\n      const wait = argsToMs(throttleArgs)\n      const leading = argsHas(throttleArgs, 'noLead', true)\n      const trailing = argsHas(throttleArgs, 'noTrail', true)\n      callback = throttle(callback, wait, leading, trailing)\n    }\n\n    const evtListOpts: AddEventListenerOptions = {\n      capture: true,\n      passive: false,\n      once: false,\n    }\n    if (!ctx.modifiers.has('capture')) evtListOpts.capture = false\n    if (ctx.modifiers.has('passive')) evtListOpts.passive = true\n    if (ctx.modifiers.has('once')) evtListOpts.once = true\n\n    if (key === 'load') {\n      callback()\n      return () => {}\n    }\n    const eventType = key.toLowerCase()\n    el.addEventListener(eventType, callback, evtListOpts)\n    return () => {\n      el.removeEventListener(eventType, callback)\n    }\n  },\n}\n\nexport const FocusPlugin: AttributePlugin = {\n  prefix: 'focus',\n  description: 'Sets the focus of the element',\n  mustHaveEmptyKey: true,\n  mustHaveEmptyExpression: true,\n\n  onLoad: (ctx: AttributeContext) => {\n    if (!ctx.el.tabIndex) {\n      ctx.el.setAttribute('tabindex', '0')\n    }\n    ctx.el.focus()\n    ctx.el.scrollIntoView({ block: 'center', inline: 'center' })\n    return () => ctx.el.blur()\n  },\n}\n\nexport const AttributePlugins: AttributePlugin[] = [\n  BindAttributePlugin,\n  TwoWayBindingModelPlugin,\n  TextPlugin,\n  FocusPlugin,\n  // PromptPlugin,\n  EventPlugin,\n]\n\nfunction argsToMs(args: string[] | undefined) {\n  if (!args || args?.length === 0) return 0\n\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return Number(arg.replace('ms', ''))\n    } else if (arg.endsWith('s')) {\n      return Number(arg.replace('s', '')) * 1000\n    }\n\n    try {\n      return parseFloat(arg)\n    } catch (e) {}\n  }\n\n  return 0\n}\n\nfunction argsHas(args: string[] | undefined, arg: string, defaultValue = false) {\n  if (!args) return false\n  return args.includes(arg) || defaultValue\n}\n\ntype TimerHandler = (...args: any[]) => void\n\nfunction debounce(callback: TimerHandler, wait: number, leading = false, trailing = true): TimerHandler {\n  let timer: NodeJS.Timeout | undefined\n\n  const resetTimer = () => timer && clearTimeout(timer)\n\n  return function wrapper(...args: any[]) {\n    resetTimer()\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      resetTimer()\n    }, wait)\n  }\n}\n\nfunction throttle(callback: TimerHandler, wait: number, leading = true, trailing = false): TimerHandler {\n  let waiting = false\n  let lastArgs: any[] | null = null\n\n  return function wrapper(...args: any[]) {\n    if (!waiting) {\n      waiting = true\n\n      if (leading) {\n        callback(...args)\n      } else {\n        lastArgs = args\n      }\n\n      setTimeout(() => {\n        if (trailing && lastArgs) {\n          callback(...lastArgs)\n          lastArgs = null\n        }\n        waiting = false\n      }, wait)\n    } else {\n      lastArgs = args\n    }\n  }\n}\n","const generatedByIdiomorphId = new WeakSet()\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function idiomorph(oldNode: Document | Element, newContent: string | Element, config = {}) {\n  if (oldNode instanceof Document) {\n    oldNode = oldNode.documentElement\n  }\n\n  let parsedContent: Element\n  if (typeof newContent === 'string') {\n    parsedContent = parseContent(newContent) as Element\n  } else {\n    parsedContent = newContent\n  }\n\n  const normalizedContent = normalizeContent(parsedContent)\n  const ctx = createMorphContext(oldNode, normalizedContent, config)\n\n  return morphNormalizedContent(oldNode, normalizedContent, ctx)\n}\n\nfunction morphNormalizedContent(oldNode: Element, normalizedNewContent: Element, ctx: any) {\n  if (ctx.head.block) {\n    const oldHead = oldNode.querySelector('head')\n    const newHead = normalizedNewContent.querySelector('head')\n    if (oldHead && newHead) {\n      const promises = handleHeadElement(newHead, oldHead, ctx)\n      // when head promises resolve, call morph again, ignoring the head tag\n      Promise.all(promises).then(() => {\n        morphNormalizedContent(\n          oldNode,\n          normalizedNewContent,\n          Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          }),\n        )\n      })\n      return\n    }\n  }\n\n  if (ctx.morphStyle === 'innerHTML') {\n    // innerHTML, so we are only updating the children\n    morphChildren(normalizedNewContent, oldNode, ctx)\n    return oldNode.children\n  } else if (ctx.morphStyle === 'outerHTML' || ctx.morphStyle == null) {\n    // otherwise find the best element match in the new content, morph that, and merge its siblings\n    // into either side of the best match\n    const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx)\n    if (!bestMatch) throw new Error('Could not find best match')\n\n    // stash the siblings that will need to be inserted on either side of the best match\n    const previousSibling = bestMatch?.previousSibling as Element\n    const nextSibling = bestMatch?.nextSibling as Element\n\n    // morph it\n    const morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx)\n\n    if (bestMatch) {\n      // if there was a best match, merge the siblings in too and return the\n      // whole bunch\n      return insertSiblings(previousSibling, morphedNode, nextSibling)\n    } else {\n      // otherwise nothing was added to the DOM\n      return []\n    }\n  } else {\n    throw 'Do not understand how to morph style ' + ctx.morphStyle\n  }\n}\n\n/**\n * @param oldNode root node to merge content into\n * @param newContent new content to merge\n * @param ctx the merge context\n * @returns {Element} the element that ended up in the DOM\n */\nfunction morphOldNodeTo(oldNode: Element, newContent: Element, ctx: any) {\n  if (ctx.ignoreActive && oldNode === document.activeElement) {\n    // don't morph focused element\n  } else if (newContent == null) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n\n    oldNode.remove()\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return\n  } else if (!isSoftMatch(oldNode, newContent)) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n    if (ctx.callbacks.beforeNodeAdded(newContent) === false) return\n\n    if (!oldNode.parentElement) throw new Error('oldNode has no parentElement')\n    oldNode.parentElement.replaceChild(newContent, oldNode)\n    ctx.callbacks.afterNodeAdded(newContent)\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return newContent\n  } else {\n    if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return\n\n    if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n      // ignore the head element\n    } else if (\n      newContent instanceof HTMLHeadElement &&\n      oldNode instanceof HTMLHeadElement &&\n      ctx.head.style !== 'morph'\n    ) {\n      handleHeadElement(newContent, oldNode, ctx)\n    } else {\n      syncNodeFrom(newContent, oldNode)\n      morphChildren(newContent, oldNode, ctx)\n    }\n    ctx.callbacks.afterNodeMorphed(oldNode, newContent)\n    return oldNode\n  }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n * @param {Element} newParent the parent element of the new content\n * @param {Element } oldParent the old content that we are merging the new content into\n * @param ctx the merge context\n */\nfunction morphChildren(newParent: Element, oldParent: Element, ctx: any) {\n  let nextNewChild = newParent.firstChild as Element | null\n  let insertionPoint = oldParent.firstChild as Element | null\n  let newChild\n\n  // run through all the new content\n  while (nextNewChild) {\n    newChild = nextNewChild\n    nextNewChild = newChild.nextSibling as Element | null\n\n    // if we are at the end of the exiting parent's children, just append\n    if (insertionPoint == null) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n      oldParent.appendChild(newChild)\n      ctx.callbacks.afterNodeAdded(newChild)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // if the current node has an id set match then morph\n    if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n      morphOldNodeTo(insertionPoint, newChild, ctx)\n      insertionPoint = insertionPoint.nextSibling as Element | null\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // otherwise search forward in the existing old children for an id set match\n    let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx)\n\n    // if we found a potential match, remove the nodes until that point and morph\n    if (idSetMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx)\n      morphOldNodeTo(idSetMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // no id set match found, so scan forward for a soft match for the current node\n    let softMatch = findSoftMatch(newParent, newChild, insertionPoint, ctx)\n\n    // if we found a soft match for the current node, morph\n    if (softMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx)\n      morphOldNodeTo(softMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // abandon all hope of morphing, just insert the new child before the insertion point\n    // and move on\n    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n    oldParent.insertBefore(newChild, insertionPoint)\n    ctx.callbacks.afterNodeAdded(newChild)\n    removeIdsFromConsideration(ctx, newChild)\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint !== null) {\n    let tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling as Element | null\n    removeNode(tempNode, ctx)\n  }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\n/**\n * syncs a given node with another node, copying over all attributes and\n * inner element state from the 'from' node to the 'to' node\n *\n * @param {Element} from the element to copy attributes & state from\n * @param {Element} to the element to copy attributes & state to\n */\nfunction syncNodeFrom(from: Element, to: Element) {\n  let type = from.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    for (const fromAttribute of from.attributes) {\n      const toAttribute = to.getAttribute(fromAttribute.name)\n      if (toAttribute !== fromAttribute.value) {\n        to.setAttribute(fromAttribute.name, fromAttribute.value)\n      }\n    }\n    for (const toAttribute of to.attributes) {\n      if (!from.hasAttribute(toAttribute.name)) {\n        to.removeAttribute(toAttribute.name)\n      }\n    }\n  }\n\n  // sync text nodes\n  if (type === Node.COMMENT_NODE || type === Node.TEXT_NODE) {\n    if (to.nodeValue !== from.nodeValue) {\n      to.nodeValue = from.nodeValue\n    }\n  }\n\n  // NB: many bothans died to bring us information:\n  //\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  // https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n\n  // sync input value\n  if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== 'file') {\n    to.value = from.value || ''\n    syncAttribute(from, to, 'value')\n\n    // sync boolean attributes\n    syncAttribute(from, to, 'checked')\n    syncAttribute(from, to, 'disabled')\n  } else if (from instanceof HTMLOptionElement) {\n    syncAttribute(from, to, 'selected')\n  } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n    const fromValue = from.value\n    const toValue = to.value\n    if (fromValue !== toValue) {\n      to.value = fromValue\n    }\n    if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n      to.firstChild.nodeValue = fromValue\n    }\n  }\n}\n\nfunction syncAttribute(from: Element, to: Element, attributeName: string) {\n  const fAttr = from.getAttribute(attributeName)\n  const tAttr = to.getAttribute(attributeName)\n\n  if (fAttr !== tAttr) {\n    if (fAttr) {\n      to.setAttribute(attributeName, fAttr)\n    } else {\n      to.removeAttribute(attributeName)\n    }\n  }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(newHeadTag: HTMLHeadElement, currentHead: HTMLHeadElement, ctx: any) {\n  const added = []\n  const removed = []\n  const preserved = []\n  const nodesToAppend = []\n\n  const headMergeStyle = ctx.head.style\n\n  // put all new head elements into a Map, by their outerHTML\n  const srcToNewHeadNodes = new Map()\n  for (const newHeadChild of newHeadTag.children) {\n    srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild)\n  }\n\n  // for each elt in the current head\n  for (const currentHeadElt of currentHead.children) {\n    // If the current head element is in the map\n    let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML)\n    let isReAppended = ctx.head.shouldReAppend(currentHeadElt)\n    let isPreserved = ctx.head.shouldPreserve(currentHeadElt)\n    if (inNewContent || isPreserved) {\n      if (isReAppended) {\n        // remove the current version and let the new version replace it and re-execute\n        removed.push(currentHeadElt)\n      } else {\n        // this element already exists and should not be re-appended, so remove it from\n        // the new content map, preserving it in the DOM\n        srcToNewHeadNodes.delete(currentHeadElt.outerHTML)\n        preserved.push(currentHeadElt)\n      }\n    } else {\n      if (headMergeStyle === 'append') {\n        // we are appending and this existing element is not new content\n        // so if and only if it is marked for re-append do we do anything\n        if (isReAppended) {\n          removed.push(currentHeadElt)\n          nodesToAppend.push(currentHeadElt)\n        }\n      } else {\n        // if this is a merge, we remove this content since it is not in the new head\n        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n          removed.push(currentHeadElt)\n        }\n      }\n    }\n  }\n\n  // Push the remaining new head elements in the Map into the\n  // nodes to append to the head tag\n  nodesToAppend.push(...srcToNewHeadNodes.values())\n  console.log('to append: ', nodesToAppend)\n\n  const promises = []\n  for (const newNode of nodesToAppend) {\n    console.log('adding: ', newNode)\n    const newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild as Element | null\n    if (!newElt) throw new Error('could not create new element from: ' + newNode.outerHTML)\n    console.log(newElt)\n    if (!!ctx.callbacks.beforeNodeAdded(newElt)) {\n      if (newElt.hasAttribute('href') || newElt.hasAttribute('src')) {\n        let resolver: (value: unknown) => void\n        const promise = new Promise((resolve) => {\n          resolver = resolve\n        })\n        newElt.addEventListener('load', function () {\n          resolver(undefined)\n        })\n        promises.push(promise)\n      }\n      currentHead.appendChild(newElt)\n      ctx.callbacks.afterNodeAdded(newElt)\n      added.push(newElt)\n    }\n  }\n\n  // remove all removed elements, after we have appended the new elements to avoid\n  // additional network requests for things like style sheets\n  for (const removedElement of removed) {\n    if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n      currentHead.removeChild(removedElement)\n      ctx.callbacks.afterNodeRemoved(removedElement)\n    }\n  }\n\n  ctx.head.afterHeadMorphed(currentHead, {\n    added: added,\n    kept: preserved,\n    removed: removed,\n  })\n  return promises\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\nfunction noOp() {}\n\nfunction createMorphContext(oldNode: Element, newContent: Element, config: any) {\n  return {\n    target: oldNode,\n    newContent: newContent,\n    config: config,\n    morphStyle: config.morphStyle,\n    ignoreActive: config.ignoreActive,\n    idMap: createIdMap(oldNode, newContent),\n    deadIds: new Set(),\n    callbacks: Object.assign(\n      {\n        beforeNodeAdded: noOp,\n        afterNodeAdded: noOp,\n        beforeNodeMorphed: noOp,\n        afterNodeMorphed: noOp,\n        beforeNodeRemoved: noOp,\n        afterNodeRemoved: noOp,\n      },\n      config.callbacks,\n    ),\n    head: Object.assign(\n      {\n        style: 'merge',\n        shouldPreserve: (elt: Element) => elt.getAttribute('im-preserve') === 'true',\n        shouldReAppend: (elt: Element) => elt.getAttribute('im-re-append') === 'true',\n        shouldRemove: noOp,\n        afterHeadMorphed: noOp,\n      },\n      config.head,\n    ),\n  }\n}\n\nfunction isIdSetMatch(node1: Element, node2: Element, ctx: any) {\n  if (!node1 || !node2) return false\n\n  if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n    if (node1?.id?.length && node1.id === node2.id) return true\n\n    return getIdIntersectionCount(ctx, node1, node2) > 0\n  }\n  return false\n}\n\nfunction isSoftMatch(node1: Element, node2: Element) {\n  if (!node1 || !node2) return false\n\n  return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n}\n\nfunction removeNodesBetween(startInclusive: Element, endExclusive: Element, ctx: any) {\n  while (startInclusive !== endExclusive) {\n    const tempNode = startInclusive\n    startInclusive = startInclusive?.nextSibling as Element\n    if (!tempNode) throw new Error('tempNode is null')\n    removeNode(tempNode, ctx)\n  }\n  removeIdsFromConsideration(ctx, endExclusive)\n  return endExclusive.nextSibling as Element | null\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(newContent: Element, oldParent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  // max id matches we are willing to discard in our search\n  const newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent)\n\n  let potentialMatch: Element | null = null\n\n  // only search forward if there is a possibility of an id match\n  if (newChildPotentialIdCount > 0) {\n    potentialMatch = insertionPoint\n    // if there is a possibility of an id match, scan forward\n    // keep track of the potential id match count we are discarding (the\n    // newChildPotentialIdCount must be greater than this to make it likely\n    // worth it)\n    let otherMatchCount = 0\n    while (potentialMatch != null) {\n      // If we have an id match, return the current potential match\n      if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n        return potentialMatch\n      }\n\n      // computer the other potential matches of this new content\n      otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent)\n      if (otherMatchCount > newChildPotentialIdCount) {\n        // if we have more potential id matches in _other_ content, we\n        // do not have a good candidate for an id match, so return null\n        return null\n      }\n\n      // advanced to the next old content child\n      potentialMatch = potentialMatch.nextSibling as Element | null\n    }\n  }\n  return potentialMatch\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(newContent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  let potentialSoftMatch = insertionPoint as Element | null\n  let nextSibling = newChild.nextSibling as Element | null\n\n  let siblingSoftMatchCount = 0\n\n  while (potentialSoftMatch && nextSibling) {\n    if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n      // the current potential soft match has a potential id set match with the remaining new\n      // content so bail out of looking\n      return null\n    }\n\n    // if we have a soft match with the current node, return it\n    if (isSoftMatch(newChild, potentialSoftMatch)) {\n      return potentialSoftMatch\n    }\n\n    if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n      // the next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling as Element | null\n\n      // If there are two future soft matches, bail to allow the siblings to soft match\n      // so that we don't consume future soft matches for the sake of the current node\n      if (siblingSoftMatchCount >= 2) {\n        return null\n      }\n    }\n\n    // advanced to the next old content child\n    potentialSoftMatch = potentialSoftMatch.nextSibling as Element | null\n  }\n\n  return potentialSoftMatch\n}\n\nconst parser = new DOMParser()\nfunction parseContent(newContent: string) {\n  // remove svgs to avoid false-positive matches on head, etc.\n  const contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '')\n\n  // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n  if (\n    contentWithSvgsRemoved.match(/<\\/html>/) ||\n    contentWithSvgsRemoved.match(/<\\/head>/) ||\n    contentWithSvgsRemoved.match(/<\\/body>/)\n  ) {\n    const content = parser.parseFromString(newContent, 'text/html')\n    // if it is a full HTML document, return the document itself as the parent container\n    if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n      generatedByIdiomorphId.add(content)\n      return content\n    } else {\n      // otherwise return the html element as the parent container\n      let Element = content.firstChild\n      if (Element) {\n        generatedByIdiomorphId.add(Element)\n        return Element as Element\n      } else {\n        return null\n      }\n    }\n  } else {\n    // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n    // deal with touchy tags like tr, tbody, etc.\n    const responseDoc = parser.parseFromString(`<body><template>${newContent}</template></body>`, 'text/html')\n    const content = responseDoc.body.querySelector('template')?.content\n    if (!content) throw new Error('content is null')\n    generatedByIdiomorphId.add(content)\n    return content\n  }\n}\n\nfunction normalizeContent(newContent: Element) {\n  if (newContent == null) {\n    // noinspection UnnecessaryLocalVariableJS\n    const dummyParent = document.createElement('div')\n    return dummyParent\n  } else if (generatedByIdiomorphId.has(newContent)) {\n    // the template tag created by idiomorph parsing can serve as a dummy parent\n    return newContent\n  } else if (newContent instanceof Node) {\n    // a single node is added as a child to a dummy parent\n    const dummyParent = document.createElement('div')\n    dummyParent.append(newContent)\n    return dummyParent\n  } else {\n    // all nodes in the array or Element collection are consolidated under\n    // a single dummy parent element\n    const dummyParent = document.createElement('div')\n    for (const elt of [...newContent]) {\n      dummyParent.append(elt)\n    }\n    return dummyParent\n  }\n}\n\nfunction insertSiblings(previousSibling?: Element, morphedNode?: Element, nextSibling?: Element) {\n  const stack = []\n  const added = []\n  while (previousSibling) {\n    stack.push(previousSibling)\n    previousSibling = previousSibling.previousSibling as Element\n  }\n  while (stack.length > 0) {\n    const node = stack.pop()!\n    added.push(node) // push added preceding siblings on in order and insert\n    morphedNode?.parentElement?.insertBefore(node, morphedNode)\n  }\n  added.push(morphedNode)\n  while (nextSibling) {\n    stack.push(nextSibling)\n    added.push(nextSibling) // here we are going in order, so push on as we scan, rather than add\n    nextSibling = nextSibling.nextSibling as Element\n  }\n  while (stack.length) {\n    morphedNode?.parentElement?.insertBefore(stack.pop()!, morphedNode.nextSibling)\n  }\n  return added\n}\n\nfunction findBestNodeMatch(newContent: Element, oldNode: Element, ctx: any) {\n  let currentElement = newContent.firstChild as Element | null\n  let bestElement = currentElement\n  let score = 0\n  while (currentElement) {\n    let newScore = scoreElement(currentElement, oldNode, ctx)\n    if (newScore > score) {\n      bestElement = currentElement\n      score = newScore\n    }\n    currentElement = currentElement.nextSibling as Element | null\n  }\n  return bestElement\n}\n\nfunction scoreElement(node1: Element, node2: Element, ctx: any) {\n  if (isSoftMatch(node1, node2)) {\n    return 0.5 + getIdIntersectionCount(ctx, node1, node2)\n  }\n  return 0\n}\n\nfunction removeNode(tempNode: Element, ctx: any) {\n  removeIdsFromConsideration(ctx, tempNode)\n  if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return\n\n  tempNode.remove()\n  ctx.callbacks.afterNodeRemoved(tempNode)\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: any, id: string) {\n  return !ctx.deadIds.has(id)\n}\n\nfunction idIsWithinNode(ctx: any, id: string, targetNode: Element) {\n  return ctx.idMap.get(targetNode)?.has(id) || false\n}\n\nfunction removeIdsFromConsideration(ctx: any, node: Element) {\n  const idSet = ctx.idMap.get(node)\n  if (!idSet) return\n  for (const id of idSet) {\n    ctx.deadIds.add(id)\n  }\n}\n\nfunction getIdIntersectionCount(ctx: any, node1: Element, node2: Element) {\n  const sourceSet = ctx.idMap.get(node1)\n  if (!sourceSet) return 0\n\n  let matchCount = 0\n  for (const id of sourceSet) {\n    // a potential match is an id in the source and potentialIdsSet, but\n    // that has not already been merged into the DOM\n    if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n      ++matchCount\n    }\n  }\n  return matchCount\n}\n\n/**\n * A bottom up algorithm that finds all elements with ids inside of the node\n * argument and populates id sets for those nodes and all their parents, generating\n * a set of ids contained within all nodes for the entire hierarchy in the DOM\n *\n * @param node {Element}\n * @param {Map<Node, Set<String>>} idMap\n */\nfunction populateIdMapForNode(node: Element, idMap: Map<Element, Set<string>>) {\n  const nodeParent = node.parentElement\n  // find all elements with an id property\n  const idElements = node.querySelectorAll('[id]')\n  for (const elt of idElements) {\n    let current = elt as Element | null\n    // walk up the parent hierarchy of that element, adding the id\n    // of element to the parent's id set\n    while (current !== nodeParent && !!current) {\n      let idSet = idMap.get(current)\n      // if the id set doesn't exist, create it and insert it in the  map\n      if (idSet == null) {\n        idSet = new Set()\n        idMap.set(current, idSet)\n      }\n      idSet.add(elt.id)\n      current = current.parentElement\n    }\n  }\n}\n\n/**\n * This function computes a map of nodes to all ids contained within that node (inclusive of the\n * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n * to contribute to a parent nodes matching.\n *\n * @param {Element} oldContent  the old content that will be morphed\n * @param {Element} newContent  the new content to morph to\n * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n */\nfunction createIdMap(oldContent: Element, newContent: Element) {\n  const idMap = new Map()\n  populateIdMapForNode(oldContent, idMap)\n  populateIdMapForNode(newContent, idMap)\n  return idMap\n}\n","import { idiomorph } from '../external/idiomorph'\nimport { Signal } from '../external/preact-core'\nimport { Actions, AttributeContext, AttributePlugin } from '../types'\nconst GET = 'get'\nconst POST = 'post'\nconst PUT = 'put'\nconst PATCH = 'patch'\nconst DELETE = 'delete'\nconst Methods = [GET, POST, PUT, PATCH, DELETE]\n\nexport const BackendActions: Actions = Methods.reduce((acc, method) => {\n  acc[method] = async (ctx) => {\n    const da = Document as any\n    if (!da.startViewTransition) {\n      await fetcher(method, ctx)\n      return\n    }\n    return new Promise((resolve) => {\n      da.startViewTransition(async () => {\n        await fetcher(method, ctx)\n        resolve()\n      })\n    })\n  }\n  return acc\n}, {} as Actions)\n\nconst ACCEPT = 'Accept'\nconst CONTENT_TYPE = 'Content-Type'\nconst DATASTAR_REQUEST = 'datastar-request'\nconst APPLICATION_JSON = 'application/json'\nconst TEXT_EVENT_STREAM = 'text/event-stream'\nconst TRUE_STRING = 'true'\nconst DATASTAR_CLASS_PREFIX = 'datastar-'\nconst INDICATOR_CLASS = `${DATASTAR_CLASS_PREFIX}indicator`\nconst INDICATOR_LOADING_CLASS = `${INDICATOR_CLASS}-loading`\nconst SETTLING_CLASS = `${DATASTAR_CLASS_PREFIX}settling`\nconst SWAPPING_CLASS = `${DATASTAR_CLASS_PREFIX}swapping`\nconst SELECTOR_SELF_SELECTOR = 'self'\n\nconst MergeOptions = {\n  MorphElement: 'morph_element',\n  InnerElement: 'inner_element',\n  OuterElement: 'outer_element',\n  PrependElement: 'prepend_element',\n  AppendElement: 'append_element',\n  BeforeElement: 'before_element',\n  AfterElement: 'after_element',\n  DeleteElement: 'delete_element',\n  UpsertAttributes: 'upsert_attributes',\n} as const\ntype MergeOption = (typeof MergeOptions)[keyof typeof MergeOptions]\n\nexport const HeadersPlugin: AttributePlugin = {\n  prefix: 'header',\n  description: 'Sets the header of the fetch request',\n  mustNotEmptyKey: true,\n  mustNotEmptyExpression: true,\n\n  onLoad: (ctx) => {\n    const headers = ctx.store.fetch.headers\n    const key = ctx.key[0].toUpperCase() + ctx.key.slice(1)\n    headers[key] = ctx.reactivity.computed(() => ctx.expressionFn(ctx))\n    return () => {\n      delete headers[key]\n    }\n  },\n}\n\nexport const FetchURLPlugin: AttributePlugin = {\n  prefix: 'fetchUrl',\n  description: 'Sets the fetch url',\n  mustHaveEmptyKey: true,\n  mustNotEmptyExpression: true,\n  onGlobalInit: ({ mergeStore }) => {\n    mergeStore({\n      fetch: {\n        headers: {},\n        elementURLs: {},\n        indicatorSelectors: {},\n      },\n    })\n  },\n  onLoad: (ctx) => {\n    return ctx.reactivity.effect(() => {\n      const c = ctx.reactivity.computed(() => `${ctx.expressionFn(ctx)}`)\n      ctx.store.fetch.elementURLs[ctx.el.id] = c\n      return () => {\n        delete ctx.store.fetch.elementURLs[ctx.el.id]\n      }\n    })\n  },\n}\n\nexport const FetchIndicatorPlugin: AttributePlugin = {\n  prefix: 'fetchIndicator',\n  description: 'Sets the fetch indicator selector',\n  mustHaveEmptyKey: true,\n  mustNotEmptyExpression: true,\n  onGlobalInit: () => {\n    const style = document.createElement('style')\n    style.innerHTML = `\n.${INDICATOR_CLASS}{\n opacity:0;\n transition: opacity 300ms ease-out;\n}\n.${INDICATOR_LOADING_CLASS} {\n opacity:1;\n transition: opacity 300ms ease-in;\n}\n`\n    document.head.appendChild(style)\n  },\n  onLoad: (ctx) => {\n    return ctx.reactivity.effect(() => {\n      const c = ctx.reactivity.computed(() => `${ctx.expressionFn(ctx)}`)\n      ctx.store.fetch.indicatorSelectors[ctx.el.id] = c\n\n      const indicator = document.querySelector(c.value)\n      if (!indicator) throw new Error(`No indicator found for ${c.value}`)\n      indicator.classList.add(INDICATOR_CLASS)\n\n      return () => {\n        delete ctx.store.fetch.indicatorSelectors[ctx.el.id]\n      }\n    })\n  },\n}\n\nexport const BackendPlugins: AttributePlugin[] = [HeadersPlugin, FetchURLPlugin, FetchIndicatorPlugin]\n\nconst sseRegexp = /(?<key>\\w*): (?<value>.*)/gm\nasync function fetcher(method: string, ctx: AttributeContext) {\n  const { el, store } = ctx\n  const urlSignal: Signal<string> = store.fetch.elementURLs[el.id]\n  if (!urlSignal) {\n    // throw new Error(`No signal for ${method} on ${el.id}`)\n    return\n  }\n\n  let loadingTarget = el\n  let hasIndicator = false\n  const indicatorSelector = store.fetch.indicatorSelectors[el.id]\n  if (indicatorSelector) {\n    const indicator = document.querySelector(indicatorSelector)\n    if (indicator) {\n      loadingTarget = indicator\n      loadingTarget.classList.remove(INDICATOR_CLASS)\n      loadingTarget.classList.add(INDICATOR_LOADING_CLASS)\n      hasIndicator = true\n    }\n  }\n\n  // console.log(`Adding ${LOADING_CLASS} to ${el.id}`)\n\n  const url = new URL(urlSignal.value, window.location.origin)\n\n  const headers = new Headers()\n  headers.append(ACCEPT, TEXT_EVENT_STREAM)\n  headers.append(CONTENT_TYPE, APPLICATION_JSON)\n  headers.append(DATASTAR_REQUEST, TRUE_STRING)\n\n  const storeHeaders: Record<string, string> = store.fetch.headers.value\n  if (storeHeaders) {\n    for (const key in storeHeaders) {\n      const value = storeHeaders[key]\n      headers.append(key, value)\n    }\n  }\n\n  const storeWithoutFetch = { ...store }\n  delete storeWithoutFetch.fetch\n  const storeJSON = JSON.stringify(storeWithoutFetch)\n  method = method.toUpperCase()\n  const req: RequestInit = { method, headers }\n  if (method === 'GET') {\n    const queryParams = new URLSearchParams(url.search)\n    queryParams.append('datastar', storeJSON)\n    url.search = queryParams.toString()\n  } else {\n    req.body = storeJSON\n  }\n\n  const response = await fetch(url, req)\n\n  if (!response.ok) throw new Error(`Response was not ok, url: ${url}, status: ${response.status}`)\n\n  if (!response.body) throw new Error(`No response body`)\n  const reader = response.body.pipeThrough(new TextDecoderStream()).getReader()\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) break\n\n    value.split('\\n\\n').forEach((evtBlock) => {\n      // console.log(evtBlock)\n      const matches = [...evtBlock.matchAll(sseRegexp)]\n      if (matches.length) {\n        let fragment = '',\n          merge: MergeOption = 'morph_element',\n          selector = '',\n          settleTime = 0,\n          isRedirect = false,\n          redirectURL = '',\n          error: Error | undefined = undefined,\n          isError = false,\n          isFragment = false\n\n        for (const match of matches) {\n          if (!match.groups) continue\n          const { key, value } = match.groups\n          switch (key) {\n            case 'event':\n              if (!value.startsWith(DATASTAR_CLASS_PREFIX)) {\n                throw new Error(`Unknown event: ${value}`)\n              }\n              const eventType = value.slice(DATASTAR_CLASS_PREFIX.length)\n              switch (eventType) {\n                case 'redirect':\n                  isRedirect = true\n                  break\n                case 'fragment':\n                  isFragment = true\n                  break\n                case 'error':\n                  isError = true\n                  break\n                default:\n                  throw new Error(`Unknown event: ${value}`)\n              }\n              break\n            case 'data':\n              const offset = value.indexOf(' ')\n              if (offset === -1) {\n                throw new Error(`Missing space in data`)\n              }\n              const type = value.slice(0, offset)\n              const contents = value.slice(offset + 1)\n\n              switch (type) {\n                case 'selector':\n                  selector = contents\n                  break\n                case 'merge':\n                  const vmo = contents as MergeOption\n                  const exists = Object.values(MergeOptions).includes(vmo)\n                  if (!exists) {\n                    throw new Error(`Unknown merge option: ${value}`)\n                  }\n                  merge = vmo\n                  break\n                case 'settle':\n                  settleTime = parseInt(contents)\n                  break\n                case 'fragment':\n                case 'html':\n                  fragment = contents\n                  break\n                case 'redirect':\n                  redirectURL = contents\n                  break\n                case 'error':\n                  error = new Error(contents)\n                  break\n                default:\n                  throw new Error(`Unknown data type: ${type}`)\n              }\n          }\n        }\n\n        if (isError && error) {\n          throw error\n        } else if (isRedirect && redirectURL) {\n          window.location.href = redirectURL\n        } else if (isFragment && fragment) {\n          mergeHTMLFragment(ctx, selector, merge, fragment, settleTime)\n        } else {\n          throw new Error(`Unknown event block: ${evtBlock}`)\n        }\n      }\n    })\n  }\n\n  if (hasIndicator) {\n    loadingTarget.classList.remove(INDICATOR_LOADING_CLASS)\n    loadingTarget.classList.add(INDICATOR_CLASS)\n  }\n}\n\nconst fragContainer = document.createElement('template')\nexport function mergeHTMLFragment(\n  ctx: AttributeContext,\n  selector: string,\n  merge: MergeOption,\n  fragment: string,\n  settleTime: number,\n) {\n  const { el } = ctx\n\n  fragContainer.innerHTML = fragment\n  const frag = fragContainer.content.firstChild\n  if (!(frag instanceof Element)) {\n    throw new Error(`Fragment is not an element, source '${fragment}'`)\n  }\n\n  const useElAsTarget = selector === SELECTOR_SELF_SELECTOR\n\n  let targets: Iterable<Element>\n  if (useElAsTarget) {\n    targets = [el]\n  } else {\n    const selectorOrID = selector || `#${frag.getAttribute('id')}`\n    targets = document.querySelectorAll(selectorOrID) || []\n    if (!!!targets) throw new Error(`No target elements, selector: ${selector}`)\n  }\n\n  for (const initialTarget of targets) {\n    initialTarget.classList.add(SWAPPING_CLASS)\n\n    const originalHTML = initialTarget.outerHTML\n\n    let modifiedTarget = initialTarget\n\n    switch (merge) {\n      case MergeOptions.MorphElement:\n        const result = idiomorph(modifiedTarget, frag)\n        if (!result?.length) throw new Error(`Failed to morph element`)\n        const first = result[0] as Element\n        modifiedTarget = first\n        break\n      case MergeOptions.InnerElement:\n        // Replace the contents of the target element with the response\n        modifiedTarget.innerHTML = frag.innerHTML\n        break\n      case MergeOptions.OuterElement:\n        // Replace the entire target element with the response\n        modifiedTarget.replaceWith(frag)\n        break\n      case MergeOptions.PrependElement:\n        modifiedTarget.prepend(frag) //  Insert the response before the first child of the target element\n        break\n      case MergeOptions.AppendElement:\n        modifiedTarget.append(frag) //  Insert the response after the last child of the target element\n        break\n      case MergeOptions.BeforeElement:\n        modifiedTarget.before(frag) //  Insert the response before the target element\n        break\n      case MergeOptions.AfterElement:\n        modifiedTarget.after(frag) //  Insert the response after the target element\n        break\n      case MergeOptions.DeleteElement:\n        //  Deletes the target element regardless of the response\n        setTimeout(() => modifiedTarget.remove(), settleTime)\n        break\n      case MergeOptions.UpsertAttributes:\n        //  Upsert the attributes of the target element\n        frag.getAttributeNames().forEach((attrName) => {\n          const value = frag.getAttribute(attrName)!\n          modifiedTarget.setAttribute(attrName, value)\n        })\n        break\n      default:\n        throw new Error(`Unknown merge type: ${merge}`)\n    }\n    modifiedTarget.classList.add(SWAPPING_CLASS)\n\n    ctx.cleanupElementRemovals(initialTarget)\n    ctx.applyPlugins(modifiedTarget)\n\n    initialTarget.classList.remove(SWAPPING_CLASS)\n    modifiedTarget.classList.remove(SWAPPING_CLASS)\n\n    const revisedHTML = modifiedTarget.outerHTML\n\n    if (originalHTML !== revisedHTML) {\n      modifiedTarget.classList.add(SETTLING_CLASS)\n      setTimeout(() => {\n        modifiedTarget.classList.remove(SETTLING_CLASS)\n      }, settleTime)\n    }\n  }\n}\n","import { Actions } from '..'\n\nexport const HelperActions: Actions = {\n  setAll: async (ctx, regexp, newValue) => {\n    const re = new RegExp(regexp)\n    Object.keys(ctx.store)\n      .filter((k) => re.test(k))\n      .forEach((signalName) => {\n        ctx.store[signalName].value = newValue\n      })\n  },\n  toggleAll: async (ctx, regexp) => {\n    const re = new RegExp(regexp)\n    Object.keys(ctx.store)\n      .filter((k) => re.test(k))\n      .forEach((k) => {\n        ctx.store[k].value = !ctx.store[k].value\n      })\n  },\n}\n","import { toHTMLorSVGElement } from '../dom'\nimport { effect } from '../external/preact-core'\nimport { AttributeContext, AttributePlugin } from '../types'\n\nconst DISPLAY = 'display'\nconst NONE = 'none'\nconst IMPORTANT = 'important'\n\nexport const ShowPlugin: AttributePlugin = {\n  prefix: 'show',\n  description: 'Sets the display of the element',\n  allowedModifiers: new Set([IMPORTANT]),\n\n  onLoad: (ctx: AttributeContext) => {\n    const { el, modifiers, expressionFn } = ctx\n\n    return effect(() => {\n      const expressionEvaluated = expressionFn(ctx)\n      const shouldShow = !!expressionEvaluated\n\n      const isImportant = modifiers.has(IMPORTANT)\n      const priority = isImportant ? IMPORTANT : undefined\n\n      if (shouldShow) {\n        if (el.style.length === 1 && el.style.display === NONE) {\n          el.style.removeProperty(DISPLAY)\n        } else {\n          el.style.setProperty(DISPLAY, '', priority)\n        }\n      } else {\n        el.style.setProperty(DISPLAY, NONE, priority)\n      }\n    })\n  },\n}\n\nconst INTERSECTS = 'intersects'\nconst ONCE = 'once'\nconst HALF = 'half'\nconst FULL = 'full'\n\nexport const IntersectionPlugin: AttributePlugin = {\n  prefix: INTERSECTS,\n  description: `Run expression when element intersects with viewport`,\n  allowedModifiers: new Set([ONCE, HALF, FULL]),\n  mustHaveEmptyKey: true,\n  onLoad: (ctx: AttributeContext) => {\n    const { modifiers } = ctx\n    const options = { threshold: 0 }\n    if (modifiers.has(FULL)) options.threshold = 1\n    else if (modifiers.has(HALF)) options.threshold = 0.5\n\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          ctx.expressionFn(ctx)\n          if (modifiers.has(ONCE)) {\n            observer.disconnect()\n          }\n        }\n      })\n    }, options)\n\n    observer.observe(ctx.el)\n    return () => observer.disconnect()\n  },\n}\n\nconst PREPEND = 'prepend'\nconst APPEND = 'append'\nconst teleportParentErr = new Error('Target element must have a parent if using prepend or append')\nexport const TeleportPlugin: AttributePlugin = {\n  prefix: 'teleport',\n  description: 'Teleports the element to another element',\n  allowedModifiers: new Set([PREPEND, APPEND]),\n  allowedTagRegexps: new Set(['template']),\n  bypassExpressionFunctionCreation: () => true,\n  onLoad: (ctx: AttributeContext) => {\n    const { el, modifiers, expression } = ctx\n    if (!(el instanceof HTMLTemplateElement)) throw new Error() // type guard\n\n    const target = document.querySelector(expression)\n    if (!target) throw new Error(`Target element not found: ${expression}`)\n\n    if (!el.content) {\n      throw new Error('Template element must have content')\n    }\n\n    const n = el.content.cloneNode(true)\n    const nEl = toHTMLorSVGElement(n as Element)\n    if (nEl?.firstElementChild) throw new Error('Empty template')\n\n    if (modifiers.has(PREPEND)) {\n      if (!target.parentNode) throw teleportParentErr\n      target.parentNode.insertBefore(n, target)\n    } else if (modifiers.has(APPEND)) {\n      if (!target.parentNode) throw teleportParentErr\n      target.parentNode.insertBefore(n, target.nextSibling)\n    } else {\n      target.appendChild(n)\n    }\n  },\n}\n\nexport const ScrollIntoViewPlugin: AttributePlugin = {\n  prefix: 'scrollIntoView',\n  description: 'Scrolls the element into view',\n  onLoad: (ctx: AttributeContext) => {\n    const { el } = ctx\n    el.scrollIntoView({\n      behavior: 'smooth',\n      block: 'center',\n      inline: 'center',\n    })\n  },\n}\n\nconst viewTransitionID = 'ds-view-transition-stylesheet'\nexport const ViewTransitionPlugin: AttributePlugin = {\n  prefix: 'viewTransition',\n  description: 'Setup view transition api',\n  onGlobalInit(ctx) {\n    const viewTransitionStylesheet = document.createElement('style')\n    viewTransitionStylesheet.id = viewTransitionID\n    document.head.appendChild(viewTransitionStylesheet)\n\n    let hasViewTransitionMeta = false\n    document.head.childNodes.forEach((node) => {\n      if (node instanceof HTMLMetaElement && node.name === 'view-transition') {\n        hasViewTransitionMeta = true\n      }\n    })\n\n    if (!hasViewTransitionMeta) {\n      const meta = document.createElement('meta')\n      meta.name = 'view-transition'\n      meta.content = 'same-origin'\n      document.head.appendChild(meta)\n    }\n\n    ctx.mergeStore({\n      viewTransitions: {},\n    })\n  },\n  onLoad: (ctx: AttributeContext) => {\n    const { el, expressionFn, store } = ctx\n    let name = expressionFn(ctx)\n    if (!name) {\n      if (!el.id) throw new Error('Element must have an id if no name is provided')\n      name = el.id\n    }\n\n    const stylesheet = document.getElementById(viewTransitionID) as HTMLStyleElement\n    if (!stylesheet) throw new Error('View transition stylesheet not found')\n\n    const clsName = `ds-vt-${name}`\n    // add view transition class\n    const vtCls = `\n.${clsName} {\n  view-transition: ${name};\n}\n\n`\n    stylesheet.innerHTML += vtCls\n    let count = store.viewTransitions[name]\n    if (!count) {\n      count = ctx.reactivity.signal(0)\n      store.viewTransitions[name] = count\n    }\n    count.value++\n\n    // add class to element\n    el.classList.add(clsName)\n\n    return () => {\n      count.value--\n      if (count.value === 0) {\n        delete store.viewTransitions[name]\n        stylesheet.innerHTML = stylesheet.innerHTML.replace(vtCls, '')\n      }\n    }\n  },\n}\n\nexport const VisibilityPlugins: AttributePlugin[] = [\n  ShowPlugin,\n  IntersectionPlugin,\n  TeleportPlugin,\n  ScrollIntoViewPlugin,\n  ViewTransitionPlugin,\n]\n","export * from './core'\nexport * from './dom'\nexport * from './types'\n\nimport { Datastar } from './core'\nimport { AttributePlugins } from './plugins/attributes'\nimport { BackendActions, BackendPlugins } from './plugins/backend'\nimport { HelperActions } from './plugins/helpers'\nimport { VisibilityPlugins } from './plugins/visibility'\nimport { Actions, AttributePlugin } from './types'\n\nexport function runDatastarWith(actions: Actions = {}, ...plugins: AttributePlugin[]) {\n  const start = performance.now()\n  const ds = new Datastar(actions, ...plugins)\n  ds.run()\n  const end = performance.now()\n  console.log(`Datastar loaded and attached to all DOM elements in ${end - start}ms`)\n  return ds\n}\n\nexport function runDatastarWithAllPlugins(addedActions: Actions = {}, ...addedPlugins: AttributePlugin[]) {\n  const actions: Actions = Object.assign({}, HelperActions, BackendActions, addedActions)\n  const allPlugins = [...BackendPlugins, ...VisibilityPlugins, ...AttributePlugins, ...addedPlugins]\n  return runDatastarWith(actions, ...allPlugins)\n}\n"],"names":["toHTMLorSVGElement","node","cycleDetected","mutationDetected","identifier","RUNNING","NOTIFIED","OUTDATED","DISPOSED","HAS_ERROR","TRACKING","startBatch","batchDepth","endBatch","error","hasError","batchedEffect","effect","batchIteration","next","needsToRecompute","err","batch","callback","evalContext","globalVersion","addDependency","signal","Signal","value","prev","fn","flag","Computed","target","prepareSources","rollbackNode","cleanupSources","head","compute","prevContext","computed","cleanupEffect","cleanup","disposeEffect","endEffect","Effect","finish","DeepSignal","getValue","payload","setValue","deepSignal","initialValue","acc","key","iKey","peek","apply","patchItem","targetResult","k","validJSIdentifier","wholePrefixSuffix","rune","prefix","suffix","SignalProcessor","groups","ActionProcessor","action","args","withCtx","x","argsJoined","RefProcessor","ref","CorePreprocessors","CorePlugins","ctx","bodyStore","el","expression","Datastar","actions","plugins","allPluginPrefixes","p","requiredPluginType","element","removalSet","removal","store","revisedStore","name","rootElement","appliedProcessors","pi","dsKey","lowerCaseTag","r","t","keyRaw","modifiersWithArgsArr","modifiersArr","m","label","modifier","modifiers","processors","processor","matches","match","whole","reactivity","refs","lines","fnContent","e","siblingOffset","kebabize","str","$","ofs","BindAttributePlugin","v","dataURIRegex","updateModelEvents","AttributePlugins","signalName","isInput","isSelect","isTextarea","type","isCheckbox","isFile","setInputFromSignal","input","cleanupSetInputFromSignal","setSignalFromInput","f","reader","mime","contents","mimeName","mimeSignal","nameName","nameSignal","current","checked","event","expressionFn","debounceArgs","wait","argsToMs","leading","argsHas","trailing","debounce","throttleArgs","throttle","evtListOpts","eventType","arg","defaultValue","timer","resetTimer","waiting","lastArgs","generatedByIdiomorphId","idiomorph","oldNode","newContent","config","parsedContent","parseContent","normalizedContent","normalizeContent","createMorphContext","morphNormalizedContent","normalizedNewContent","oldHead","newHead","promises","handleHeadElement","morphChildren","bestMatch","findBestNodeMatch","previousSibling","nextSibling","morphedNode","morphOldNodeTo","insertSiblings","isSoftMatch","syncNodeFrom","newParent","oldParent","nextNewChild","insertionPoint","newChild","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","from","to","fromAttribute","toAttribute","syncAttribute","fromValue","toValue","attributeName","fAttr","tAttr","newHeadTag","currentHead","added","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","newHeadChild","currentHeadElt","inNewContent","isReAppended","isPreserved","newNode","newElt","resolver","promise","resolve","removedElement","noOp","createIdMap","elt","node1","node2","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","parser","contentWithSvgsRemoved","content","Element","dummyParent","stack","currentElement","bestElement","score","newScore","scoreElement","isIdInConsideration","id","idIsWithinNode","targetNode","idSet","sourceSet","matchCount","populateIdMapForNode","idMap","nodeParent","idElements","oldContent","BackendActions","method","da","fetcher","ACCEPT","CONTENT_TYPE","DATASTAR_REQUEST","APPLICATION_JSON","TEXT_EVENT_STREAM","TRUE_STRING","DATASTAR_CLASS_PREFIX","INDICATOR_CLASS","INDICATOR_LOADING_CLASS","SETTLING_CLASS","SWAPPING_CLASS","SELECTOR_SELF_SELECTOR","MergeOptions","BackendPlugins","headers","mergeStore","c","style","indicator","sseRegexp","urlSignal","loadingTarget","hasIndicator","indicatorSelector","url","storeHeaders","storeWithoutFetch","storeJSON","req","queryParams","response","done","evtBlock","fragment","merge","selector","settleTime","isRedirect","redirectURL","isError","isFragment","offset","vmo","mergeHTMLFragment","fragContainer","frag","useElAsTarget","targets","selectorOrID","initialTarget","originalHTML","modifiedTarget","result","attrName","revisedHTML","HelperActions","regexp","newValue","re","DISPLAY","NONE","IMPORTANT","ShowPlugin","shouldShow","priority","INTERSECTS","ONCE","HALF","FULL","IntersectionPlugin","options","observer","entries","entry","PREPEND","APPEND","teleportParentErr","TeleportPlugin","n","ScrollIntoViewPlugin","viewTransitionID","VisibilityPlugins","viewTransitionStylesheet","hasViewTransitionMeta","meta","stylesheet","clsName","vtCls","count","runDatastarWith","start","ds","end","runDatastarWithAllPlugins","addedActions","addedPlugins","allPlugins"],"mappings":"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"}