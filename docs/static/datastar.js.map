{"version":3,"file":"datastar.js","sources":["../src/lib/dom.ts","../src/lib/eval.ts","../src/lib/external/reactively.ts","../src/lib/core.ts","../src/lib/extensions/actions.ts","../src/lib/extensions/bind.ts","../src/lib/extensions/focus.ts","../src/lib/external/idiomorph.ts","../src/lib/extensions/fragments.ts","../src/lib/extensions/model.ts","../src/lib/extensions/on.ts","../src/lib/extensions/ref.ts","../src/lib/extensions/show.ts","../src/lib/extensions/signal.ts","../src/lib/extensions/teleport.ts","../src/lib/extensions/text.ts","../src/lib/extensions/intersects.ts","../src/lib/extensions/index.ts","../src/lib/mockFetch.ts"],"sourcesContent":["export function walkDownDOM(el: Element | null, callback: (el: Element) => void) {\n  if (!el) return\n  callback(el)\n\n  el = el.firstElementChild\n\n  while (el) {\n    walkDownDOM(el, callback)\n    el = el.nextElementSibling\n  }\n}\n\nexport function walkUpDOM(el: Element | null, callback: (el: Element) => void) {\n  if (!el) return\n  callback(el)\n\n  el = el.parentElement\n  walkUpDOM(el, callback)\n}\n","import { ActionsMap, NamespacedReactiveRecordCallback, NamespacedReactiveRecords } from './types'\n\nexport function functionGenerator<T>(str: string): NamespacedReactiveRecordCallback<T> {\n  const fnContents = `return ${str}`\n  const fn = new Function('el', 'dataStack', 'actions', fnContents)\n  return fn as NamespacedReactiveRecordCallback<T>\n}\n\nexport function functionEval(el: Element, dataStack: NamespacedReactiveRecords, actions: ActionsMap, str: string) {\n  const fn = functionGenerator(str)\n  try {\n    return fn(el, dataStack, actions)\n  } catch (e) {\n    console.error(`Error evaluating expression: ${str}`)\n  }\n}\n\nexport function camelize(str: string) {\n  return str\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => {\n      return index === 0 ? word.toLowerCase() : word.toUpperCase()\n    })\n    .replace(/\\s+/g, '')\n}\n","/**\n * Nodes for constructing a reactive graph of reactive values and reactive computations.\n * The graph is acyclic.\n * The user inputs new values into the graph by calling set() on one more more reactive nodes.\n * The user retrieves computed results from the graph by calling get() on one or more reactive nodes.\n * The library is responsible for running any necessary reactive computations so that get() is\n * up to date with all prior set() calls anywhere in the graph.\n *\n * We call input nodes 'roots' and the output nodes 'leaves' of the graph here in discussion,\n * but the distinction is based on the use of the graph, all nodes have the same internal structure.\n * Changes flow from roots to leaves. It would be effective but inefficient to immediately propagate\n * all changes from a root through the graph to descendant leaves. Instead we defer change\n * most change progogation computation until a leaf is accessed. This allows us to coalesce computations\n * and skip altogether recalculating unused sections of the graph.\n *\n * Each reactive node tracks its sources and its observers (observers are other\n * elements that have this node as a source). Source and observer links are updated automatically\n * as observer reactive computations re-evaluate and call get() on their sources.\n *\n * Each node stores a cache state to support the change propogation algorithm: 'clean', 'check', or 'dirty'\n * In general, execution proceeds in three passes:\n *  1. set() propogates changes down the graph to the leaves\n *     direct children are marked as dirty and their deeper descendants marked as check\n *     (no reactive computations are evaluated)\n *  2. get() requests that parent nodes updateIfNecessary(), which proceeds recursively up the tree\n *     to decide whether the node is clean (parents unchanged) or dirty (parents changed)\n *  3. updateIfNecessary() evaluates the reactive computation if the node is dirty\n *     (the computations are executed in root to leaf order)\n */\n\n/** current capture context for identifying @reactive sources (other reactive elements) and cleanups\n * - active while evaluating a reactive function body  */\nlet CurrentReaction: Reactive<any> | undefined = undefined\nlet CurrentGets: Reactive<any>[] | null = null\nlet CurrentGetsIndex = 0\n\n/** A list of non-clean 'effect' nodes that will be updated when stabilize() is called */\nlet EffectQueue: Reactive<any>[] = []\n\nlet stabilizeFn: ((node: Reactive<any>) => void) | undefined = undefined // fn to call if there are dirty effect nodes\nlet stabilizationQueued = false // stabilizeFn() is queued to run after this event loop\n\n/** reactive nodes are marked dirty when their source values change TBD*/\nexport const CacheClean = 0 // reactive value is valid, no need to recompute\nexport const CacheCheck = 1 // reactive value might be stale, check parent nodes to decide whether to recompute\nexport const CacheDirty = 2 // reactive value is invalid, parents have changed, valueneeds to be recomputed\nexport type CacheState = typeof CacheClean | typeof CacheCheck | typeof CacheDirty\ntype CacheNonClean = typeof CacheCheck | typeof CacheDirty\n\nexport function logDirty(_enable?: boolean): void {\n  // TBD for a debug build\n}\n\nexport interface ReactivelyParams {\n  equals?: (a: any, b: any) => boolean\n  effect?: boolean\n}\n\n/** A reactive element contains a mutable value that can be observed by other reactive elements.\n *\n * The property can be modified externally by calling set().\n *\n * Reactive elements may also contain a 0-ary function body that produces a new value using\n * values from other reactive elements.\n *\n * Dependencies on other elements are captured dynamically as the 'reactive' function body executes.\n *\n * The reactive function is re-evaluated when any of its dependencies change, and the result is\n * cached.\n */\nexport function reactive<T>(fnOrValue: T | (() => T), params?: ReactivelyParams): Reactive<T> {\n  const node = new Reactive(fnOrValue, params?.effect)\n  if (params?.equals) {\n    node.equals = params.equals\n  }\n  return node\n}\n\nfunction defaultEquality(a: any, b: any) {\n  return a === b\n}\n\n/** A reactive element contains a mutable value that can be observed by other reactive elements.\n *\n * The property can be modified externally by calling set().\n *\n * Reactive elements may also contain a 0-ary function body that produces a new value using\n * values from other reactive elements.\n *\n * Dependencies on other elements are captured dynamically as the 'reactive' function body executes.\n *\n * The reactive function is re-evaluated when any of its dependencies change, and the result is\n * cached.\n */\nexport class Reactive<T> {\n  private _value: T\n  private fn?: () => T\n  private observers: Reactive<any>[] | null = null // nodes that have us as sources (down links)\n  private sources: Reactive<any>[] | null = null // sources in reference order, not deduplicated (up links)\n\n  private state: CacheState\n  cleanups: ((oldValue: T) => void)[] = []\n  equals = defaultEquality\n\n  constructor(\n    fnOrValue: (() => T) | T,\n    readonly isEffect = false,\n  ) {\n    if (typeof fnOrValue === 'function') {\n      this.fn = fnOrValue as () => T\n      this._value = undefined as any\n      this.isEffect = isEffect || false\n      this.state = CacheDirty\n      if (isEffect) {\n        EffectQueue.push(this)\n        stabilizeFn?.(this)\n      }\n    } else {\n      this.fn = undefined\n      this._value = fnOrValue\n      this.state = CacheClean\n      this.isEffect = false\n    }\n  }\n\n  get value(): T {\n    return this.get()\n  }\n\n  set value(v: T) {\n    this.set(v)\n  }\n\n  get(): T {\n    if (CurrentReaction) {\n      if (!CurrentGets && CurrentReaction.sources && CurrentReaction.sources[CurrentGetsIndex] == this) {\n        CurrentGetsIndex++\n      } else {\n        if (!CurrentGets) CurrentGets = [this]\n        else CurrentGets.push(this)\n      }\n    }\n    if (this.fn) this.updateIfNecessary()\n    return this._value\n  }\n\n  set(fnOrValue: T | (() => T)): void {\n    if (typeof fnOrValue === 'function') {\n      const fn = fnOrValue as () => T\n      if (fn !== this.fn) {\n        this.stale(CacheDirty)\n      }\n      this.fn = fn\n    } else {\n      if (this.fn) {\n        this.removeParentObservers(0)\n        this.sources = null\n        this.fn = undefined\n      }\n      const value = fnOrValue as T\n      if (!this.equals(this._value, value)) {\n        if (this.observers) {\n          for (let i = 0; i < this.observers.length; i++) {\n            const observer = this.observers[i]\n            observer.stale(CacheDirty)\n          }\n        }\n        this._value = value\n      }\n    }\n  }\n\n  private stale(state: CacheNonClean): void {\n    if (this.state < state) {\n      // If we were previously clean, then we know that we may need to update to get the new value\n      if (this.state === CacheClean && this.isEffect) {\n        EffectQueue.push(this)\n        stabilizeFn?.(this)\n      }\n\n      this.state = state\n      if (this.observers) {\n        for (let i = 0; i < this.observers.length; i++) {\n          this.observers[i].stale(CacheCheck)\n        }\n      }\n    }\n  }\n\n  /** run the computation fn, updating the cached value */\n  private update(): void {\n    const oldValue = this._value\n\n    /* Evalute the reactive function body, dynamically capturing any other reactives used */\n    const prevReaction = CurrentReaction\n    const prevGets = CurrentGets\n    const prevIndex = CurrentGetsIndex\n\n    CurrentReaction = this\n    CurrentGets = null as any // prevent TS from thinking CurrentGets is null below\n    CurrentGetsIndex = 0\n\n    try {\n      if (this.cleanups.length) {\n        this.cleanups.forEach((c) => c(this._value))\n        this.cleanups = []\n      }\n      this._value = this.fn!()\n\n      // if the sources have changed, update source & observer links\n      if (CurrentGets) {\n        // remove all old sources' .observers links to us\n        this.removeParentObservers(CurrentGetsIndex)\n        // update source up links\n        if (this.sources && CurrentGetsIndex > 0) {\n          this.sources.length = CurrentGetsIndex + CurrentGets.length\n          for (let i = 0; i < CurrentGets.length; i++) {\n            this.sources[CurrentGetsIndex + i] = CurrentGets[i]\n          }\n        } else {\n          this.sources = CurrentGets\n        }\n\n        for (let i = CurrentGetsIndex; i < this.sources.length; i++) {\n          // Add ourselves to the end of the parent .observers array\n          const source = this.sources[i]\n          if (!source.observers) {\n            source.observers = [this]\n          } else {\n            source.observers.push(this)\n          }\n        }\n      } else if (this.sources && CurrentGetsIndex < this.sources.length) {\n        // remove all old sources' .observers links to us\n        this.removeParentObservers(CurrentGetsIndex)\n        this.sources.length = CurrentGetsIndex\n      }\n    } finally {\n      CurrentGets = prevGets\n      CurrentReaction = prevReaction\n      CurrentGetsIndex = prevIndex\n    }\n\n    // handles diamond depenendencies if we're the parent of a diamond.\n    if (!this.equals(oldValue, this._value) && this.observers) {\n      // We've changed value, so mark our children as dirty so they'll reevaluate\n      for (let i = 0; i < this.observers.length; i++) {\n        const observer = this.observers[i]\n        observer.state = CacheDirty\n      }\n    }\n\n    // We've rerun with the latest values from all of our sources.\n    // This means that we no longer need to update until a signal changes\n    this.state = CacheClean\n  }\n\n  /** update() if dirty, or a parent turns out to be dirty. */\n  private updateIfNecessary(): void {\n    // If we are potentially dirty, see if we have a parent who has actually changed value\n    if (this.state === CacheCheck) {\n      for (const source of this.sources!) {\n        source.updateIfNecessary() // updateIfNecessary() can change this.state\n        if ((this.state as CacheState) === CacheDirty) {\n          // Stop the loop here so we won't trigger updates on other parents unnecessarily\n          // If our computation changes to no longer use some sources, we don't\n          // want to update() a source we used last time, but now don't use.\n          break\n        }\n      }\n    }\n\n    // If we were already dirty or marked dirty by the step above, update.\n    if (this.state === CacheDirty) {\n      this.update()\n    }\n\n    // By now, we're clean\n    this.state = CacheClean\n  }\n\n  private removeParentObservers(index: number): void {\n    if (!this.sources) return\n    for (let i = index; i < this.sources.length; i++) {\n      const source: Reactive<any> = this.sources[i] // We don't actually delete sources here because we're replacing the entire array soon\n      const swap = source.observers!.findIndex((v) => v === this)\n      source.observers![swap] = source.observers![source.observers!.length - 1]\n      source.observers!.pop()\n    }\n  }\n}\n\nexport function onCleanup<T = any>(fn: (oldValue: T) => void): void {\n  if (CurrentReaction) {\n    CurrentReaction.cleanups.push(fn)\n  } else {\n    console.error('onCleanup must be called from within a @reactive function')\n  }\n}\n\n/** run all non-clean effect nodes */\nexport function stabilize(): void {\n  for (let i = 0; i < EffectQueue.length; i++) {\n    EffectQueue[i].get()\n  }\n  EffectQueue.length = 0\n}\n\n/** run a function for each dirty effect node.  */\nexport function autoStabilize(fn = deferredStabilize): void {\n  stabilizeFn = fn\n}\n\n/** queue stabilize() to run at the next idle time */\nfunction deferredStabilize(): void {\n  if (!stabilizationQueued) {\n    stabilizationQueued = true\n\n    queueMicrotask(() => {\n      stabilizationQueued = false\n      stabilize()\n    })\n  }\n}\n","import { camelize } from '.'\nimport { walkDownDOM, walkUpDOM } from './dom'\nimport { ACTION } from './extensions/actions'\nimport { Reactive, autoStabilize, onCleanup, reactive } from './external/reactively'\nimport { ActionFn, ActionsMap, Modifier, NamespacedReactiveRecords, WithExpressionArgs } from './types'\nautoStabilize()\n\nfunction signal<T>(initialValue: T): Reactive<T> {\n  return reactive(initialValue)\n}\n\nfunction computed<T>(fn: () => T): Reactive<T> {\n  return reactive(fn)\n}\n\nfunction effect(fn: () => void) {\n  return reactive(fn, { effect: true })\n}\n\nconst extensionObserver = new MutationObserver((mutations) => {\n  for (const m of mutations) {\n    m.removedNodes.forEach((node) => {\n      const el = node as Element\n      if (!el) return\n      extensionElementRegistry.delete(el)\n    })\n\n    m.addedNodes.forEach((node) => {\n      const el = node as Element\n      if (!el) return\n      extensionApplyFunctions.forEach((fn) => fn(el))\n    })\n  }\n})\n\nextensionObserver.observe(document, {\n  attributes: true,\n  childList: true,\n  subtree: true,\n})\n\nexport interface Preprocesser {\n  name: string\n  description: string\n  regexp: RegExp\n  replacer: (groups: Record<string, string>) => string\n}\nexport function useProcessor({ regexp, replacer }: Preprocesser, str: string): string {\n  // console.log(`preprocess with ${name}. ${description}`)\n  const matches = [...str.matchAll(regexp)]\n  if (!matches.length) return str\n  for (const match of matches) {\n    if (!match.groups) continue\n    const { groups } = match\n    const { whole } = groups\n    str = str.replace(whole, replacer(groups))\n  }\n  return str\n}\n\nfunction cyrb53(str: string, seed = 0) {\n  let h1 = 0xdeadbeef ^ seed,\n    h2 = 0x41c6ce57 ^ seed\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i)\n    h1 = Math.imul(h1 ^ ch, 2654435761)\n    h2 = Math.imul(h2 ^ ch, 1597334677)\n  }\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507)\n  h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909)\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507)\n  h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909)\n\n  return 4294967296 * (2097151 & h2) + (h1 >>> 0)\n}\n\nconst prefixHashes = new Map<string, number>()\nconst extensionApplyFunctions = new Map<number, Function>()\nconst extensionElementRegistry = new Map<Element, Set<number>>()\nconst extensionPreprocessStack = new Array<Preprocesser>()\nconst data = new Map<Element, NamespacedReactiveRecords>()\n\nconst actions: ActionsMap = {}\n\nexport function addDataExtension(\n  prefix: string,\n  args: {\n    allowedTags?: Iterable<string>\n    allowedModifiers?: Iterable<string | RegExp>\n    isPreprocessGlobal?: boolean\n    preprocessExpressions?: Iterable<Preprocesser>\n    withExpression?: (args: WithExpressionArgs) => NamespacedReactiveRecords | void\n    requiredExtensions?: Iterable<string>\n  },\n) {\n  if (prefix.toLowerCase() !== prefix) throw Error(`Data extension 'data-${prefix}' must be lowercase`)\n  if (prefixHashes.has(prefix)) {\n    throw new Error(`Data extension 'data-${prefix}' already registered`)\n  }\n\n  const hash = cyrb53(prefix)\n  prefixHashes.set(prefix, hash)\n\n  if (!args) {\n    args = {}\n  }\n\n  for (const extension of args.requiredExtensions || []) {\n    if (extension === prefix) {\n      throw new Error(`Data extension 'data-${prefix}' cannot require itself`)\n    }\n  }\n\n  const extensionsRegistered = new Set(prefixHashes.keys())\n  for (const requiredExtension of args.requiredExtensions || []) {\n    if (!extensionsRegistered.has(requiredExtension)) {\n      throw new Error(`Data extension 'data-${prefix}' can't be a duplicate`)\n    }\n  }\n\n  if (typeof args?.isPreprocessGlobal === 'undefined') {\n    args.isPreprocessGlobal = true\n  }\n\n  if (args?.preprocessExpressions && args.isPreprocessGlobal) {\n    extensionPreprocessStack.push(...args.preprocessExpressions)\n  }\n\n  const allAllowedModifiers: RegExp[] = []\n  if (args?.allowedModifiers) {\n    for (const modifier of args.allowedModifiers) {\n      const m = modifier instanceof RegExp ? modifier : new RegExp(modifier)\n      allAllowedModifiers.push(m)\n    }\n  }\n\n  const allowedTags = new Set([...(args?.allowedTags || [])].map((t) => t.toLowerCase()))\n\n  function registerExtensionOnElement(parentEl: Element) {\n    walkDownDOM(parentEl, (element) => {\n      const el = toHTMLorSVGElement(element)\n      if (!el) return\n\n      let extensions = extensionElementRegistry.get(el)\n      if (!extensions) {\n        extensions = new Set()\n        extensionElementRegistry.set(el, extensions)\n      }\n\n      if (extensions.has(hash)) return\n      extensions.add(hash)\n\n      if (allowedTags.size) {\n        const tagLower = el.tagName.toLowerCase()\n        if (!allowedTags.has(tagLower)) return\n      }\n\n      for (var d in el.dataset) {\n        if (!d.startsWith(prefix)) continue\n\n        let [name, ...modifiersWithArgsArr] = d.split('.')\n\n        const pl = prefix.length\n        const pl1 = pl + 1\n        name = name.slice(pl, pl1).toLocaleLowerCase() + name.slice(pl1)\n\n        const modifiers = modifiersWithArgsArr.map((m) => {\n          const [label, ...args] = m.split(':')\n\n          const isAllowed = allAllowedModifiers.some((allowedModifier) => allowedModifier.test(label))\n          if (!isAllowed) {\n            throw new Error(`Modifier ${label} is not allowed for ${name}`)\n          }\n\n          return { label, args }\n        })\n\n        const dataStack = loadDataStack(el)\n        let expression = el.dataset[d] || ''\n\n        for (const preprocessor of extensionPreprocessStack) {\n          expression = useProcessor(preprocessor, expression)\n        }\n\n        if (args?.preprocessExpressions && !args?.isPreprocessGlobal) {\n          for (const preprocessor of args.preprocessExpressions) {\n            expression = useProcessor(preprocessor, expression)\n          }\n        }\n\n        const elementData = data.get(el) || {}\n        if (args?.withExpression) {\n          const postExpression = args.withExpression({\n            name,\n            expression,\n            el,\n            dataStack,\n            reactivity: {\n              signal,\n              computed,\n              effect,\n              onCleanup,\n            },\n            withMod: (label: string) => withModifier(modifiers, label),\n            hasMod: (label: string) => hasModifier(modifiers, label),\n            actions,\n          })\n          if (postExpression) {\n            Object.assign(elementData, postExpression)\n          }\n        }\n        data.set(el, elementData)\n      }\n    })\n  }\n\n  registerExtensionOnElement(document.body)\n  extensionApplyFunctions.set(hash, registerExtensionOnElement)\n\n  // console.info(`Registered data extension: data-${prefix}`)\n}\n\nfunction loadDataStack(el: Element): NamespacedReactiveRecords {\n  const stack: NamespacedReactiveRecords[] = []\n\n  walkUpDOM(el, (el) => {\n    const elData = data.get(el)\n    if (elData) stack.push(elData)\n  })\n\n  stack.reverse()\n\n  const dataStack: NamespacedReactiveRecords = {}\n  for (const namespacedRecords of stack) {\n    for (const namespaceKey in namespacedRecords) {\n      if (!dataStack[namespaceKey]) {\n        dataStack[namespaceKey] = {}\n      }\n      Object.assign(dataStack[namespaceKey], namespacedRecords[namespaceKey])\n    }\n  }\n\n  return dataStack\n}\n\nexport function toHTMLorSVGElement(el: Element) {\n  if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n    return null\n  }\n  return el\n}\n\nexport function hasModifier(modifiers: Modifier[], label: string) {\n  return modifiers.some((m) => m.label === label)\n}\n\nexport function withModifier(modifiers: Modifier[], label: string) {\n  return modifiers.find((m) => m.label === label)\n}\n\nexport function addActionExtension(args: {\n  name: string\n  description: string\n  fn: ActionFn\n  requiredExtensions?: Iterable<string>\n}) {\n  const { name, fn, requiredExtensions } = args\n  const extensionHashes = [ACTION, ...(requiredExtensions || [])]\n\n  if (name != camelize(name)) {\n    throw new Error(`must be camelCase`)\n  }\n\n  for (const ext of extensionHashes) {\n    if (!prefixHashes.has(ext)) {\n      throw new Error(`requires '@${name}' registration`)\n    }\n\n    if (name in actions) {\n      throw new Error(`'@${name}' already registered`)\n    }\n\n    actions[name] = fn\n  }\n}\n\nlet nextID = 0\nexport function uniqueId() {\n  return nextID++\n}\n","import { addDataExtension } from '../core'\n\nexport const ACTION = 'action'\n\nexport function addActionDataExtension() {\n  addDataExtension(ACTION, {\n    preprocessExpressions: [\n      {\n        name: 'action',\n        description: 'turns @action(args) into actions.action(args)',\n        regexp: new RegExp(/(?<whole>@(?<action>[a-zA-Z_$][0-9a-zA-Z_$]*)(?<call>\\((?<args>.*)\\))?)/g),\n        replacer: ({ action, args }) => `actions.${action}({el,dataStack, actions}, ${args || ''})`,\n      },\n    ],\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataExtension } from '../core'\n\nexport const BIND = 'bind'\nexport function addBindDataExtension() {\n  addDataExtension(BIND, {\n    requiredExtensions: [SIGNAL],\n    withExpression: ({ el, name, expression, dataStack, actions, reactivity: { effect } }) => {\n      const signalFn = functionGenerator(expression)\n\n      const elementData: NamespacedReactiveRecords = {\n        bind: {\n          [name]: effect(() => {\n            if (!dataStack?.signals) return\n            const res = signalFn(el, dataStack, actions)\n            el.setAttribute(name, `${res}`)\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { SIGNAL } from '.'\nimport { addDataExtension, toHTMLorSVGElement } from '../core'\n\nexport const FOCUS = 'focus'\nexport function addFocusDataExtension() {\n  addDataExtension(FOCUS, {\n    requiredExtensions: [SIGNAL],\n    withExpression: ({ el }) => {\n      const element = toHTMLorSVGElement(el)\n      if (!element?.focus) throw new Error('Element must have a focus method')\n      element.focus()\n      return {}\n    },\n  })\n}\n","const generatedByIdiomorphId = new WeakSet()\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function idiomorph(oldNode: Document | Element, newContent: string | Element, config = {}) {\n  if (oldNode instanceof Document) {\n    oldNode = oldNode.documentElement\n  }\n\n  let parsedContent: Element\n  if (typeof newContent === 'string') {\n    parsedContent = parseContent(newContent) as Element\n  } else {\n    parsedContent = newContent\n  }\n\n  const normalizedContent = normalizeContent(parsedContent)\n  const ctx = createMorphContext(oldNode, normalizedContent, config)\n\n  return morphNormalizedContent(oldNode, normalizedContent, ctx)\n}\n\nfunction morphNormalizedContent(oldNode: Element, normalizedNewContent: Element, ctx: any) {\n  if (ctx.head.block) {\n    const oldHead = oldNode.querySelector('head')\n    const newHead = normalizedNewContent.querySelector('head')\n    if (oldHead && newHead) {\n      const promises = handleHeadElement(newHead, oldHead, ctx)\n      // when head promises resolve, call morph again, ignoring the head tag\n      Promise.all(promises).then(() => {\n        morphNormalizedContent(\n          oldNode,\n          normalizedNewContent,\n          Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          }),\n        )\n      })\n      return\n    }\n  }\n\n  if (ctx.morphStyle === 'innerHTML') {\n    // innerHTML, so we are only updating the children\n    morphChildren(normalizedNewContent, oldNode, ctx)\n    return oldNode.children\n  } else if (ctx.morphStyle === 'outerHTML' || ctx.morphStyle == null) {\n    // otherwise find the best element match in the new content, morph that, and merge its siblings\n    // into either side of the best match\n    const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx)\n    if (!bestMatch) throw new Error('Could not find best match')\n\n    // stash the siblings that will need to be inserted on either side of the best match\n    const previousSibling = bestMatch?.previousSibling as Element\n    const nextSibling = bestMatch?.nextSibling as Element\n\n    // morph it\n    const morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx)\n\n    if (bestMatch) {\n      // if there was a best match, merge the siblings in too and return the\n      // whole bunch\n      return insertSiblings(previousSibling, morphedNode, nextSibling)\n    } else {\n      // otherwise nothing was added to the DOM\n      return []\n    }\n  } else {\n    throw 'Do not understand how to morph style ' + ctx.morphStyle\n  }\n}\n\n/**\n * @param oldNode root node to merge content into\n * @param newContent new content to merge\n * @param ctx the merge context\n * @returns {Element} the element that ended up in the DOM\n */\nfunction morphOldNodeTo(oldNode: Element, newContent: Element, ctx: any) {\n  if (ctx.ignoreActive && oldNode === document.activeElement) {\n    // don't morph focused element\n  } else if (newContent == null) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n\n    oldNode.remove()\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return\n  } else if (!isSoftMatch(oldNode, newContent)) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n    if (ctx.callbacks.beforeNodeAdded(newContent) === false) return\n\n    if (!oldNode.parentElement) throw new Error('oldNode has no parentElement')\n    oldNode.parentElement.replaceChild(newContent, oldNode)\n    ctx.callbacks.afterNodeAdded(newContent)\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return newContent\n  } else {\n    if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return\n\n    if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n      // ignore the head element\n    } else if (\n      newContent instanceof HTMLHeadElement &&\n      oldNode instanceof HTMLHeadElement &&\n      ctx.head.style !== 'morph'\n    ) {\n      handleHeadElement(newContent, oldNode, ctx)\n    } else {\n      syncNodeFrom(newContent, oldNode)\n      morphChildren(newContent, oldNode, ctx)\n    }\n    ctx.callbacks.afterNodeMorphed(oldNode, newContent)\n    return oldNode\n  }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n * @param {Element} newParent the parent element of the new content\n * @param {Element } oldParent the old content that we are merging the new content into\n * @param ctx the merge context\n */\nfunction morphChildren(newParent: Element, oldParent: Element, ctx: any) {\n  let nextNewChild = newParent.firstChild as Element | null\n  let insertionPoint = oldParent.firstChild as Element | null\n  let newChild\n\n  // run through all the new content\n  while (nextNewChild) {\n    newChild = nextNewChild\n    nextNewChild = newChild.nextSibling as Element | null\n\n    // if we are at the end of the exiting parent's children, just append\n    if (insertionPoint == null) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n      oldParent.appendChild(newChild)\n      ctx.callbacks.afterNodeAdded(newChild)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // if the current node has an id set match then morph\n    if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n      morphOldNodeTo(insertionPoint, newChild, ctx)\n      insertionPoint = insertionPoint.nextSibling as Element | null\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // otherwise search forward in the existing old children for an id set match\n    let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx)\n\n    // if we found a potential match, remove the nodes until that point and morph\n    if (idSetMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx)\n      morphOldNodeTo(idSetMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // no id set match found, so scan forward for a soft match for the current node\n    let softMatch = findSoftMatch(newParent, newChild, insertionPoint, ctx)\n\n    // if we found a soft match for the current node, morph\n    if (softMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx)\n      morphOldNodeTo(softMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // abandon all hope of morphing, just insert the new child before the insertion point\n    // and move on\n    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n    oldParent.insertBefore(newChild, insertionPoint)\n    ctx.callbacks.afterNodeAdded(newChild)\n    removeIdsFromConsideration(ctx, newChild)\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint !== null) {\n    let tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling as Element | null\n    removeNode(tempNode, ctx)\n  }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\n/**\n * syncs a given node with another node, copying over all attributes and\n * inner element state from the 'from' node to the 'to' node\n *\n * @param {Element} from the element to copy attributes & state from\n * @param {Element} to the element to copy attributes & state to\n */\nfunction syncNodeFrom(from: Element, to: Element) {\n  let type = from.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    for (const fromAttribute of from.attributes) {\n      const toAttribute = to.getAttribute(fromAttribute.name)\n      if (toAttribute !== fromAttribute.value) {\n        to.setAttribute(fromAttribute.name, fromAttribute.value)\n      }\n    }\n    for (const toAttribute of to.attributes) {\n      if (!from.hasAttribute(toAttribute.name)) {\n        to.removeAttribute(toAttribute.name)\n      }\n    }\n  }\n\n  // sync text nodes\n  if (type === Node.COMMENT_NODE || type === Node.TEXT_NODE) {\n    if (to.nodeValue !== from.nodeValue) {\n      to.nodeValue = from.nodeValue\n    }\n  }\n\n  // NB: many bothans died to bring us information:\n  //\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  // https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n\n  // sync input value\n  if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== 'file') {\n    to.value = from.value || ''\n    syncAttribute(from, to, 'value')\n\n    // sync boolean attributes\n    syncAttribute(from, to, 'checked')\n    syncAttribute(from, to, 'disabled')\n  } else if (from instanceof HTMLOptionElement) {\n    syncAttribute(from, to, 'selected')\n  } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n    const fromValue = from.value\n    const toValue = to.value\n    if (fromValue !== toValue) {\n      to.value = fromValue\n    }\n    if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n      to.firstChild.nodeValue = fromValue\n    }\n  }\n}\n\nfunction syncAttribute(from: Element, to: Element, attributeName: string) {\n  const fAttr = from.getAttribute(attributeName)\n  const tAttr = to.getAttribute(attributeName)\n\n  if (fAttr !== tAttr) {\n    if (fAttr) {\n      to.setAttribute(attributeName, fAttr)\n    } else {\n      to.removeAttribute(attributeName)\n    }\n  }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(newHeadTag: HTMLHeadElement, currentHead: HTMLHeadElement, ctx: any) {\n  const added = []\n  const removed = []\n  const preserved = []\n  const nodesToAppend = []\n\n  const headMergeStyle = ctx.head.style\n\n  // put all new head elements into a Map, by their outerHTML\n  const srcToNewHeadNodes = new Map()\n  for (const newHeadChild of newHeadTag.children) {\n    srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild)\n  }\n\n  // for each elt in the current head\n  for (const currentHeadElt of currentHead.children) {\n    // If the current head element is in the map\n    let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML)\n    let isReAppended = ctx.head.shouldReAppend(currentHeadElt)\n    let isPreserved = ctx.head.shouldPreserve(currentHeadElt)\n    if (inNewContent || isPreserved) {\n      if (isReAppended) {\n        // remove the current version and let the new version replace it and re-execute\n        removed.push(currentHeadElt)\n      } else {\n        // this element already exists and should not be re-appended, so remove it from\n        // the new content map, preserving it in the DOM\n        srcToNewHeadNodes.delete(currentHeadElt.outerHTML)\n        preserved.push(currentHeadElt)\n      }\n    } else {\n      if (headMergeStyle === 'append') {\n        // we are appending and this existing element is not new content\n        // so if and only if it is marked for re-append do we do anything\n        if (isReAppended) {\n          removed.push(currentHeadElt)\n          nodesToAppend.push(currentHeadElt)\n        }\n      } else {\n        // if this is a merge, we remove this content since it is not in the new head\n        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n          removed.push(currentHeadElt)\n        }\n      }\n    }\n  }\n\n  // Push the remaining new head elements in the Map into the\n  // nodes to append to the head tag\n  nodesToAppend.push(...srcToNewHeadNodes.values())\n  console.log('to append: ', nodesToAppend)\n\n  const promises = []\n  for (const newNode of nodesToAppend) {\n    console.log('adding: ', newNode)\n    const newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild as Element | null\n    if (!newElt) throw new Error('could not create new element from: ' + newNode.outerHTML)\n    console.log(newElt)\n    if (!!ctx.callbacks.beforeNodeAdded(newElt)) {\n      if (newElt.hasAttribute('href') || newElt.hasAttribute('src')) {\n        let resolver: (value: unknown) => void\n        const promise = new Promise((resolve) => {\n          resolver = resolve\n        })\n        newElt.addEventListener('load', function () {\n          resolver(undefined)\n        })\n        promises.push(promise)\n      }\n      currentHead.appendChild(newElt)\n      ctx.callbacks.afterNodeAdded(newElt)\n      added.push(newElt)\n    }\n  }\n\n  // remove all removed elements, after we have appended the new elements to avoid\n  // additional network requests for things like style sheets\n  for (const removedElement of removed) {\n    if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n      currentHead.removeChild(removedElement)\n      ctx.callbacks.afterNodeRemoved(removedElement)\n    }\n  }\n\n  ctx.head.afterHeadMorphed(currentHead, {\n    added: added,\n    kept: preserved,\n    removed: removed,\n  })\n  return promises\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\nfunction noOp() {}\n\nfunction createMorphContext(oldNode: Element, newContent: Element, config: any) {\n  return {\n    target: oldNode,\n    newContent: newContent,\n    config: config,\n    morphStyle: config.morphStyle,\n    ignoreActive: config.ignoreActive,\n    idMap: createIdMap(oldNode, newContent),\n    deadIds: new Set(),\n    callbacks: Object.assign(\n      {\n        beforeNodeAdded: noOp,\n        afterNodeAdded: noOp,\n        beforeNodeMorphed: noOp,\n        afterNodeMorphed: noOp,\n        beforeNodeRemoved: noOp,\n        afterNodeRemoved: noOp,\n      },\n      config.callbacks,\n    ),\n    head: Object.assign(\n      {\n        style: 'merge',\n        shouldPreserve: (elt: Element) => elt.getAttribute('im-preserve') === 'true',\n        shouldReAppend: (elt: Element) => elt.getAttribute('im-re-append') === 'true',\n        shouldRemove: noOp,\n        afterHeadMorphed: noOp,\n      },\n      config.head,\n    ),\n  }\n}\n\nfunction isIdSetMatch(node1: Element, node2: Element, ctx: any) {\n  if (!node1 || !node2) return false\n\n  if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n    if (node1?.id?.length && node1.id === node2.id) return true\n\n    return getIdIntersectionCount(ctx, node1, node2) > 0\n  }\n  return false\n}\n\nfunction isSoftMatch(node1: Element, node2: Element) {\n  if (!node1 || !node2) return false\n\n  return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n}\n\nfunction removeNodesBetween(startInclusive: Element, endExclusive: Element, ctx: any) {\n  while (startInclusive !== endExclusive) {\n    const tempNode = startInclusive\n    startInclusive = startInclusive?.nextSibling as Element\n    if (!tempNode) throw new Error('tempNode is null')\n    removeNode(tempNode, ctx)\n  }\n  removeIdsFromConsideration(ctx, endExclusive)\n  return endExclusive.nextSibling as Element | null\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(newContent: Element, oldParent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  // max id matches we are willing to discard in our search\n  const newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent)\n\n  let potentialMatch: Element | null = null\n\n  // only search forward if there is a possibility of an id match\n  if (newChildPotentialIdCount > 0) {\n    potentialMatch = insertionPoint\n    // if there is a possibility of an id match, scan forward\n    // keep track of the potential id match count we are discarding (the\n    // newChildPotentialIdCount must be greater than this to make it likely\n    // worth it)\n    let otherMatchCount = 0\n    while (potentialMatch != null) {\n      // If we have an id match, return the current potential match\n      if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n        return potentialMatch\n      }\n\n      // computer the other potential matches of this new content\n      otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent)\n      if (otherMatchCount > newChildPotentialIdCount) {\n        // if we have more potential id matches in _other_ content, we\n        // do not have a good candidate for an id match, so return null\n        return null\n      }\n\n      // advanced to the next old content child\n      potentialMatch = potentialMatch.nextSibling as Element | null\n    }\n  }\n  return potentialMatch\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(newContent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  let potentialSoftMatch = insertionPoint as Element | null\n  let nextSibling = newChild.nextSibling as Element | null\n\n  let siblingSoftMatchCount = 0\n\n  while (potentialSoftMatch && nextSibling) {\n    if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n      // the current potential soft match has a potential id set match with the remaining new\n      // content so bail out of looking\n      return null\n    }\n\n    // if we have a soft match with the current node, return it\n    if (isSoftMatch(newChild, potentialSoftMatch)) {\n      return potentialSoftMatch\n    }\n\n    if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n      // the next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling as Element | null\n\n      // If there are two future soft matches, bail to allow the siblings to soft match\n      // so that we don't consume future soft matches for the sake of the current node\n      if (siblingSoftMatchCount >= 2) {\n        return null\n      }\n    }\n\n    // advanced to the next old content child\n    potentialSoftMatch = potentialSoftMatch.nextSibling as Element | null\n  }\n\n  return potentialSoftMatch\n}\n\nconst parser = new DOMParser()\nfunction parseContent(newContent: string) {\n  // remove svgs to avoid false-positive matches on head, etc.\n  const contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '')\n\n  // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n  if (\n    contentWithSvgsRemoved.match(/<\\/html>/) ||\n    contentWithSvgsRemoved.match(/<\\/head>/) ||\n    contentWithSvgsRemoved.match(/<\\/body>/)\n  ) {\n    const content = parser.parseFromString(newContent, 'text/html')\n    // if it is a full HTML document, return the document itself as the parent container\n    if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n      generatedByIdiomorphId.add(content)\n      return content\n    } else {\n      // otherwise return the html element as the parent container\n      let Element = content.firstChild\n      if (Element) {\n        generatedByIdiomorphId.add(Element)\n        return Element as Element\n      } else {\n        return null\n      }\n    }\n  } else {\n    // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n    // deal with touchy tags like tr, tbody, etc.\n    const responseDoc = parser.parseFromString(`<body><template>${newContent}</template></body>`, 'text/html')\n    const content = responseDoc.body.querySelector('template')?.content\n    if (!content) throw new Error('content is null')\n    generatedByIdiomorphId.add(content)\n    return content\n  }\n}\n\nfunction normalizeContent(newContent: Element) {\n  if (newContent == null) {\n    // noinspection UnnecessaryLocalVariableJS\n    const dummyParent = document.createElement('div')\n    return dummyParent\n  } else if (generatedByIdiomorphId.has(newContent)) {\n    // the template tag created by idiomorph parsing can serve as a dummy parent\n    return newContent\n  } else if (newContent instanceof Node) {\n    // a single node is added as a child to a dummy parent\n    const dummyParent = document.createElement('div')\n    dummyParent.append(newContent)\n    return dummyParent\n  } else {\n    // all nodes in the array or Element collection are consolidated under\n    // a single dummy parent element\n    const dummyParent = document.createElement('div')\n    for (const elt of [...newContent]) {\n      dummyParent.append(elt)\n    }\n    return dummyParent\n  }\n}\n\nfunction insertSiblings(previousSibling?: Element, morphedNode?: Element, nextSibling?: Element) {\n  const stack = []\n  const added = []\n  while (previousSibling) {\n    stack.push(previousSibling)\n    previousSibling = previousSibling.previousSibling as Element\n  }\n  while (stack.length > 0) {\n    const node = stack.pop()!\n    added.push(node) // push added preceding siblings on in order and insert\n    morphedNode?.parentElement?.insertBefore(node, morphedNode)\n  }\n  added.push(morphedNode)\n  while (nextSibling) {\n    stack.push(nextSibling)\n    added.push(nextSibling) // here we are going in order, so push on as we scan, rather than add\n    nextSibling = nextSibling.nextSibling as Element\n  }\n  while (stack.length) {\n    morphedNode?.parentElement?.insertBefore(stack.pop()!, morphedNode.nextSibling)\n  }\n  return added\n}\n\nfunction findBestNodeMatch(newContent: Element, oldNode: Element, ctx: any) {\n  let currentElement = newContent.firstChild as Element | null\n  let bestElement = currentElement\n  let score = 0\n  while (currentElement) {\n    let newScore = scoreElement(currentElement, oldNode, ctx)\n    if (newScore > score) {\n      bestElement = currentElement\n      score = newScore\n    }\n    currentElement = currentElement.nextSibling as Element | null\n  }\n  return bestElement\n}\n\nfunction scoreElement(node1: Element, node2: Element, ctx: any) {\n  if (isSoftMatch(node1, node2)) {\n    return 0.5 + getIdIntersectionCount(ctx, node1, node2)\n  }\n  return 0\n}\n\nfunction removeNode(tempNode: Element, ctx: any) {\n  removeIdsFromConsideration(ctx, tempNode)\n  if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return\n\n  tempNode.remove()\n  ctx.callbacks.afterNodeRemoved(tempNode)\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: any, id: string) {\n  return !ctx.deadIds.has(id)\n}\n\nfunction idIsWithinNode(ctx: any, id: string, targetNode: Element) {\n  return ctx.idMap.get(targetNode)?.has(id) || false\n}\n\nfunction removeIdsFromConsideration(ctx: any, node: Element) {\n  const idSet = ctx.idMap.get(node)\n  if (!idSet) return\n  for (const id of idSet) {\n    ctx.deadIds.add(id)\n  }\n}\n\nfunction getIdIntersectionCount(ctx: any, node1: Element, node2: Element) {\n  const sourceSet = ctx.idMap.get(node1)\n  if (!sourceSet) return 0\n\n  let matchCount = 0\n  for (const id of sourceSet) {\n    // a potential match is an id in the source and potentialIdsSet, but\n    // that has not already been merged into the DOM\n    if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n      ++matchCount\n    }\n  }\n  return matchCount\n}\n\n/**\n * A bottom up algorithm that finds all elements with ids inside of the node\n * argument and populates id sets for those nodes and all their parents, generating\n * a set of ids contained within all nodes for the entire hierarchy in the DOM\n *\n * @param node {Element}\n * @param {Map<Node, Set<String>>} idMap\n */\nfunction populateIdMapForNode(node: Element, idMap: Map<Element, Set<string>>) {\n  const nodeParent = node.parentElement\n  // find all elements with an id property\n  const idElements = node.querySelectorAll('[id]')\n  for (const elt of idElements) {\n    let current = elt as Element | null\n    // walk up the parent hierarchy of that element, adding the id\n    // of element to the parent's id set\n    while (current !== nodeParent && !!current) {\n      let idSet = idMap.get(current)\n      // if the id set doesn't exist, create it and insert it in the  map\n      if (idSet == null) {\n        idSet = new Set()\n        idMap.set(current, idSet)\n      }\n      idSet.add(elt.id)\n      current = current.parentElement\n    }\n  }\n}\n\n/**\n * This function computes a map of nodes to all ids contained within that node (inclusive of the\n * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n * to contribute to a parent nodes matching.\n *\n * @param {Element} oldContent  the old content that will be morphed\n * @param {Element} newContent  the new content to morph to\n * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n */\nfunction createIdMap(oldContent: Element, newContent: Element) {\n  const idMap = new Map()\n  populateIdMapForNode(oldContent, idMap)\n  populateIdMapForNode(newContent, idMap)\n  return idMap\n}\n","import { ActionArgs } from '..'\nimport { addActionExtension, toHTMLorSVGElement } from '../core'\nimport { idiomorph } from '../external/idiomorph'\nimport { Reactive } from '../external/reactively'\nconst p = new DOMParser()\nconst DATASTAR_CLASS_PREFIX = 'datastar'\nconst INDICATOR_CLASS = `${DATASTAR_CLASS_PREFIX}-indicator`\nconst LOADING_CLASS = `${DATASTAR_CLASS_PREFIX}-request`\nconst ACCEPT = 'Accept',\n  TEXT_HTML = 'text/html',\n  CONTENT_TYPE = 'Content-Type',\n  APPLICATION_JSON = 'application/json',\n  SELECTOR = 'selector',\n  SWAP = 'swap'\n\nexport const GET = 'get'\nexport const addGetExtension = () => addFetchMethod(GET)\nexport const POST = 'post'\nexport const addPostExtension = () => addFetchMethod(POST)\nexport const PUT = 'put'\nexport const addPutExtension = () => addFetchMethod(PUT)\nexport const PATCH = 'patch'\nexport const addPatchExtension = () => addFetchMethod(PATCH)\nexport const DELETE = 'delete'\nexport const addDeleteExtension = () => addFetchMethod(DELETE)\n\nexport const addAllFragmentExtensions = () => {\n  addGetExtension()\n  addPostExtension()\n  addPutExtension()\n  addPatchExtension()\n  addDeleteExtension()\n}\n\nlet hasInjectedStyles = false\nfunction addFetchMethod(method: string) {\n  if (!hasInjectedStyles) {\n    const style = document.createElement('style')\n    style.innerHTML = `\n.${INDICATOR_CLASS}{\n  opacity:0;\n  transition: opacity 500ms ease-in;\n}\n.${LOADING_CLASS} .${INDICATOR_CLASS}{\n    opacity:1\n}\n.${LOADING_CLASS}.${INDICATOR_CLASS}{\n    opacity:1\n}\n    `\n    document.head.appendChild(style)\n    hasInjectedStyles = true\n  }\n\n  addActionExtension({\n    name: method,\n    description: `turns @${method}(args) into fetch(${method}, args)`,\n    fn: async (args: ActionArgs) => fetcher(method, args),\n  })\n}\n\nasync function fetcher(method: string, args: ActionArgs) {\n  const { el: elRaw, dataStack } = args\n\n  const urlSignal: Reactive<string> = dataStack.signals?.[method]\n  if (!urlSignal) throw new Error(`No signal for ${method}`)\n\n  const el = toHTMLorSVGElement(elRaw)\n  if (!el) throw new Error('Element must be an HTMLElement or SVGElement')\n\n  el.classList.add(LOADING_CLASS)\n\n  const url = new URL(urlSignal.value, window.location.origin)\n\n  const headers = new Headers()\n\n  headers.append(ACCEPT, TEXT_HTML)\n  headers.append(CONTENT_TYPE, APPLICATION_JSON)\n\n  if (dataStack?.headers) {\n    for (let name in dataStack.headers) {\n      const signal = dataStack.headers[name]\n      headers.append(name, signal.value)\n    }\n  }\n\n  const dataStackJSON = JSON.stringify(dataStack, (_, value) => {\n    if (value instanceof Reactive) {\n      if (value.isEffect) return undefined\n      return value.get()\n    }\n    return value\n  })\n  const req: RequestInit = { method, headers }\n  if (method === GET) {\n    const queryParams = new URLSearchParams(url.search)\n    queryParams.append('dataStack', dataStackJSON)\n    url.search = queryParams.toString()\n  } else {\n    req.body = dataStackJSON\n  }\n\n  const res = await fetch(url, req)\n  if (!res.ok) throw new Error('Network response was not ok.')\n  const html = await res.text()\n\n  const dom = [...p.parseFromString(html, TEXT_HTML).body.children]\n  for (let i = 0; i < dom.length; i++) {\n    const frag = dom[i]\n    if (!(frag instanceof Element)) {\n      throw new Error('Not an element')\n    }\n    const fragElement = toHTMLorSVGElement(frag)\n\n    const id = frag.getAttribute('id')\n    const firstFrag = i === 0\n    const hasID = !!id?.length\n    const useElAsTarget = firstFrag && !hasID\n\n    let targets: Iterable<Element>\n    if (useElAsTarget) {\n      targets = [elRaw]\n    } else {\n      if (!hasID) throw new Error('No id')\n\n      const targetSelector = fragElement?.dataset?.[SELECTOR] || `#${id}`\n      targets = document.querySelectorAll(targetSelector) || []\n    }\n    if (!!!targets) throw new Error('No target element')\n\n    for (const target of targets) {\n      const merge = fragElement?.dataset?.[SWAP] || 'morph'\n      switch (merge) {\n        case 'morph':\n          idiomorph(target, frag)\n          break\n        case 'inner':\n          target.innerHTML = frag.innerHTML //  The default, replace the inner html of the target element\n          break\n        case 'outer':\n          target.outerHTML = frag.outerHTML //  Replace the entire target element with the response\n          break\n        case 'prepend':\n          target.prepend(frag.outerHTML) //  Insert the response before the first child of the target element\n          break\n        case 'append':\n          target.append(frag.outerHTML) //  Insert the response after the last child of the target element\n          break\n        case 'before':\n          target.before(frag) //  Insert the response before the target element\n          break\n        case 'after':\n          target.after(frag) //  Insert the response after the target element\n          break\n        case 'delete':\n          target.remove() //  Deletes the target element regardless of the response\n          break\n        default:\n          throw new Error('Invalid merge mode')\n      }\n    }\n  }\n\n  el.classList.remove(LOADING_CLASS)\n}\n","import { SIGNAL } from '.'\nimport { addDataExtension, uniqueId } from '../core'\n\nexport const MODEL = 'model'\nconst updateEvents = ['change', 'input', 'keydown']\nexport function addModelDataExtension() {\n  addDataExtension(MODEL, {\n    allowedTags: ['input', 'textarea', 'select'],\n    requiredExtensions: [SIGNAL],\n\n    withExpression: ({ name, el, expression, dataStack, reactivity: { effect, onCleanup } }) => {\n      const signal = dataStack.signals[expression]\n      if (!signal) {\n        throw new Error(`Signal ${expression} not found`)\n      }\n\n      if (!('value' in el)) throw new Error('Element must have a value property')\n      el.value = signal.value\n\n      const setter = () => {\n        const current = signal.value\n        if (typeof current === 'number') {\n          signal.value = Number(el.value)\n        } else if (typeof current === 'string') {\n          signal.value = el.value\n        } else if (typeof current === 'boolean') {\n          signal.value = Boolean(el.value)\n        } else {\n          throw new Error('Unsupported type')\n        }\n      }\n\n      return {\n        model: {\n          [`${name}-${uniqueId()}`]: effect(() => {\n            el.value = signal.value\n\n            for (const event of updateEvents) {\n              el.addEventListener(event, setter)\n            }\n\n            onCleanup(() => {\n              for (const event of updateEvents) {\n                el.removeEventListener(event, setter)\n              }\n            })\n          }),\n        },\n      }\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataExtension } from '../core'\n\nexport const ON = 'on'\n\nconst ONCE = 'once',\n  THROTTLE = 'throttle',\n  DEBOUNCE = 'debounce',\n  LEADING = 'leading'\n\nexport function addOnDataExtension() {\n  addDataExtension(ON, {\n    requiredExtensions: [SIGNAL],\n    allowedModifiers: [ONCE, THROTTLE, DEBOUNCE, LEADING],\n    withExpression: ({\n      el,\n      name,\n      hasMod,\n      withMod,\n      expression,\n      dataStack,\n      reactivity: { computed, effect, onCleanup },\n      actions,\n    }) => {\n      const signalFn = functionGenerator(expression)\n\n      const hasOnce = hasMod(ONCE)\n      const throttleMod = withMod(THROTTLE)\n      const debounceMod = withMod(DEBOUNCE)\n      const hasLeading = hasMod(LEADING)\n\n      if (name === 'load') {\n        document.addEventListener('DOMContentLoaded', () => signalFn(el, dataStack, actions), true)\n        return\n      }\n\n      const fn = () => signalFn(el, dataStack, actions)\n      let wrappedFnCallback: Function = fn\n      let callback: () => void\n\n      if (hasOnce) {\n        wrappedFnCallback = () => {\n          fn()\n          if (callback) {\n            el.removeEventListener(name, callback)\n          }\n        }\n      } else if (!!throttleMod) {\n        const [throttleTimeRaw] = throttleMod.args\n        const throttleTime = throttleTimeRaw ? Number(throttleTimeRaw) : 1000\n\n        let prev = 0\n        const throttledFn = computed(() => {\n          const now = Date.now()\n          const delta = now - prev\n          if (delta >= throttleTime) {\n            prev = now\n            return fn()\n          }\n        })\n\n        wrappedFnCallback = () => throttledFn.value\n      } else if (!!debounceMod) {\n        const [debounceTimeRaw] = debounceMod.args\n        const debounceTime = debounceTimeRaw ? Number(debounceTimeRaw) : 1000\n\n        let timerID: ReturnType<typeof setTimeout> | undefined\n        const debouncedFn = computed(() => {\n          if (hasLeading && !timerID) {\n            fn()\n          }\n          clearTimeout(timerID)\n          timerID = setTimeout(() => {\n            if (hasLeading) timerID = undefined\n            else fn()\n          }, debounceTime)\n        })\n\n        wrappedFnCallback = () => debouncedFn.value\n      }\n\n      callback = () => wrappedFnCallback()\n\n      el.addEventListener(name, callback)\n\n      const elementData: NamespacedReactiveRecords = {\n        on: {\n          [name]: effect(() => {\n            onCleanup(() => {\n              if (hasOnce) return\n\n              el.removeEventListener(name, callback)\n            })\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL } from '..'\nimport { addDataExtension } from '../core'\n\nexport const REF = 'ref'\nexport function addRefDataExtension() {\n  addDataExtension(REF, {\n    requiredExtensions: [SIGNAL],\n    preprocessExpressions: [\n      {\n        name: 'ref',\n        description: 'turns #ref into data.refs.ref.value',\n        regexp: new RegExp(/(?<whole>\\#(?<ref>[a-zA-Z_$][0-9a-zA-Z_$]*))/g),\n        replacer: ({ ref }) => `data.refs.${ref}.value`,\n      },\n    ],\n    withExpression: ({ el, name, reactivity: { signal } }) => {\n      const elementData: NamespacedReactiveRecords = {\n        refs: {\n          [name]: signal(el),\n        },\n      }\n      return elementData\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataExtension } from '../core'\n\nconst IMPORTANT = 'important',\n  DISPLAY = 'display',\n  NONE = 'none'\n\nexport const SHOW = 'show'\nexport function addShowDataExtension() {\n  addDataExtension(SHOW, {\n    requiredExtensions: [SIGNAL],\n    allowedModifiers: [IMPORTANT],\n    withExpression: ({ el, name, dataStack, expression, hasMod, reactivity: { effect }, actions }) => {\n      const signalFn = functionGenerator(expression)\n\n      if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n        throw new Error('Element must have a style property')\n      }\n\n      const isImportant = hasMod(IMPORTANT)\n      const priority = isImportant ? IMPORTANT : undefined\n\n      const elementData: NamespacedReactiveRecords = {\n        show: {\n          [name]: effect(() => {\n            const shouldShow = !!signalFn(el, dataStack, actions)\n            if (shouldShow) {\n              if (el.style.length === 1 && el.style.display === NONE) {\n                el.style.removeProperty(DISPLAY)\n              } else {\n                el.style.setProperty(DISPLAY, '', priority)\n              }\n            } else {\n              el.style.setProperty(DISPLAY, NONE, priority)\n            }\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { functionEval } from '..'\nimport { addDataExtension } from '../core'\nimport { ACTION } from './actions'\n\nexport const SIGNAL = 'signal'\n\nconst PERSIST_KEY = 'persist'\nexport function addSignalDataExtension() {\n  addDataExtension(SIGNAL, {\n    requiredExtensions: [ACTION],\n    preprocessExpressions: [\n      {\n        name: 'signal',\n        description: 'turns $signal into dataStack.signals.signal.value',\n        regexp: new RegExp(/(?<whole>\\$(?<signal>[a-zA-Z_$][0-9a-zA-Z_$]*))/g),\n        replacer: ({ signal }) => `dataStack.${SIGNAL}s.${signal}.value`,\n      },\n    ],\n    allowedModifiers: [PERSIST_KEY],\n    withExpression: ({ name, el, expression, reactivity, hasMod, actions }) => {\n      const signal = reactivity.signal(functionEval(el, {}, actions, expression))\n\n      if (hasMod(PERSIST_KEY)) {\n        const value = localStorage.getItem(name)\n        if (value) {\n          const parsedValue = JSON.parse(value)\n          signal.value = parsedValue\n        }\n\n        reactivity.effect(() => {\n          const value = JSON.stringify(signal.value)\n          localStorage.setItem(name, value)\n        })\n      }\n\n      return {\n        signals: {\n          [name]: signal,\n        },\n      }\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataExtension, toHTMLorSVGElement } from '../core'\n\nconst PREPEND = 'prepend',\n  APPEND = 'append',\n  MUST_PARENT_ERR = 'Target element must have a parent if using prepend or append'\n\nexport const TELEPORT = 'teleport'\nexport function addTeleportDataExtension() {\n  addDataExtension(TELEPORT, {\n    requiredExtensions: [SIGNAL],\n    allowedModifiers: [PREPEND, APPEND],\n    withExpression: ({ name, el, expression, dataStack, reactivity: { effect }, hasMod, actions }) => {\n      if (!(el instanceof HTMLTemplateElement)) {\n        throw new Error('Element must be a template')\n      }\n\n      const signalFn = functionGenerator(expression)\n\n      const elementData: NamespacedReactiveRecords = {\n        text: {\n          [name]: effect(() => {\n            const res = signalFn(el, dataStack, actions)\n            if (typeof res !== 'string') throw new Error('Selector must be a string')\n            const target = document.querySelector(res)\n            if (!target) throw new Error(`Target element not found: ${res}`)\n\n            if (!el.content) throw new Error('Template element must have content')\n            const n = el.content.cloneNode(true)\n            const nEl = toHTMLorSVGElement(n as Element)\n            if (nEl?.firstElementChild) throw new Error('Empty template')\n\n            if (hasMod(PREPEND)) {\n              if (!target.parentNode) throw new Error(MUST_PARENT_ERR)\n              target.parentNode.insertBefore(n, target)\n            } else if (hasMod(APPEND)) {\n              if (!target.parentNode) throw new Error(MUST_PARENT_ERR)\n              target.parentNode.insertBefore(n, target.nextSibling)\n            } else {\n              target.appendChild(n)\n            }\n            target.appendChild(n)\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { NamespacedReactiveRecords, functionGenerator } from '..'\nimport { addDataExtension } from '../core'\n\nexport const TEXT = 'text'\nexport function addTextDataExtension() {\n  addDataExtension(TEXT, {\n    withExpression: ({ name, el, expression, dataStack, actions, reactivity: { effect } }) => {\n      const signalFn = functionGenerator(expression)\n\n      const elementData: NamespacedReactiveRecords = {\n        text: {\n          [name]: effect(() => {\n            if (!dataStack?.signals) return\n            const res = signalFn(el, dataStack, actions)\n            el.textContent = `${res}`\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { NamespacedReactiveRecords, SIGNAL, functionGenerator } from '..'\nimport { addDataExtension } from '../core'\n\nconst once = 'once',\n  full = 'full',\n  half = 'half'\n\nexport const INTERSECTS = 'intersects'\nexport function addIntersectsExtension() {\n  addDataExtension(INTERSECTS, {\n    requiredExtensions: [SIGNAL],\n    allowedModifiers: [once, full, half],\n    withExpression: ({ name, el, expression, dataStack, actions, hasMod, reactivity: { effect, onCleanup } }) => {\n      const signalFn = functionGenerator(expression)\n      const fn = () => signalFn(el, dataStack, actions)\n\n      const options = { threshold: 0 }\n      if (hasMod(full)) options.threshold = 1\n      else if (hasMod(half)) options.threshold = 0.5\n\n      const observer = new IntersectionObserver((entries) => {\n        entries.forEach((entry) => {\n          if (entry.isIntersecting) {\n            fn()\n\n            if (hasMod(once)) {\n              observer.disconnect()\n            }\n          }\n        })\n      }, options)\n\n      const elementData: NamespacedReactiveRecords = {\n        on: {\n          [name]: effect(() => {\n            observer.observe(el)\n\n            onCleanup(() => {\n              observer.disconnect()\n            })\n          }),\n        },\n      }\n\n      return elementData\n    },\n  })\n}\n","import { addActionDataExtension } from './actions.js'\nimport { addBindDataExtension } from './bind.js'\nimport { addFocusDataExtension } from './focus.js'\nimport { addAllFragmentExtensions } from './fragments.js'\nimport { addModelDataExtension } from './model.js'\nimport { addOnDataExtension } from './on.js'\nimport { addRefDataExtension } from './ref.js'\nimport { addShowDataExtension } from './show.js'\nimport { addSignalDataExtension } from './signal.js'\nimport { addTeleportDataExtension } from './teleport.js'\nimport { addTextDataExtension } from './text.js'\n\nexport * from './bind.js'\nexport * from './focus.js'\nexport * from './fragments.js'\nexport * from './intersects.js'\nexport * from './on.js'\nexport * from './ref.js'\nexport * from './show.js'\nexport * from './signal.js'\nexport * from './teleport.js'\nexport * from './text.js'\n\nexport function addAllIncludedExtensions() {\n  addActionDataExtension()\n  addSignalDataExtension()\n  addBindDataExtension()\n  addModelDataExtension()\n  addFocusDataExtension()\n  addAllFragmentExtensions()\n  addOnDataExtension()\n  addRefDataExtension()\n  addShowDataExtension()\n  addTeleportDataExtension()\n  addTextDataExtension()\n}\n","export interface MockedResponse {\n  html: string\n  status?: number\n  statusText?: string\n  headers?: Headers\n}\n\nexport interface MockFetchRoutes {\n  [url: string]: {\n    [method: string]: (req: Request) => Promise<MockedResponse>\n  }\n}\n\nexport function injectMockFetch(routes: MockFetchRoutes) {\n  console.warn(`Overriding fetch with mock version, this should only be used in examples.`)\n\n  const mockFetch = async (url: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n    const req = new Request(url, init)\n\n    if (!(url instanceof URL)) throw new Error(`url must be a URL`)\n\n    const urlMethods = routes[url.pathname]\n    if (!urlMethods) throw new Error(`No mock route found for ${req.url}`)\n\n    const methodFn = urlMethods[req.method]\n    if (!methodFn) throw new Error(`No mock route found for ${req.method} ${req.url}`)\n\n    let { html, status, statusText, headers } = await methodFn(req)\n    if (!headers) headers = new Headers()\n    if (!headers.has('Content-Type')) headers.append('Content-Type', 'text/html')\n    status = status || 200\n    statusText = statusText || 'OK'\n\n    const res = new Response(html, { status, statusText, headers })\n    return res\n  }\n\n  window.fetch = mockFetch\n}\n"],"names":["walkDownDOM","el","callback","walkUpDOM","functionGenerator","str","fnContents","functionEval","dataStack","actions","fn","camelize","word","index","CurrentReaction","CurrentGets","CurrentGetsIndex","EffectQueue","stabilizeFn","stabilizationQueued","CacheClean","CacheCheck","CacheDirty","reactive","fnOrValue","params","node","Reactive","defaultEquality","a","b","isEffect","v","value","i","state","oldValue","prevReaction","prevGets","prevIndex","c","source","observer","swap","onCleanup","stabilize","autoStabilize","deferredStabilize","signal","initialValue","computed","effect","extensionObserver","mutations","m","extensionElementRegistry","extensionApplyFunctions","useProcessor","regexp","replacer","matches","match","groups","whole","cyrb53","seed","h1","h2","ch","prefixHashes","extensionPreprocessStack","data","addDataExtension","prefix","args","hash","extension","extensionsRegistered","requiredExtension","allAllowedModifiers","modifier","allowedTags","t","registerExtensionOnElement","parentEl","element","toHTMLorSVGElement","extensions","tagLower","d","name","modifiersWithArgsArr","pl","pl1","modifiers","label","allowedModifier","loadDataStack","expression","preprocessor","elementData","postExpression","withModifier","hasModifier","stack","elData","namespacedRecords","namespaceKey","addActionExtension","requiredExtensions","extensionHashes","ACTION","ext","nextID","uniqueId","addActionDataExtension","action","BIND","addBindDataExtension","SIGNAL","signalFn","res","FOCUS","addFocusDataExtension","generatedByIdiomorphId","idiomorph","oldNode","newContent","config","parsedContent","parseContent","normalizedContent","normalizeContent","ctx","createMorphContext","morphNormalizedContent","normalizedNewContent","oldHead","newHead","promises","handleHeadElement","morphChildren","bestMatch","findBestNodeMatch","previousSibling","nextSibling","morphedNode","morphOldNodeTo","insertSiblings","isSoftMatch","syncNodeFrom","newParent","oldParent","nextNewChild","insertionPoint","newChild","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","from","to","type","fromAttribute","toAttribute","syncAttribute","fromValue","toValue","attributeName","fAttr","tAttr","newHeadTag","currentHead","added","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","newHeadChild","currentHeadElt","inNewContent","isReAppended","isPreserved","newNode","newElt","resolver","promise","resolve","removedElement","noOp","createIdMap","elt","node1","node2","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","parser","contentWithSvgsRemoved","content","Element","dummyParent","currentElement","bestElement","score","newScore","scoreElement","isIdInConsideration","id","idIsWithinNode","targetNode","idSet","sourceSet","matchCount","populateIdMapForNode","idMap","nodeParent","idElements","current","oldContent","p","DATASTAR_CLASS_PREFIX","INDICATOR_CLASS","LOADING_CLASS","ACCEPT","TEXT_HTML","CONTENT_TYPE","APPLICATION_JSON","SELECTOR","SWAP","GET","addGetExtension","addFetchMethod","POST","addPostExtension","PUT","addPutExtension","PATCH","addPatchExtension","DELETE","addDeleteExtension","addAllFragmentExtensions","hasInjectedStyles","method","style","fetcher","elRaw","urlSignal","url","headers","dataStackJSON","_","req","queryParams","html","dom","frag","fragElement","firstFrag","hasID","useElAsTarget","targets","targetSelector","target","MODEL","updateEvents","addModelDataExtension","setter","event","ON","ONCE","THROTTLE","DEBOUNCE","LEADING","addOnDataExtension","hasMod","withMod","hasOnce","throttleMod","debounceMod","hasLeading","wrappedFnCallback","throttleTimeRaw","throttleTime","prev","throttledFn","now","debounceTimeRaw","debounceTime","timerID","debouncedFn","REF","addRefDataExtension","ref","IMPORTANT","DISPLAY","NONE","SHOW","addShowDataExtension","priority","PERSIST_KEY","addSignalDataExtension","reactivity","parsedValue","PREPEND","APPEND","MUST_PARENT_ERR","TELEPORT","addTeleportDataExtension","n","TEXT","addTextDataExtension","once","full","half","INTERSECTS","addIntersectsExtension","options","entries","entry","addAllIncludedExtensions","injectMockFetch","routes","mockFetch","init","urlMethods","methodFn","status","statusText"],"mappings":"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"}